{"meta":{"title":"个人技术博客","subtitle":"记录了一些与JAVA相关的技术文章","description":"学习与工作总结","author":"杨发","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-11-30T06:41:57.000Z","updated":"2019-11-30T08:45:32.174Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-30T06:42:05.000Z","updated":"2019-11-30T08:45:18.243Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-27T14:29:50.000Z","updated":"2019-11-30T08:45:08.311Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git分支与冲突","slug":"JAVA/Git分支与冲突","date":"2019-12-06T16:00:00.000Z","updated":"2020-01-01T02:53:33.649Z","comments":true,"path":"2019/12/07/JAVA/Git分支与冲突/","link":"","permalink":"http://yoursite.com/2019/12/07/JAVA/Git%E5%88%86%E6%94%AF%E4%B8%8E%E5%86%B2%E7%AA%81/","excerpt":"","text":"GIT分支与冲突分支分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。火影忍者里面的鸣人学习妙木山仙术的那种情景。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 在 版本回退里，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即 master 分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上 从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变 假如我们在dev上的工作完成了，就可以把dev合并到master上。 Git怎么合并呢？最简单的方法，直接把master指向dev的当前提交，就完成了合并 git branch -v 查看分支时，会列出所有的分支，当前分支前面会添加一个星号。 1git checkout -b 123 // 创建并切换到123分支上 然后我们在123分支上继续做demo，比如我们现在在test.txt再增加一些内容。 把test.txt 添加到本地库 使用 git branch -v 查看分支 这两个分支的版本号已经不一致了，123 分支已经比master分支领先一个版本了。 现在 123 分支工作已完成，现在我们切换到主分支master上，继续查看test.txt内容如下： 此时master分支上并没有与之前有任何的变化，因为所有的操作都在123分支上进行的。 现在我们可以把123分支上的内容合并到分支master上了 可以在master分支上，使用如下命令 1git merge 123 // 当前所在的分支 合并 123分支， 被合并的作为参数 如下所示： 合并完成后，我们可以接着删除123分支了，操作如下： 1git branch -d 123 // 只有被合并后的空分支 才可以被删除 冲突先新建一个新分支，比如名字叫 fenzhi1，在test.txt添加一行内容88888888888888，然后提交，如下所示： 同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999999999，如下所示： 这是两个分支上，同一个位置做出了不同的修改，冲突产生。 现在我们需要在master分支上来合并 fenzhi1，如下操作： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容 其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Git&GitHub","slug":"Git-GitHub","permalink":"http://yoursite.com/tags/Git-GitHub/"}]},{"title":"GitHUb","slug":"JAVA/GitHub","date":"2019-12-05T16:00:00.000Z","updated":"2020-01-01T03:57:19.044Z","comments":true,"path":"2019/12/06/JAVA/GitHub/","link":"","permalink":"http://yoursite.com/2019/12/06/JAVA/GitHub/","excerpt":"","text":"GitHub修改本地host，使访问GIitHub变快1、浏览器访问 https://www.ipaddress.com/ 2、修改host文件 12345678910111213141516171819# GitHub Start 140.82.113.3 github.com199.232.5.194 github.global.ssl.fastly.net192.30.253.118 gist.github.com185.199.108.153 assets-cdn.github.com199.232.28.133 raw.githubusercontent.com199.232.28.133 gist.githubusercontent.com199.232.28.133 cloud.githubusercontent.com199.232.28.133 camo.githubusercontent.com199.232.28.133 avatars0.githubusercontent.com199.232.28.133 avatars1.githubusercontent.com199.232.28.133 avatars2.githubusercontent.com199.232.28.133 avatars3.githubusercontent.com199.232.28.133 avatars4.githubusercontent.com199.232.28.133 avatars5.githubusercontent.com199.232.28.133 avatars6.githubusercontent.com199.232.28.133 avatars7.githubusercontent.com199.232.28.133 avatars8.githubusercontent.com # GitHub End 3、更新DNS 1ipconfig /flushdns 把本地Git仓库同步到GitHub在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置： 第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令： 1ssh-keygen -t rsa –C “849949161@qq.com” 由于我本地此前运行过一次，所以本地有，如下所示： id_rsa是私钥，不能泄露出去。id_rsa.pub是公钥，可以放心地告诉任何人。 第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。 点击 Add Key，你就应该可以看到已经添加的key。 如何添加远程库？ 现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。 首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下： 在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 命令如下，每一个repository里出现的命令都不是一样的！ 12git remote add origin https://github.com/yangfa4j/gitTest.git // 本地库与远程库关联起来git push -u origin master // 把本地库的内容推送到GitHub上 既是把我目前在d盘的Git仓库同步到GitHub上。 接下来就会弹出一个窗口，要输入你的GitHub账号密码了。 输入正确的 GitHub 账号，此时Git Bash界面出现 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了 –u 参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了。 从现在起，只要本地作了提交，就可以通过如下命令： 1git push origin master 把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。 把GitHub远程仓库同步到本地Git仓库现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？ 首先，登录github，创建一个新的仓库，名字叫testgit2 如下： 如下，我们看到远程GitHub仓库只有一个README.md文件： 现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示： git clone后面跟当前repository浏览器地址。 接着在我本地目录下 生成testgit2目录了，如下所示：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Git&GitHub","slug":"Git-GitHub","permalink":"http://yoursite.com/tags/Git-GitHub/"}]},{"title":"JVM","slug":"JAVA/JVM","date":"2019-12-05T16:00:00.000Z","updated":"2019-12-30T14:46:53.220Z","comments":true,"path":"2019/12/06/JAVA/JVM/","link":"","permalink":"http://yoursite.com/2019/12/06/JAVA/JVM/","excerpt":"","text":"JVM的位置 栈管运行，堆管存储类加载器 加载 .class 文件进内存（运行时数据区），并将这些内容转换成方法区中运行时是数据接口。 BootStrap 启动类加载器 C++ 启动类加载器是使用C++语言实现的(HotSpot)，负责加载JVM虚拟机运行时所需的基本系统级别的类，如java.lang.String, java.lang.Object等等。 启动类加载器(Bootstrap Classloader)会读取 {JRE_HOME}/lib 下的jar包(如 rt.jar)和配置，然后将这些系统类加载到方法区内。 由于类加载器是使用平台相关的底层C/C++语言实现的， 所以该加载器不能被Java代码访问到。但是，我们可以查询某个类是否被引导类加载器加载过。 位置：$JAVAHOME/jre/lib/rt.jar 都是 BootStrap 加载 Extension 扩展类加载器 JAVA 此加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 {JAVA_HOME}\\lib\\ext 目录下的类库， 开发者可以直接获取此加载器。 拓展类加载器是是整个JVM加载器的Java代码可以访问到的类加载器的最顶端，即是超级父加载器，拓展类加载器是没有父类加载器的。 位置：$JAVAHOME/jre/lib/ext/ 目录下，都是 Extension 加载 AppClassLoader 应用程序加载器 此加载器负责加载用户类路径上指定的类库，若没有指定自定义加载器，则此加载器一般是程序中默认的加载器。 应用类加载器将拓展类加载器当成自己的父类加载器。 位置：我们自己写的类，都是由 AppClassLoader 加载 用户自定义加载器用户可以自己定义类加载器来加载类。 所有的类加载器都要继承 java.lang.ClassLoader 类并重写 findClass(String name) 方法。用户自定义类加载器默认父加载器是 应用程序加载器 1234567public class MyClassLoader extends ClassLoader &#123; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; return super.findClass(name); &#125;&#125; 双亲委派机制解释：从加载类的关系图来说明，所有的类加载都必须要经过 Bootstrap ，如果没有 再去 Extension 中找，最后才轮到 AppClassLoad ，自顶向下寻找！ 双亲委派模型工作过程：一个类加载器收到类加载的请求，它首先会把这个请求委派给父类加载器去完成，层层上升，只有当父类加载器无法完成此加载请求时，子加载器才会尝试自己去加载。 方法区，也会发生GC存放 静态变量、常量、类信息、运行时常量池 堆，GC发生的主要场所存放对象实例，GC回收的主要区域，分为新生代，老年代，永久存储区。 交换过程S0（from）与S1（to），他们的位置和名分不是固定的，每次GC后都会交换，交换的原则是：GC发生后，谁空谁是to 栈 寄存器寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。每一个线程都有它自己的寄存器，指向内存中下一个调用的地址。 堆参数调优1.7版本的 HotSpot 1.8版本的 HotSpot，取消永久区，新增元空间 JVM调优的三个参数，实际工作中都调成一致1-Xms1024m -Xmx1024m -XX:+PrintGCDetails // JVM内存大小与日志详情 1234long maxMemory = Runtime.getRuntime().maxMemory(); // 虚拟机使用最大内存long totalMemory = Runtime.getRuntime().totalMemory(); // 虚拟机目前使用内存System.out.println(\"虚拟机使用最大内存 = \" + maxMemory + \"字节、\" + (maxMemory / (double) 1024 / 1024) + \"MB\");System.out.println(\"虚拟机目前使用内存 = \" + totalMemory + \"字节、\" + (totalMemory / (double) 1024 / 1024) + \"MB\"); GC日志分析 GC4大算法引用计数法对象添加一个引用计数器，每当一个地方引用它时，计数器加1。每当引用失效时，计数器减少1。当计数器的数值为0时，也就是对象没有引用了，就被垃圾回收掉。 复制算法（Copying）直接复制过去 标记清除（Mark-Sweep） 标记压缩（Mark-Compact） GC调优原则（分代收集算法）频繁收集Young区，较少收集Old区，基本不动元空间新生代新生代区域一般使用Minor GC，频繁发生，此区域用到的算法是复制算法（Copying）。 复制算法在复制幸存下来的对象时，不会产生垃圾碎片。 老年代老年代一般是由标记清除或是标记清除与标记压缩的混合实现。。 标记清除（Mark-Sweep）:两次扫描，时间花费比较多，且会产生垃圾碎片，空间不连续。 标记整理（Mark-Compact）:两次扫描，一次移动，效率低，但是空间连续，移动对象需要成本 深入理解Java虚拟机：https://blog.csdn.net/zhang_jiayuan/article/details/82083163","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"Git","slug":"JAVA/Git基本操作","date":"2019-12-04T16:00:00.000Z","updated":"2020-01-01T03:44:10.283Z","comments":true,"path":"2019/12/05/JAVA/Git基本操作/","link":"","permalink":"http://yoursite.com/2019/12/05/JAVA/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"GITGit工作区的概念 向仓库中添加文件流程 Git的基本操作命令用户名与邮箱的全局设置12$ git config --global user.name \"yangfa\" $ git config --global user.email \"849949161@qq.com\" idea中使用git时，做一些文件忽略 1.idea;*.iml; // 在后面加上忽略idea的配置 git init 初始化本地仓库把这个目录变成git可以管理的本地仓库 git add [文件名] 添加到暂存区在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：111111111， 使用git add 命令把文件添加到暂存区。 git commit 提交当前文件到仓库把文件提交到Git仓库， -m 后面添加注释 git status 查看目前状态 修改文件信息，添加一行2222222222内容，继续使用git status来查看下结果，如下： 上面的命令告诉我们 readme.txt文件已被修改，但是未被提交 git diff [文件名] 查看文件的修改 如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行222222222内容。 对修改后的文件进行提交，先add后commit cat [文件名] 查看文件内容 git reset –hard 版本回退如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行 内容为33333333333333.继续执行add，commit命令 如下： 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令， git reset –hard HEAD^那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。 git reset –hard HEAD~x那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。未回退之前的readme.txt内容如下： 如果想回退到上一个版本的命令如下操作： 第一种: 第二种： 接着查看文件内容如下： 已经回退到第二个版本了。 git log 查看历史记录 git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111。 git log –pretty=oneline 一行显示历史记录如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下： git reflog 获取每次提交的版本号，便于版本切换 git reset –hard [版本号] 根据版本号，回退到指定版本使用git log 来查看下历史记录信息，如下： 我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下： 先查看每次操作后的版本号：git reflog 通过版本号定位版本，最后回退： 通过上面的显示我们可以知道，增加内容3333的版本号是 4f30862.我们现在可以通过回退命令返回指定的版本。 git reset –hard 版本号1git reset --hard 4f30862 // 根据git reflog 查到的版本号 回退 git clone 克隆把GitHub中的仓库克隆到本地Git仓库。 git push 推送到远端git branch 查看当前分支git branch [分支名] 创建分支 git branch -v 查看所有的分支 git branch -d [分支名] 删除分支只有分支被合并后才能被删除 git checkout 切换分支git checkout -b [分支名] 创建并切换分支 git checkout [分支名] 切换到指定分支 git marge [分支名] 当前所在分支与参数分支合并理解工作区与暂存区的区别工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 我们前面说过使用Git提交文件到版本库有两步： 第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下： 现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下： 接着我们可以使用git commit一次性提交到分支上，如下： Git撤销修改和删除文件操作git checkout – [ 文件名] 撤销修改比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下： 在我未提交之前，我发现添加5555555555555内容有误，我要撤销修改，如下： 你可以发现，Git会告诉你，git checkout – [ 文件名] 可以丢弃工作区的修改： git checkout – readme.txt,如下所示： 注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。 rm 删除文件假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下： 如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交，现在目录是这样的， 只要在没有commit之前，还可以在版本库中恢复此文件，如何操作呢？如下： 再来看看我们testgit目录，添加了3个文件了。如下所示： 至此GIT中常用的命令都已经介绍完了。下面进入GitHub的学习。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Git&GitHub","slug":"Git-GitHub","permalink":"http://yoursite.com/tags/Git-GitHub/"}]},{"title":"JavaTime","slug":"JAVA/javaTime","date":"2019-12-03T16:00:00.000Z","updated":"2019-12-30T14:14:02.428Z","comments":true,"path":"2019/12/04/JAVA/javaTime/","link":"","permalink":"http://yoursite.com/2019/12/04/JAVA/javaTime/","excerpt":"","text":"LocalDateTimeJava 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API： Local(本地) − 简化了日期时间的处理，没有时区的问题。 Zoned(时区) − 通过制定的时区处理日期时间。 新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。 DateTimeFormatter 1234567891011121314151617181920DateTimeFormatter[] formatters = new DateTimeFormatter[]&#123; // 直接使用常量创建DateTimeFormatter格式器 DateTimeFormatter.ISO_LOCAL_DATE, DateTimeFormatter.ISO_LOCAL_TIME, DateTimeFormatter.ISO_LOCAL_DATE_TIME, // 使用本地化的不同风格来创建DateTimeFormatter格式器 DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.MEDIUM), DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG), // 根据模式字符串来创建DateTimeFormatter格式器 DateTimeFormatter.ofPattern(\"Gyyyy%%MMM%%dd HH:mm:ss\")&#125;;LocalDateTime date = LocalDateTime.now(); //获取当前本地时间// 依次使用不同的格式器对LocalDateTime进行格式化for(int i = 0 ; i &lt; formatters.length ; i++)&#123; // 下面两行代码的作用相同 System.out.println(date.format(formatters[i])); System.out.println(formatters[i].format(date)); // 一般用这个&#125; LocalDate、LocalTime、LocalDateTime线程安全 获取此刻时间 构造一个指定年、月、日的时间比如：2019年10月12日9时12分32秒 修改日期 格式化日期 Instant 时间戳12Instant instant = Instant.now(); // 获取以 UTC 时区的时间System.out.println(instant); // 2019-12-28T00:43:14.752Z Duration、Period两个类表示时间量或两个日期之间的差 两者之间的差异为：Duration基于时间值，Period基于日期值。 Duration 类 计算两个 时间(time) 之间的间隔Duration类表示秒或纳秒时间间隔，适合处理较短的时间，需要更高的精确性。我们能使用between()方法比较两个瞬间的差： 123456LocalTime startTime = LocalTime.now();Thread.sleep(20000);LocalTime endTime = LocalTime.now();Duration between = Duration.between(startTime, endTime);System.out.println(between.getSeconds()); // 使用get to等方法获取所需数据 Period 类 计算两个 日期(date) 之间的间隔Period 类表示一段时间的年、月、日，使用between()方法获取两个日期之间的差作为Period 对象返回： 123456789LocalDate startDate = LocalDate.of(2015, 2, 20);LocalDate endDate = LocalDate.of(2017, 1, 15); Period period = Period.between(startDate, endDate);//用 Period 类方法获取日期单元System.out.println(period.getYears()); // 获取两个日期之间差几年System.out.println(period.getMonths());// 获取两个日期之间差几月System.out.println(period.getDays()); // 获取两个日期之间差几天 TemporalAdjuster 时间矫正器使用 TemporalAdjuster 可以对当前时间进行处理，如下个周一，下个周日等等需求。 方法通常以 With 开头。 123456789101112LocalDate today = LocalDate.now();System.out.println(\"今天: \" + today);// 使用DateAdjuster将今天的日期调整到下周一LocalDate nextMonday = today.with(TemporalAdjusters.next(DayOfWeek.MONDAY));System.out.println(\"下周一: \" + nextMonday);// 使用 TemporalAdjuster 将今天的日期调整为月的最后一天LocalDate lastDayOfMonth = today.with(TemporalAdjusters.lastDayOfMonth());System.out.println(\"这个月最后一天: \" + lastDayOfMonth);// 创建一个在3个月2天后日期的 TemporalAdjusterTemporalAdjuster adjuster = TemporalAdjusters.ofDateAdjuster((LocalDate date) -&gt; date.plusMonths(3).plusDays(2));LocalDate dayAfter3Mon2Day = today.with(adjuster);System.out.println(\"三月零两天后的日期: \" + dayAfter3Mon2Day);","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"Optional","slug":"JAVA/Optional","date":"2019-12-02T16:00:00.000Z","updated":"2019-12-30T14:13:50.410Z","comments":true,"path":"2019/12/03/JAVA/Optional/","link":"","permalink":"http://yoursite.com/2019/12/03/JAVA/Optional/","excerpt":"","text":"Optional容器类Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException） 简单的方法1234567891011121314151617// 得到容器中的对象，如果为null就抛出异常public T get() &#123; if (value == null) &#123; throw new NoSuchElementException(\"No value present\"); &#125; return value;&#125;// 判断容器中的对象是否为nullpublic boolean isPresent() &#123; return value != null;&#125;// 如果容器中的对象存在，则返回。否则返回传递进来的参数public T orElse(T other) &#123; return value != null ? value : other;&#125; Lambda表达式方法ifPresent()如果容器中的对象存在，则调用accept方法 123User user = new User(7L, \"张三\", 24, \"wwwwwwwww\");Optional&lt;User&gt; optional = Optional.ofNullable(user);optional.ifPresent(System.out::println); orElse(T other) 与 orElseGet(Supplier&lt;? extends T&gt; other)1234567891011121314@Testpublic void test2() &#123; Student student = new Student(1, \"A\", \"M\", 184); Student student1 = Optional.ofNullable(student).orElse(createStudent()); Student student2 = Optional.ofNullable(student).orElseGet(this::createStudent); &#125;public Student createStudent()&#123; Student student = new Student(); student.setName(\"新增的学生\"); System.out.println(\"新增的学生的方法执行了\"); return student;&#125; 这两个函数的区别： 当user值不为null时，orElse函数依然会执行 createStudent() 方法 而orElseGet函数并不会执行 createStudent() 方法，大家可自行测试。 filter()如果容器中的对象存在，并且符合过滤条件，返回装载对象的Optional容器，否则返回一个空的Optional容器。 1234Optional&lt;User&gt; optional = Optional.ofNullable(user) .filter((u) -&gt; \"张三\".equals(u.getName()));System.out.println(\"optional = \" + optional);System.out.println(\"stringOptional = \" + stringOptional); // 返回optional map()如果容器的对象存在，则对其执行调用mapping函数得到返回值。然后创建包含mapping返回值的Optional，否则返回空Optional。 123Optional&lt;User&gt; optional = Optional.ofNullable(user);Optional&lt;String&gt; stringOptional = optional.map( u -&gt; u.getEmail().toUpperCase());System.out.println(\"stringOptional = \" + stringOptional); // 返回optional","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"Docker","slug":"容器技术/Docker","date":"2019-12-02T16:00:00.000Z","updated":"2019-12-28T00:20:05.374Z","comments":true,"path":"2019/12/03/容器技术/Docker/","link":"","permalink":"http://yoursite.com/2019/12/03/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker/","excerpt":"","text":"Docker什么是DockerDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 比虚拟机更为高端，轻量级容器技术 一个完整的Docker有以下几个部分组成： DockerClient客户端 Docker Daemon守护进程（后台进程） Docker Image镜像 DockerContainer容器 就是把Linux中的软件环境打包成镜像，在别的Linux机器上安装这个镜像，每个镜像跟镜像之间相互隔离，这就是Docker。运行中的镜像称为容器，容器的启动速度是非常快速的。 核心概念Docker主机(Host)：安装了Docker主机的机器（直接安装在操作系统上）。 Docker客户端(Client)：连接Docker主机进行操作。 Docker仓库(Registry)：用来存放打包好的软件镜像放在仓库中https://hub.docker.com/ Docker容器(Container)：镜像启动后的实例称为一个容器，容器是独立的一个或是一组应用； 使用Docker的步骤: 1、安装Docker 2、去Docker仓库找到这个软件相应的镜像，并下载在本地 3、使用Docker命令运行这个这个镜像，这个镜像就会生成一个Docker容器 4、对容器的启动停止就是对软件的启动停止 安装Docker1、查看Centos系统的内核，uname -r 必须高于3.10及以上 2、yum install docker，或者官网文档 3、启动Docker systemctl start docker 4、查看docker版本 docker -v 5、设置开机启动 systemctl enable docker 6、停止docker systemctl stop docker 查阅官方文档： https://docs.docker.com/install/linux/docker-ce/centos/ 命令如下： 12345$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo$ sudo yum install docker-ce docker-ce-cli containerd.io$ sudo systemctl start docker$ sudo docker run hello-world 常用操作镜像操作搜索：docker search xxx 拉取：docker pull xxx 查看所有镜像：docker images 删除镜像：docker rmi 镜像id 容器操作软件镜像 — 运行镜像 — 产生一个容器（正在运行的软件），一个镜像可以启动多个容器。 1、运行：–name 自定义容器名 -p 虚拟机端口到容器的映射 -d后台运行 名字 1docker run --name mytomcat -p 8080:8080 -d tomcat 创建一个容器 2、查看运行容器：docker ps 查看所有容器：docker ps -a 3、停止： docker stop 容器name | 容器id 4、启动： docker start 容器name | 容器id 5、删除 ：docker rm 容器id 容器必须停止状态 6、进入容器：docker exec -it 容器name | 容器id /bin/bash 7、查看容器的日志：docker logs 容器name | 容器id 8、查看端口占用: netstat -ntlp 5. 阿里云Docker镜像加速 https://cr.console.aliyun.com/cn-hangzhou/instances/repositories 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://gn3uz2n5.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 6. 阿里云 maven 加速 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 7. 常用容器启动命令 1、启动redis 12docker run -d -it -p 6379:6379 redis redis-server --appendonly yes docker exec -it c6cde1eddf22 redis-cli // redis客户端连接命令 2、启动RabbitMQ 5672是rabbitMQ 的容器使用端口（映射为5672），15672是web页面管理端口（对外映射为15672） 12docker run -d -p 5672:5672 -p 15672:15672 --name rabbitMQ 99cbda713eff docker exec -it rabbitMQ /bin/bash // 进入 RabbitMQ 容器 3、启动 ActiveMQ 命令 61616是 activeMQ 的容器使用端口（映射为61616），8161是web页面管理端口（对外映射为8161） 12docker run -d --name activeMQ -p 61616:61616 -p 8161:8161 webcenter/activemq docker exec -it activeMQ /bin/bash // 进入 ActiveMQ 容器","categories":[{"name":"容器技术","slug":"容器技术","permalink":"http://yoursite.com/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"Stream","slug":"JAVA/Stream","date":"2019-12-01T16:00:00.000Z","updated":"2019-12-30T14:13:40.461Z","comments":true,"path":"2019/12/02/JAVA/Stream/","link":"","permalink":"http://yoursite.com/2019/12/02/JAVA/Stream/","excerpt":"","text":"StreamJava 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。 中间操作筛选与切片filter接收 Lambda，从流中过滤某些数据 123list.stream() .filter( (student -&gt; student.getNo() &gt; 3) ) //中间操作过滤编号小于4 .forEach( (student -&gt; System.out.println(student.toString()))); limit截断流，使其元素不超过指定数量 123list.stream() .limit(2) //截断流，只取前两个 .forEach((student -&gt; System.out.println(student))); skip跳过元素，返回一个扔掉了前n个元素的流，与limit相反 123list.stream() .skip(2) //跳过流的前两个 .forEach((System.out::println)); distinct通过 equals() 和 hashCode() 去除 123list.stream() .distinct() .forEach((System.out::println)); 映射map接收 Lambda，将元素转换成其他形式，接受一个函数，会作用到每一个元素上。 123list.stream() .map((String::toUpperCase)) // 映射函数 .forEach((System.out::println)); flatMap 把几个小的list转换到一个大的list,返回的是集合类型 12345678910111213141516171819202122232425262728293031323334List&lt;String&gt; list1 = Arrays.asList(\"1\", \"2\", \"3\");List&lt;String&gt; list2 = Arrays.asList(\"4\", \"5\", \"6\");List&lt;String&gt; list3 = Arrays.asList(\"7\", \"8\", \"9\");List&lt;String&gt; list4 = Arrays.asList(\"a\", \"b\", \"c\");List&lt;String&gt; list5 = Arrays.asList(\"d\", \"e\", \"f\");List&lt;String&gt; list6 = Arrays.asList(\"g\", \"h\", \"i\");List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;();lists.add(list1);lists.add(list2);lists.add(list3);lists.add(list4);lists.add(list5);lists.add(list6);// Let's print all string before Java 8List&lt;String&gt; listOfAllName = new ArrayList&lt;&gt;();for(List&lt;String&gt; team : lists)&#123; for(String name : team)&#123; listOfAllName.add(name); &#125;&#125;System.out.println(\"Players playing in world cup 2016\");System.out.println(listOfAllName);// Now let's do this in Java 8 using FlatMapList&lt;String&gt; flatMapList = lists.stream() .flatMap(pList -&gt; pList.stream()) .collect(Collectors.toList());System.out.println(\"List of all Players using Java 8\");System.out.println(flatMapList); 排序sorted()123list.stream() .sorted() // 自然排序 .forEach((System.out::println)); sorted（Comparator com） 定制排序123list.stream() .sorted(Comparator.comparingInt(String::length)) // 定制排序 .forEach((System.out::println)); 终止操作查找与匹配allMatch是否全部匹配，返回Boolean值 123boolean g = list.stream() .allMatch((student -&gt; student.getSex().equals(\"G\")));System.out.println(g); anyMatch至少匹配一个，返回Boolean值 123boolean g = list.stream() .anyMatch((student -&gt; student.getSex().equals(\"G\")));System.out.println(g); noneMatch没有匹配元素，返回Boolean值 123boolean g = list.stream() .noneMatch((student -&gt; student.getSex().equals(\"G\")));System.out.println(g); findFirst返回第一个元素，封装为一个Optional，避免了空指针 12Optional&lt;Student&gt; first = list.stream().findFirst();System.out.println(first.get()); findAny返回当前流中任意的元素 12Optional&lt;Student&gt; any = list.stream().findAny();System.out.println(any.get()); count返回流中元素总个数 12long count = list.stream().count();System.out.println(count); max返回流中最大值，找出最高学生的信息 123Optional&lt;Student&gt; max = list.stream() .max((x, y) -&gt; Float.compare(x.getHeight(), y.getHeight())); // float 比较System.out.println(max.get()); min返回流中最小值，找出学生中最矮的学生身高 1234Optional&lt;Float&gt; min = list.stream() .map((Student::getHeight)) // map 把身高拿出来，返回只有身高的流 .min(Float::compare);System.out.println(min.get()); 归纳map - reduce 模式是将流中元素反复结合起来，得到一个值，有两种表现形式 一个参数的Reduce1234Optional&lt;Float&gt; reduce = list.stream() .map((Student::getHeight)) // 获得每个学生的身高 .reduce(Float::sum); // 将身高总和加起来System.out.println(reduce.get()); 假设Stream中的元素a[0]、a[1]、a[2]…a[n - 1]，表示将a[0]与a[1]进行二合运算，结果与a[2]做二合运算，一直到最后与a[n-1]做二合运算。 两个参数的Reduce1234Float reduce = list.Float reduce = list.stream() .map((Student::getHeight)) // 获得每个学生的身高 .reduce(0f, Float::sum); // 定义一个初始化的值为0System.out.println(reduce); 它多了一个初始化的值，因此计算的顺序是identity与a[0]进行二合运算，结果与a[1]再进行二合运算，最终与a[n-1]进行二合运算，identity一般设为不影响结果的值。 收集collect是将流转换为其他形式。接收一个 Collector 接口的实现，用于给Stream中元素做汇总的方法。 1234Set&lt;String&gt; collect = list.stream() .map((Student::getName)) // 获取所有学生的身高 .collect(Collectors.toSet()); // 把学生的名字收集到 set 集合中去System.out.println(collect); // 去重结果 1234HashSet&lt;String&gt; collect = list.stream() .map((Student::getName)) //什么集合，就是 集合名字::new .collect(Collectors.toCollection(HashSet::new)); System.out.println(collect); Idea流调试工具如下代码： 1234567Arrays.asList(\"How are you\", \"Hello\", \"Tom\", \"Hi\", \"Hell\", \"Jerry\") .stream() .filter(s -&gt; s.startsWith(\"H\")) .map(s -&gt; s.substring(2)) .distinct() .sorted() .collect(Collectors.toList()); 打上断点，点击如下图标","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"Lambda","slug":"JAVA/Lambda","date":"2019-11-30T16:00:00.000Z","updated":"2019-12-28T00:48:55.610Z","comments":true,"path":"2019/12/01/JAVA/Lambda/","link":"","permalink":"http://yoursite.com/2019/12/01/JAVA/Lambda/","excerpt":"","text":"Lambda 表达式复制小括号，写死右箭头，落地大括号。 函数式接口函数式接口就是只显式声明一个抽象方法的接口。为保证方法数量不多不少，java8提供了一个专用注解 @FunctionalInterface，这样，当接口中声明的抽象方法多于或少于一个时就会报错。如下图所示： Java内置的四大核心函数式接口1234567891011Consumer&lt;T&gt; 消费型接口 消费对象 void accept(T t);Supplier&lt;T&gt; 供给型接口 生成对象 T get();Function&lt;R,T&gt; 函数型接口 指定特定功能 R apply(T t);Predicate&lt;T&gt; 断言型接口 进行条件判断 boolean test(T t); Lambda表达式Lambda表达式本质上是一个匿名方法。让我们来看下面这个例子： 123public int add(int x, int y) &#123; return x + y; &#125; 转成Lambda表达式后是这个样子： 1(int x, int y) -&gt; &#123; x + y; &#125; // 复制小括号 写死右箭头 落地大括号 参数类型也可以省略，Java编译器会根据上下文推断出来： 1(x, y) -&gt; &#123; x + y; &#125; // 隐式的自动返回 或者 1(x, y) -&gt; &#123; return x + y; &#125; // 显式指明返回值 可见Lambda表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。 Lambda表达式几种类型有参无返回值接口 1234@FunctionalInterfacepublic interface InterfaceWithParams &#123; void run(String s);&#125; 实现 12345678InterfaceWithParams params = new InterfaceWithParams() &#123; @Override public void run(String s) &#123; System.out.println(\"通过\" + s + \"实现run(String)\"); &#125;&#125;;InterfaceWithParams params1 = (String s) -&gt; System.out.println(\"通过\" + s + \"实现run(String)\"); 测试 12this.params.run(\"匿名类\");this.params1.run(\"Lambda\"); 无参有返回值接口 1234@FunctionalInterfacepublic interface InterfaceUnVoidWithNoParam &#123; String run();&#125; 实现 123456789InterfaceUnVoidWithNoParam interfaceUnVoidWithNoParam = new InterfaceUnVoidWithNoParam() &#123; @Override public String run() &#123; return \"Hello World!\"; &#125;&#125;;//省略掉了returnInterfaceUnVoidWithNoParam interfaceUnVoidWithNoParam1 = () -&gt; \"Hello Lambda!\"; 测试 1234String s = this.interfaceUnVoidWithNoParam.run();System.out.println(\"返回结果是：\" + s);String s0 = this.interfaceUnVoidWithNoParam1.run();System.out.println(\"返回结果是：\" + s0); 有参有返回值接口 1234@FunctionalInterfacepublic interface InterfaceUnVoidWithParams &#123; String run(Integer integer);&#125; 实现 12345678InterfaceUnVoidWithParams interfaceWithParams = new InterfaceUnVoidWithParams() &#123; @Override public String run(Integer integer) &#123; return String.valueOf(integer); &#125;&#125;;InterfaceUnVoidWithParams interfaceWithParams1 = (Integer integer) -&gt; String.valueOf(integer); 测试 1234String s1 = this.interfaceWithParams.run(1);System.out.println(\"您输入的是：\" + s1);String s2 = this.interfaceWithParams1.run(2);System.out.println(\"您输入的是：\" + s2);","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"SpringBoot集成Swagger2","slug":"SpringBoot/Swagger","date":"2019-11-30T13:17:24.000Z","updated":"2019-12-28T00:23:44.023Z","comments":true,"path":"2019/11/30/SpringBoot/Swagger/","link":"","permalink":"http://yoursite.com/2019/11/30/SpringBoot/Swagger/","excerpt":"","text":"Swagger我们提供Restful接口的时候，API文档是尤为的重要，它承载着对接口的定义，描述等。它还是和API消费方沟通的重要工具。在实际情况中由于接口和文档存放的位置不同，我们很难及时的去维护文档。个人在实际的工作中就遇到过很多接口更新了很久，但是文档却还是老版本的情况，其实在这个时候这份文档就已经失去了它存在的意义。而Swagger是目前我见过的最好的API文档生成工具，使用起来也很方便，还可以直接调试我们的API。我们今天就来看下Swagger2与SpringBoot的结合。 导入依赖12345678910111213&lt;!-- swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; Swagger 的配置类1234567891011121314151617181920212223242526272829303132333435363738@Configuration@EnableSwagger2public class SwaggerConfig extends WebMvcConfigurationSupport &#123; @Bean public Docket productApi() &#123; return new Docket(DocumentationType.SWAGGER_2).select() // 扫描的包路径 .apis(RequestHandlerSelectors.basePackage(\"com.yf.controller\")) // 定义要生成文档的Api的url路径规则 .paths(PathSelectors.any()) .build() // 设置swagger-ui.html页面上的一些元素信息。 .apiInfo(metaData()); &#125; private ApiInfo metaData() &#123; return new ApiInfoBuilder() // 标题 .title(\"SpringBoot集成Swagger2测试\") // 描述 .description(\"这是一篇博客演示\") // 文档版本 .version(\"1.0.0\") .license(\"Apache License Version 2.0\") .licenseUrl(\"https://www.apache.org/licenses/LICENSE-2.0\") .build(); &#125; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); &#125;&#125; Swagger 常用注解 @Api() 用于类：表示标识这个类是swagger的资源 tags——表示说明 value——也是说明，可以使用tags替代 但是tags 如果有多个值，会生成多个list 12345@Api(value=\"用户controller\",tags=\"用户操作接口\")@RestControllerpublic class UserController &#123;&#125; @ApiOperation() 用于方法：表示一个 http 请求的操作 value——用于方法描述 notes——用于提示内容 tags可以重新分组（视情况而用） 12345@ApiOperation(value = \"获取用户列表\",notes = \"获取所有用户的信息\")@GetMapping(\"/users\")public Object index() &#123; &#125; @ApiParam() 用于参数：对方法参数的补充说明 name——参数名 value——参数的描述 required——是否必填 123456@ApiOperation(value = \"根据用户ID查询用户\",notes = \"查询单个用户的信息\")@ApiParam(name =\"id\",value = \"用户id\",required = true)@GetMapping(\"/users/&#123;id&#125;\")public Object getUserById(@PathVariable(\"id\") String id) &#123; &#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"树","slug":"数据结构/树","date":"2019-11-27T16:00:00.000Z","updated":"2020-01-01T02:52:27.572Z","comments":true,"path":"2019/11/28/数据结构/树/","link":"","permalink":"http://yoursite.com/2019/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/","excerpt":"","text":"树树是n(n&gt;=0)个结点的有限集。n=0时称为空树。在任意一棵非空树种：(1)有且仅有一个特定的称为根(Root)的结点；(2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集，其中每一个集合本身又是一棵树，并且称为根的子树。 定义之前的顺序表 栈 队列 都是一对一的线性结构，现在需要一对多的结构，树就是一对多的数据结构。 结点分类根节点 内部结点 叶节点/终端结点。 其他定义如果树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 树中结点的最大层次称为树的深度。 森林是m(m&gt;=0)棵互不相交的树的集合。 树的存储结构之前有顺序存储结构，现在有链式存储结构。但是那都是一对一的关系，现在需要一对多的关系。如果树中结点只是简单的顺序结构，那就体现不了结点之间的一对多关系。可以充分结合链式和顺序存储的特点，让它能体现出一对多的关系。 双亲表示法每个结点都有一个指针域来指向它的父节点。根节点的指针域为-1。 特点是找结点的双亲方便。 孩子表示法每个结点都有多个指针域，其中每一个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法。 把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。 特点是找结点的孩子方便。 孩子兄弟表示法任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。 特点是找结点的兄弟结点方便。 二叉树一个结点只有左右两个结点。 折半查找目的是有规律的缩减筛选条件，当条件小到中间只差1，不就找到那个元素了。 二叉树定义二叉树(Binary Tree)是n(n&gt;=0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根节点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成。 二叉树特点 每个结点最多两棵子树，且每个结点的度最大也为2 子树需要区分顺序，左和右本来就是他们的特点 满二叉树可以说把二叉树填充满就是完全二叉树。在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 完全二叉树特点：满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。 对一棵具有n个结点的二叉树按层序排号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这可二叉树称为完全二叉树。 上面的解释读起来有点抽象，比喻一下就是，每一层的结点只能是从左向右按次序排，这层排满才能排下一层的结点。 遍历二叉树因为每个结点对应至多两个方向，那么每选择一个方向就是一个新的路线。限制遍历顺序是从左往右，就有以下几种顺序。二叉树的定义是递归的方式，每一个结点和子结点都可以看做一个最短二叉树。那么实现遍历算法也可以采用递归。 前序遍历代码如图： 123456789public void preOrder()&#123; System.out.println(this); if (this.lrft != null)&#123; this.lrft.preOrder(); &#125; if (this.right != null)&#123; this.right.preOrder(); &#125;&#125; 从根结点开始记录，一直读左子树，直到终端结点，再读右终端节点往上读。 中序遍历代码如图： 123456789public void infixOrder()&#123; if (this.lrft != null)&#123; this.lrft.infixOrder(); &#125; System.out.println(this); if (this.right != null)&#123; this.right.infixOrder(); &#125; &#125; 从左子树的终端结点开始读，再读终端结点父结点，再读右终端结点。 后序遍历代码如图： 123456789public void lastOrder()&#123; if (this.lrft != null)&#123; this.lrft.lastOrder(); &#125; if (this.right != null)&#123; this.right.lastOrder(); &#125; System.out.println(this); &#125; 从左子树的终端结点开始读，再读右终端结点，再读终端结点父结点。 遍历方式意义方便计算机识别，计算机只有循环、判断等方式处理，它只会处理线性序列；而上边的遍历顺序就是把在树中的结点变成某种意义的线性序列。 如果给出前序和中序遍历的结果请推导出后序遍历像这种情况，就是需要充分理解上面的算法的特点。递归和前中后这两个特点是推导的关键，我们可以把每一个子树中在最后或者最前位置的结点看为根结点(根据前序和后序的特点)，中序遍历就是确定谁是左子树谁是右子树。 线索话二叉树将二叉树的每一个结点都增加两个指针域，其中左指针域指向它的孩子结点，同理右指针域。这样总会有一些空指针域，为了提高利用率，就将空指针域进行改造；左边的空指针域就指向中序遍历的前结点，右边的空指针域就指向中序遍历的后结点。仅仅这样还是无法知道结点的左指针域指向的到底是左孩子还是它的前驱结点。那么给结点再增加两个布尔域，用来辨别它的左右指针指向的是前驱还是孩子。 二叉排序树二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。 对于二叉排序树，要求任何一个非叶子结点，其左子树结点的值比当前结点小，右子结点的值比当前结点大。 平衡二叉树（AVL），对BST的升级 每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。&gt;1 的时候，就需要考虑用旋转了。** 并且左右两个子树都是一棵平衡二叉树。 单旋转1、左单旋：任何一个结点，他的右子树的高度 - 左子树的高度 &gt;1 的时候，就要考虑左旋了，左旋是为了解决右子树太高的问题。 https://img-blog.csdn.net/20180722220546910 2、右单旋：任何一个结点，他的左子树的高度 - 右子树的高度 &gt;1 的时候，就要考虑右旋了，右旋是为了解决左子树太高的问题。 https://img-blog.csdn.net/20180722222413303 方案：将左子树的右子树链接到父亲结点的左孩子结点，父亲结点作为左孩子结点的右孩子结点便完成了旋转。 3、双旋转：当一个结点的左右子树中，有不是AVL 树时，就需要对 左子树 或 右子树 进行旋转，情况有以下四种，递归执行。 只有当每个子树都是AVL树的时候，才能操作Root结点。 当左子结点的 左子树 的高度大于 右子树 的高度时，需要右旋 当左子结点的 左子树 的高度小于 右子树 的高度时，需要左旋 当右子结点的 左子树 的高度大于 右子树 的高度时，需要右旋 当右子结点的 左子树 的高度小于 右子树 的高度时，需要左旋 红黑树 红黑树 和 AVL 树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的 n 是树中元素的数目。 红黑树的性质 根节点是黑色 父子不能同为红色 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 平衡多叉树（B树，B+树）将树的度设为 1024，600亿 个元素最多只需要 4次 I/O 操作就可以取得想要的元素，效率是非常的快的。 B树广泛的应用于 文件存储系统 和 数据库系统中（索引） 。 2-3树2-3树是最简单的B树结构，2-3树 满足如下条件： 所有叶子结点都在同一层（平衡多叉树必须满足的条件） 有两个子结点的结点叫二结点，二结点要么没有子结点，要么有两个子结点 有三个子结点的结点叫三结点，三结点要么没有子结点，要么有三个子结点 2-3树 是由二结点和三结点构成的树 B树 B树的特点 从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束； 没有命中，则进入查询关键字所属范围的儿子结点进行查找； 重复以上步骤，直到所对应的儿子指针为空，或已经是叶子结点； 搜索性能等于在关键字全集中做二分查找。查找很不稳定，最好就是根节点，最坏就在叶子结点。 B+树B+树，是B树的一种变体，也是一种多路搜索树。他们差别是： B+树中所有的数据都会放在叶子结点，而不会放在非叶子结点 B+树的特点 B+树 跟 B树 搜索基本相同，区别是 B+树 只有达到叶子结点才会命中，搜索性能等于在关键字全集中做二分查找。 所有的 关键字都出现在叶子结点的链表中，（即关键字只能在叶子结点【稠密索引】），且链表中的关键字恰好是有序的。 非叶子结点相当于是叶子结点的索引【稀疏索引】，叶子结点相当于是存储（关键字）的箱子。 适合做文件索引系统，数据库索引系统。 为什么说 B+树 比 B 树 更适合实际应用中操作系统的文件索引和数据库索引？1、B+树的磁盘读写代价更低B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更 小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 而B+树非叶子节点没有Data数据，所以同样大小的磁盘页可以容纳更多的节点元素。所以数据量相同的情况下，B+树比B树更加“矮胖“，因此使用的IO查询次数更少。 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。 2、B+树的的查询效率更加稳定由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 而B树的查找并不稳定（最好的情况是查询根节点，最坏查询叶子节点）。而B树每一次查找都是稳定的。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"队列","slug":"数据结构/队列","date":"2019-11-26T16:00:00.000Z","updated":"2020-01-01T02:52:22.153Z","comments":true,"path":"2019/11/27/数据结构/队列/","link":"","permalink":"http://yoursite.com/2019/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/","excerpt":"","text":"队列queue是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。是一种先进先出的线性表，简称FIFO。允许插入的叫队尾，允许删除的一端称为队头。 键盘输入到屏幕输出用的就是队列。 循环队列当队列是顺序结构时，假设这个队列能放n个元素，那么它的长度必须是大于n的，并且要把队列的所有元素存储在数组的前n个单元，数组下标为0的一端就是队头。入队，就是在队尾加入一个元素，不用移动任何元素。出队，需要将除第一个元素的所有元素前移。所以入队的时间复杂度为o(1)，出队是o(n)。 如果我们不去限制队列的元素必须放在数组的前n个单元，出队的下标就不需要一定在下标为0的位置。 我们把队列这种头尾相接的顺序存储结构称为循环队列。 如何判断是否为空或者满呢？ 设置一个标识flag，当front==rear，且flag=0时为队列空；当front==rear，且flag=1时为队列满 当队列空时，条件就是front==rear。当队列满，数组中会有一个空闲位置，不让rear==front。 循环队列入队操作(顺序结构)1234567891011Status EnQueue(SqQueue *Q,QElemType e)&#123; //判断队列是否满 if((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front) return ERROR; //将元素e赋值给队尾，数组 Q-&gt;data[Q-&gt;rear]=e; //rear指针后移 Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE; return OK;&#125; 循环队列出队操作(顺序结构)1234567891011Status DeQueue(SqQueue *Q,QElemType *e)&#123; //队列为空的判断 if(Q-&gt;front == Q-&gt;rear) return ERROR; //取出要删除的数据 *e=Q-&gt;data[Q-&gt;front]; //队头后移 Q-&gt;front=(Q-&gt;front+1)%MAXSIZE; return OK;&#125; 入队(链式结构)将队头指针指向链对列的头结点，而队尾指针指向终端结点 1234567891011121314Status EnQueue(LinkQueue *Q,QElemType e)&#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); if(!s) exit(OVERFLOW); //对入队结点赋值 s-&gt;data=e; s-&gt;next=NULL; //将结点加入队列 Q-&gt;rear-&gt;next=s; //移动队尾指针 Q-&gt;rear=s; return OK;&#125; 出队(链式结构)出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点。如果链表除了头结点外只有一个元素，则需要将rear指向头结点。 12345678910111213141516Status DeQueue(LinkQueue *Q,QElemType *e)&#123; //新结点来保存信息 QueuePtr p; if(Q-&gt;front == Q-&gt;rear) return ERROR; //头结点的后继(被删除的结点)信息保存在p结点中 p=Q-&gt;front-&gt;next; *e=p-&gt;data; Q-&gt;front-&gt;next=p-&gt;next; //如果删除的结点是唯一结点 if(Q-&gt;rear==p) q-&gt;rear=Q-&gt;front; free(p); return OK;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"栈","slug":"数据结构/栈","date":"2019-11-25T16:00:00.000Z","updated":"2020-01-01T02:52:15.320Z","comments":true,"path":"2019/11/26/数据结构/栈/","link":"","permalink":"http://yoursite.com/2019/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/","excerpt":"","text":"栈栈是限定仅在表尾进行插入和删除操作的线性表。队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表。 栈的操作顺序类似idea等软件的撤销按钮，后来的先返回。把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom）。栈是后进先出，LAST IN FIRST OUT，叫LIFO结构。 栈的顺序存储结构可以把栈想成线性表顺序存储结构的简化，简称顺序栈。把栈顶看成游标卡尺的游标，栈底固定位置，栈顶来回移动。 也可以看成子弹上膛。 两栈共享空间栈的存库空间必须事先定好，所以一般都会设计出合适的大小数组来处理。但是对于两个同类型的栈，我们可以做到最大限度利用他们的存储空间。 让第一个满了的栈的栈顶接上另一个未满栈的栈顶。使用这样的数据结构，通常是两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。如果不是两个具有相同数据类型的栈的，使用这个办法反而会使问题变复杂。 栈的的链式存储结构简称链栈。栈顶放在链表的头部，头指针和栈顶指针合二为一。对于链栈来说，基本不存在栈满的情况。 入栈操作： 123456789101112Status Push(LinkStack *S,SElemType e) &#123;//先创建一个需要插入的结点 LinkStackPtr s = (LinkStackPtr)malloc(sizeOf(StackNode)); //对s结点进行赋值和指向操作 s-&gt;data=e; //因为栈中的元素是从栈顶往栈底传递的，栈顶元素保存的下一结点的地址就是它下面一位元素 s-&gt;next=S-&gt;top; //对栈操作 S-&gt;top=s; S-&gt;count++; return ok;&#125; 出栈操作： 123456789101112131415Status Pop(LinkStack *S,SElemType *e)&#123; LinkStackPtr p; if(StackEmpty(*S)) return ERROR; //拿到栈顶的数据 *e=S-&gt;top-&gt;data; p=S-&gt;top; //将栈顶指针下移 S-&gt;top=S-&gt;top-&gt;next; //释放删除的结点 free(p); S-&gt;count--; return OK;&#125; 顺序栈和链栈的区别它们的时间复杂度是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定长度，可能会存在内存空间浪费问题，但是它存取时定位很方便，而链栈则要求每个元素都有指针域，这同时增加了内存开销，但对于栈的长度无限制。如果栈使用过程中元素变化不可预料，有时很小，有时非常大，那么最好用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。 栈的作用为何我们不用数组或者链表直接实现功能？因为栈的引入简化了程序设计的问题，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组，会需要分散精力去考虑数组的下标增减等细节问题，反而有掩盖了问题的本质。 栈的应用-递归关键词：斐波那契数列(Fibonacci) 迭代 递归 现在假设有一个数学函数： 打印前40位的斐波那契数列数，使用迭代，代码如下： 123456789101112131415int main()&#123; int i; int a[40]; a[0]=0; a[1]=1; printf(\"%d\",a[0]); printf(\"%d\",a[1]); for(i=2;i&lt;40;i++) &#123; a[i]=a[i-1]+a[i-2]; printf(\"%d\",a[i]); &#125; return 0;&#125; 使用迭代代码简单，容易理解，但是过于冗长。 使用递归： 123456789101112131415int Fbi(int i)&#123; if(i&lt;2) return i== 0?0:1; return Fbi(i-1)+Fbi(i-2);&#125;int main()&#123; int i; for(int i=0;i&lt;40;i++) &#123; printf(\"%d\",Fbi(i)); &#125; return 0;&#125; 递归是自己调用自己，我们可以把它看做是调用另一个函数；只不过，这个函数和自己长得一样。 每个递归定义必须至少有一个条件，满足时递归不在进行，即不再引用自身而是返回值退出。避免陷入永不结束的无穷递归中。 递归和迭代的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰，更简洁，更容易让人理解，从而减少读懂代码的时间。但大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代不需要反复调用函数和占用额外的内存。 这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合这样的数据结构，因此，编译器使用栈实现递归。 后缀表达式这是波兰逻辑学家提出的，它将传统的四则运算表达式，改造成去掉括号，运算符在运算数字之后出现的形式。 例如：9+(3-1)*3+10/2改造为9 3 1 - 3 * + 10 2 / + 如何看这个改造结果呢？理解起来就是：从左到右写数字，原则是运算符在计算的两个数字之后，但是要考虑括号和乘除优先写运算符。所以看成三块9 |+| (3-1)*3 |+| 10/2每一块又按这个原则来分。 9 3 1 - 3 * + 10 2 / +这个表达式计算机如何处理呢？计算机的做法是遇到数字就入栈，遇到运算符就将栈顶的两个数出栈进行运算(注意顺序)，将运算结果再入栈，这样直到最后的运算符。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"线性表","slug":"数据结构/线性表","date":"2019-11-24T16:00:00.000Z","updated":"2020-01-01T02:51:43.706Z","comments":true,"path":"2019/11/25/数据结构/线性表/","link":"","permalink":"http://yoursite.com/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"概念筑基 数据 数据对象 有相同数量和类型数据项的数据元素的集合 数据元素 组成数据的基本单位 数据项 数据结构 包含相互关系数据元素的集合 逻辑结构与物理结构逻辑针对数据元素之间的关系，物理针对计算机存储单元之间的关系 逻辑关系：元素之间无关联、一对一、一对多、多对多；分别对应集合结构、线性结构、树形结构、图形结构。 物理结构：数据存储单元之间顺序存储、链式存储。 算法求解特定问题的求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 算法的特性： 输入 输出 有穷性 确定性 可行性 算法设计的特性： 正确性 可读性 健壮性 对输入不合法的情况做出合适的处理 时间效率高，存储量低‘ 算法效率的度量： 测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数。运行时间与这个计数成正比。 判断一个算法的效率，函数中常数和其他次要项常常可以忽略，更应该关注主项（最高阶项）的阶数。 推导时间复杂度的方法： 用常数1取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是1，则去除与整个项相乘的常数。 得到的结果就是大O阶 对于循环体来说，时间复杂度就是内循环的复杂度乘循环的次数。 线性表有顺序结构和链式结构。单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但是如果我们希望从第i个位置，插入10个元素，对于顺序存储结构意味着，每一次插入都要移动n-i个元素，每次都是O(n)。而单链表，我们只需要第一次找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针，事件复杂度为O(1)。显然，对于插入和删除数据越频繁的操作，单链表的效率优势就越明显。 单链表的整表创建1.头插法：让不断生成的结点始终位于第一的位置。新结点指向上一次的新结点，头指针指向新结点。 2.尾插法：把每次新结点都插在终端结点后面。上一次的新结点指向新结点。 单链表的整表删除链表中每个元素只有数据域和指向下一个元素的指针；要删除的话，只能从第一个开始删除，然后不断往后循环。 单链表结构与顺序存储结构优缺点时间性能上，单链表查找弱于顺序存储结构，插入和删除在多元素时优于顺序存储结构。空间性能上，顺序存储需要预先分配空间，这就直接导致会有浪费或者上溢。 例如：1.在游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况下都是读取，所以应该考虑使用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家游戏的过程中，可能随时增加或删除，此时再用顺序存储就太不合适了。2.当线性表中的元素个数变化较大或者根本不知道多大时，为了空间考虑还是使用单链表结构。如果事先知道线性表的大致长度，比如一年12个月，一周共7天，这种用顺序存储结构效率高很多。 静态链表当最初期的编程高级语言Basic、Fortran，由于没有指针，链表结构如何实现呢？和我在Java中定义链表差不多，我用一个包装类里面放数据和它指向的下个元素的地址。那这些没有指针的语言，它们可以使用数组来代替指针。首先是数组中的每个元素都是由两个数据域组成，data和cur；这个cur放的就是该元素的后继在数组中的下标。这种用数组描述的链表就是静态链表，还有叫游标实现法的。 光这样放元素还是不够完善，我们需要对数组第一个和最后一个元素作为特殊元素处理，不存数据。通常把未被使用数组元素（剩余空闲的数组元素连在一起的）称为备用链表。而数组第一个元素，下标为0的数组元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数组的元素的下标，相当于头结点。如下图：第一个节点中cur为7，庚元素的cur为0，数组的末尾的cur为1，这三个表示的意思，我们都应该要知道。7是备用链表的起始位置，0是表示当前数组元素为不为空的元素最后一个，1是表示数组中不为空的第一个位置的下标。7、0、1都是下标。 静态链表的插入与删除静态链表要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。 插入那么如何模拟结点创建呢？我们将数组中未被使用过的及已经被删除的分量用游标链成一个备用的链表，每当进行插入时，就从备用链表中取得一个结点作为待插入的新结点。 1234567891011121314/*备用链表非空，就返回要分配出去的结点的下标，否则返回0*/int Malloc_SLL(StaticLinkList space) &#123; //静态链表的第一个位置放的就是备用链表 //第一个元素的下标，现在我们先拿到 //备用链表的第一个元素 int i = space[0].cur; //如果能拿到备用链表的第一个结点，那就把它下一个 //结点作为新一个第一结点。因为需要人能顶起下次被取出的任务 if (space[0].cur) &#123; space[0].cur = space[i].cur; &#125; return i;&#125; 现在能从备用链表中拿到新的空间作为放新结点的位置了。那我们就来实现如何给静态链表插入一个元素。大致思路还是：先判断插入位置是否合理；再拿到插入位置的前一个结点，让它把它的后继结点的游标给我们新插入的结点来继承；然后新结点再作为前面结点的后继。很好理解，每个元素只有下一个元素的游标，我们要插入某个位置，那就要把这个位置的上游指向新结点且新结点指向上游的后继结点；那就先把上游的后继结点游标拿到，不然赋值就覆盖了。 12345678910111213141516171819Status ListInsert(StaticLinkList L,int i,ElemTyp e) &#123; //j用来接收分配位置,k用来接收静态链表的最后一位元素的下标， //位于该k位置元素的游标指向第一个放元素的下标；l用来计数。 int j,k,l; k = MAX_SIZE - 1; if (i&lt;1 ||i&gt;ListLength(L) +1) return ERROR; j = Malloc_SSL(L); /*获得空闲分量的下标*/ if (j) &#123; L[j].data = e; /*插入位置数据域赋值*/ for (l=1; l&lt;i; l++) &#123; /*l是相对于长度来说，l=1下面第一次循环就拿到开头元素的下标，那么他要循环到插入位置前一个元素，那对应的下标就是i-1，就循环i-1次*/ k = L[k].cur; &#125; L[j].cur = L[k].cur; L[k].cur = j; return OK; &#125; return ERROR;&#125; 这里面比较难理解的就是找到插入位置的前一个元素。一个循环，它的结束条件还是要看它循环体什么时候符合条件；符合条件了就要结束循环。 删除要删除i位置的结点，很简单，就是把i上游的游标不再指向i了，指向i的下游；然后将i位置结点释放。直接上代码： 1234567891011121314Status ListDelete(StaticLinkList L,int i) &#123; int j,k; if (i &lt;1 || i&gt;ListLength(L)) &#123; return ERROR; &#125; k = MAX_SIZE - 1; for (j = 1;j&lt;=i-1;j++) &#123; k = L[k].cur; &#125; j = L[k],cur; L[k].cur = L[j].cur; Free_SSL(L,j); return OK;&#125; 其中的Free_SSL(L,j)是释放元素： 123456/*将下标为k的空闲结点回收到备用链表*/void Free_SSL(StaticLinkList space,int k) &#123; /*用了头插法，把新产生的空闲结点放到备用链表第一个元素之前*/ space[k].cur = space[0].cur; space[0].cur = k;&#125; 为啥这里不用尾插法？理论上是可行，反正都是把空闲结点放进备用链表。不过尾插就得找到备用链表的最后一个结点，在静态链表中只能不断遍历才能拿到。这就过于麻烦了吧！静态链表有三个特殊位置，第一个是第一位指向了备用链表的位置，第二个是最后一位指向了有元素的第一个位置，第三个是备用链表的起始位置，它指向备用链表的后继。头插法是，我们只要把插入的结点指向之前的第一个结点就行；在静态链表中，除了要这样做之外，还要把第一个结点指向的位置换成新结点。 静态链表的优缺点优点是继承了单链表的优点，缺点是没有解决表长难确定的问题，失去了顺序存储结构随机存取的特性。静态链表理解它的思想就ok了。 循环链表第一个特点，从任一结点都能完整遍历链表。我们把单链表的尾结点的指针从空指针改为指向头结点。这样就把整个单链表形成一个环，这种头尾相连的单链表就是单循环链表。简称循环链表（circular linked list）。通常为了让空链表和非空链表处理一致，通常设置一个头结点。循环链表和单链表的主要差异就在于循环的判断条件，原来是判断p-&gt;next是否为空，现在是p-&gt;next不等于头结点，则循环未结束。循环链表就是为了解决从任一结点都能遍历链表，我们都知道链表的头和尾是两个特殊位置，如果我们想要不遍历整个链表就拿到头和尾，那该咋整呢？我们用一个尾指针来指向尾结点，不就解决了。 现在咋们有两个循环链表A和B，我们要让B接在A后面，如果只有头指针的情况下，怎么办？那就得遍历A，指导尾结点结束，然后让尾结点不再指向A的头结点；让它指向B的头结点，然后遍历B，让B的尾结点不指向B的头结点，去指向A的头结点。这里用到了两个遍历时间复杂度O(n)。如果现在有尾指针的情况下呢？A的尾指针去指向B的尾指针的next-&gt;next也就是B的头，让B的next指向A的尾指针的next-&gt;next也就是A的头。这里的时间复杂度是多少？也就两步吧？这不就很简单了。这就是尾指针的爽点。文字看起来不爽，来用代码表示一下： 1234p = rearA-&gt;next; /*拿到A的头结点*/rearA-&gt;next=rearB-&gt;next-&gt;next; /*A的尾结点指向B的头结点*/rearB-&gt;next=p; /*B的尾结点指向A的头结点*/free(p); 双向链表在一个循环链表的情况下，我们现在需要从尾结点开始，遍历整个链表，并且最后要回到头结点。遍历一次咋们还是在尾结点，还得多走一步才能回到头结点。现在我们整一个双向链表，啥是双向链表？先不管，反正能反着访问就行，那我们就可以从尾结点逆序访问到头结点，还不用多走一步。我们在单链表中，有了next指针，使得我们要查找下一结点的时间复杂度为O(1)。可是如果我们要找的是上一个结点，就得是O(n)了。因为我们每次都得从头开始查找。为了克服单向性这一个访问缺点，我们的科学家设计出了双向链表。double linked list是在单链表的每一个节点中，再设置一个指向其前驱结点的指针域。那么现在双向链表的每一个结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。 双向链表的插入与删除思路：在a1（p结点）与a2之间插入一个s结点，现在能知道的就是p结点和e结点。进行指针操作必须要注意p-&gt;next只能最后被赋值，因为它表示的就是a1与a2之间的联系，如果他改变了就表示联系断了。 1234567/*先给插入的s结点的两个指针域赋值，完成s结点的指向*/s-&gt;next = p-&gt;next; s-&gt;prior = p;/*对a2结点的priod指针（指向前一结点的指针域）赋值*/p-&gt;next-&gt;prior = s;/*对a1结点的next指针赋值*/p-&gt;next = s; 双向链表插入得修改三个结点，首先是插入结点的前后指针，再是插入位置的后一结点的前指针，最后是插入结点位置的前一结点的后指针。 删除：假如删除的就是p结点，它的前后结点的指针都与他无关了，之前和它有关的都得改变。 123p-&gt;next-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=p-&gt;next;free(p);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}]}