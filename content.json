{"meta":{"title":"个人技术博客","subtitle":"记录了一些与JAVA相关的技术文章","description":"学习与工作总结","author":"杨发","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-11-30T06:41:57.000Z","updated":"2019-11-30T08:45:32.174Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-30T06:42:05.000Z","updated":"2019-11-30T08:45:18.243Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-27T14:29:50.000Z","updated":"2019-11-30T08:45:08.311Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git分支与冲突","slug":"JAVA/Git&GitHub/Git分支与冲突","date":"2019-12-06T16:00:00.000Z","updated":"2020-01-01T04:57:28.641Z","comments":true,"path":"2019/12/07/JAVA/Git&GitHub/Git分支与冲突/","link":"","permalink":"http://yoursite.com/2019/12/07/JAVA/Git&GitHub/Git%E5%88%86%E6%94%AF%E4%B8%8E%E5%86%B2%E7%AA%81/","excerpt":"","text":"GIT分支与冲突分支分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。火影忍者里面的鸣人学习妙木山仙术的那种情景。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 在版本回退里，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即 master 分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上 从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变 假如我们在dev上的工作完成了，就可以把dev合并到master上。 Git怎么合并呢？最简单的方法，直接把master指向dev的当前提交，就完成了合并 git branch -v 查看分支时，会列出所有的分支，当前分支前面会添加一个星号。 1git checkout -b 123 // 创建并切换到123分支上 然后我们在123分支上继续做demo，比如我们现在在test.txt再增加一些内容。 把test.txt 添加到本地库 使用 git branch -v 查看分支 这两个分支的版本号已经不一致了，123 分支已经比master分支领先一个版本了。 现在 123 分支工作已完成，现在我们切换到主分支master上，继续查看test.txt内容如下： 此时master分支上并没有与之前有任何的变化，因为所有的操作都在123分支上进行的。 现在我们可以把123分支上的内容合并到分支master上了 可以在master分支上，使用如下命令 1git merge 123 // 当前(Master)所在的分支 合并 123分支， 被合并的作为参数 如下所示： 合并完成后，我们可以接着删除123分支了，操作如下： 1git branch -d 123 // 只有被合并后的空分支 才可以被删除 冲突先新建一个新分支，比如名字叫 fenzhi1，在test.txt添加一行内容88888888888888，然后提交，如下所示： 同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999999999，如下所示： 这是两个分支上，同一个位置做出了不同的修改，冲突产生。 现在我们需要在master分支上来合并 fenzhi1，如下操作： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容 其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Git&GitHub","slug":"Git-GitHub","permalink":"http://yoursite.com/tags/Git-GitHub/"}]},{"title":"JVM","slug":"JAVA/JVM","date":"2019-12-05T16:00:00.000Z","updated":"2020-03-02T11:30:07.003Z","comments":true,"path":"2019/12/06/JAVA/JVM/","link":"","permalink":"http://yoursite.com/2019/12/06/JAVA/JVM/","excerpt":"","text":"JVM的位置 栈管运行，堆管存储类加载器 加载 .class 文件进内存（运行时数据区），并将这些内容转换成方法区中运行时是数据接口。 BootStrap 启动类加载器 C++ 启动类加载器是使用C++语言实现的(HotSpot)，负责加载JVM虚拟机运行时所需的基本系统级别的类，如java.lang.String, java.lang.Object等等。 启动类加载器(Bootstrap Classloader)会读取 {JRE_HOME}/lib 下的jar包(如 rt.jar)和配置，然后将这些系统类加载到方法区内。 由于类加载器是使用平台相关的底层C/C++语言实现的， 所以该加载器不能被Java代码访问到。但是，我们可以查询某个类是否被引导类加载器加载过。 位置：$JAVAHOME/jre/lib/rt.jar 都是 BootStrap 加载 Extension 扩展类加载器 JAVA 此加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 {JAVA_HOME}\\lib\\ext 目录下的类库， 开发者可以直接获取此加载器。 拓展类加载器是是整个JVM加载器的Java代码可以访问到的类加载器的最顶端，即是超级父加载器，拓展类加载器是没有父类加载器的。 位置：$JAVAHOME/jre/lib/ext/ 目录下，都是 Extension 加载 AppClassLoader 应用程序加载器 此加载器负责加载用户类路径上指定的类库，若没有指定自定义加载器，则此加载器一般是程序中默认的加载器。 应用类加载器将拓展类加载器当成自己的父类加载器。 位置：我们自己写的类，都是由 AppClassLoader 加载 用户自定义加载器用户可以自己定义类加载器来加载类。 所有的类加载器都要继承 java.lang.ClassLoader 类并重写 findClass(String name) 方法。用户自定义类加载器默认父加载器是 应用程序加载器 1234567public class MyClassLoader extends ClassLoader &#123; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; return super.findClass(name); &#125;&#125; 双亲委派机制解释：从加载类的关系图来说明，所有的类加载都必须要经过 Bootstrap ，如果没有 再去 Extension 中找，最后才轮到 AppClassLoad ，自顶向下寻找！ 双亲委派模型工作过程：一个类加载器收到类加载的请求，它首先会把这个请求委派给父类加载器去完成，层层上升，只有当父类加载器无法完成此加载请求时，子加载器才会尝试自己去加载。 方法区，也会发生GC存放 静态变量、常量、类信息、运行时常量池 堆，GC发生的主要场所存放对象实例，GC回收的主要区域，分为新生代，老年代，永久存储区。 交换过程S0（from）与S1（to），他们的位置和名分不是固定的，每次GC后都会交换，交换的原则是：GC发生后，谁空谁是to 栈 寄存器寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。每一个线程都有它自己的寄存器，指向内存中下一个调用的地址。 堆参数调优1.7版本的 HotSpot 1.8版本的 HotSpot，取消永久区，新增元空间 JVM调优的三个参数，实际工作中都调成一致1-Xms1024m -Xmx1024m -XX:+PrintGCDetails // JVM内存大小与日志详情 1234long maxMemory = Runtime.getRuntime().maxMemory(); // 虚拟机使用最大内存long totalMemory = Runtime.getRuntime().totalMemory(); // 虚拟机目前使用内存System.out.println(\"虚拟机使用最大内存 = \" + maxMemory + \"字节、\" + (maxMemory / (double) 1024 / 1024) + \"MB\");System.out.println(\"虚拟机目前使用内存 = \" + totalMemory + \"字节、\" + (totalMemory / (double) 1024 / 1024) + \"MB\"); GC日志分析 GC4大算法引用计数法对象添加一个引用计数器，每当一个地方引用它时，计数器加1。每当引用失效时，计数器减少1。当计数器的数值为0时，也就是对象没有引用了，就被垃圾回收掉。 复制算法（Copying）直接复制过去 标记清除（Mark-Sweep） 标记压缩（Mark-Compact） GC调优原则（分代收集算法）频繁收集Young区，较少收集Old区，基本不动元空间新生代新生代区域一般使用Minor GC，频繁发生，此区域用到的算法是复制算法（Copying）。 复制算法在复制幸存下来的对象时，不会产生垃圾碎片。 老年代老年代一般是由标记清除或是标记清除与标记压缩的混合实现。。 标记清除（Mark-Sweep）:两次扫描，时间花费比较多，且会产生垃圾碎片，空间不连续。 标记整理（Mark-Compact）:两次扫描，一次移动，效率低，但是空间连续，移动对象需要成本 深入理解Java虚拟机：https://blog.csdn.net/zhang_jiayuan/article/details/82083163","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"GitHUb","slug":"JAVA/Git&GitHub/GitHub","date":"2019-12-05T16:00:00.000Z","updated":"2020-01-01T04:45:48.564Z","comments":true,"path":"2019/12/06/JAVA/Git&GitHub/GitHub/","link":"","permalink":"http://yoursite.com/2019/12/06/JAVA/Git&GitHub/GitHub/","excerpt":"","text":"GitHub修改本地host，使访问GIitHub变快1、浏览器访问 https://www.ipaddress.com/ 2、修改host文件 12345678910111213141516171819# GitHub Start 140.82.113.3 github.com199.232.5.194 github.global.ssl.fastly.net192.30.253.118 gist.github.com185.199.108.153 assets-cdn.github.com199.232.28.133 raw.githubusercontent.com199.232.28.133 gist.githubusercontent.com199.232.28.133 cloud.githubusercontent.com199.232.28.133 camo.githubusercontent.com199.232.28.133 avatars0.githubusercontent.com199.232.28.133 avatars1.githubusercontent.com199.232.28.133 avatars2.githubusercontent.com199.232.28.133 avatars3.githubusercontent.com199.232.28.133 avatars4.githubusercontent.com199.232.28.133 avatars5.githubusercontent.com199.232.28.133 avatars6.githubusercontent.com199.232.28.133 avatars7.githubusercontent.com199.232.28.133 avatars8.githubusercontent.com # GitHub End 3、更新DNS 1ipconfig /flushdns 把本地Git仓库同步到GitHub在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置： 第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令： 1ssh-keygen -t rsa –C “849949161@qq.com” 由于我本地此前运行过一次，所以本地有，如下所示： id_rsa是私钥，不能泄露出去。id_rsa.pub是公钥，可以放心地告诉任何人。 第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。 点击 Add Key，你就应该可以看到已经添加的key。 如何添加远程库？ 现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。 首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下： 在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 命令如下，每一个repository里出现的命令都不是一样的！ 12git remote add origin https://github.com/yangfa4j/gitTest.git // 本地库与远程库关联起来git push -u origin master // 把本地库的内容推送到GitHub上 既是把我目前在d盘的Git仓库同步到GitHub上。 接下来就会弹出一个窗口，要输入你的GitHub账号密码了。 输入正确的 GitHub 账号，此时Git Bash界面出现 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了 –u 参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了。 从现在起，只要本地作了提交，就可以通过如下命令： 1git push origin master 把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。 把GitHub远程仓库同步到本地Git仓库现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？ 首先，登录github，创建一个新的仓库，名字叫testgit2 如下： 如下，我们看到远程GitHub仓库只有一个README.md文件： 现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示： git clone后面跟当前repository浏览器地址。 接着在我本地目录下 生成testgit2目录了，如下所示：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Git&GitHub","slug":"Git-GitHub","permalink":"http://yoursite.com/tags/Git-GitHub/"}]},{"title":"Git","slug":"JAVA/Git&GitHub/Git基本操作","date":"2019-12-04T16:00:00.000Z","updated":"2020-01-01T03:44:10.283Z","comments":true,"path":"2019/12/05/JAVA/Git&GitHub/Git基本操作/","link":"","permalink":"http://yoursite.com/2019/12/05/JAVA/Git&GitHub/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"GITGit工作区的概念 向仓库中添加文件流程 Git的基本操作命令用户名与邮箱的全局设置12$ git config --global user.name \"yangfa\" $ git config --global user.email \"849949161@qq.com\" idea中使用git时，做一些文件忽略 1.idea;*.iml; // 在后面加上忽略idea的配置 git init 初始化本地仓库把这个目录变成git可以管理的本地仓库 git add [文件名] 添加到暂存区在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：111111111， 使用git add 命令把文件添加到暂存区。 git commit 提交当前文件到仓库把文件提交到Git仓库， -m 后面添加注释 git status 查看目前状态 修改文件信息，添加一行2222222222内容，继续使用git status来查看下结果，如下： 上面的命令告诉我们 readme.txt文件已被修改，但是未被提交 git diff [文件名] 查看文件的修改 如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行222222222内容。 对修改后的文件进行提交，先add后commit cat [文件名] 查看文件内容 git reset –hard 版本回退如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行 内容为33333333333333.继续执行add，commit命令 如下： 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令， git reset –hard HEAD^那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。 git reset –hard HEAD~x那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。未回退之前的readme.txt内容如下： 如果想回退到上一个版本的命令如下操作： 第一种: 第二种： 接着查看文件内容如下： 已经回退到第二个版本了。 git log 查看历史记录 git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111。 git log –pretty=oneline 一行显示历史记录如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下： git reflog 获取每次提交的版本号，便于版本切换 git reset –hard [版本号] 根据版本号，回退到指定版本使用git log 来查看下历史记录信息，如下： 我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下： 先查看每次操作后的版本号：git reflog 通过版本号定位版本，最后回退： 通过上面的显示我们可以知道，增加内容3333的版本号是 4f30862.我们现在可以通过回退命令返回指定的版本。 git reset –hard 版本号1git reset --hard 4f30862 // 根据git reflog 查到的版本号 回退 git clone 克隆把GitHub中的仓库克隆到本地Git仓库。 git push 推送到远端git branch 查看当前分支git branch [分支名] 创建分支 git branch -v 查看所有的分支 git branch -d [分支名] 删除分支只有分支被合并后才能被删除 git checkout 切换分支git checkout -b [分支名] 创建并切换分支 git checkout [分支名] 切换到指定分支 git marge [分支名] 当前所在分支与参数分支合并理解工作区与暂存区的区别工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 我们前面说过使用Git提交文件到版本库有两步： 第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下： 现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下： 接着我们可以使用git commit一次性提交到分支上，如下： Git撤销修改和删除文件操作git checkout – [ 文件名] 撤销修改比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下： 在我未提交之前，我发现添加5555555555555内容有误，我要撤销修改，如下： 你可以发现，Git会告诉你，git checkout – [ 文件名] 可以丢弃工作区的修改： git checkout – readme.txt,如下所示： 注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。 rm 删除文件假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下： 如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交，现在目录是这样的， 只要在没有commit之前，还可以在版本库中恢复此文件，如何操作呢？如下： 再来看看我们testgit目录，添加了3个文件了。如下所示： 至此GIT中常用的命令都已经介绍完了。下面进入GitHub的学习。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Git&GitHub","slug":"Git-GitHub","permalink":"http://yoursite.com/tags/Git-GitHub/"}]},{"title":"JavaTime","slug":"JAVA/Java8/javaTime","date":"2019-12-03T16:00:00.000Z","updated":"2020-03-30T13:55:40.593Z","comments":true,"path":"2019/12/04/JAVA/Java8/javaTime/","link":"","permalink":"http://yoursite.com/2019/12/04/JAVA/Java8/javaTime/","excerpt":"","text":"LocalDateTime获取此刻时间 构造一个指定年、月、日的时间比如：2019年10月12日9时21分32秒 修改日期 格式化日期 线程安全DateTimeFormatter 123456789101112131415161718DateTimeFormatter[] formatters = new DateTimeFormatter[]&#123; // 直接使用常量创建DateTimeFormatter格式器 DateTimeFormatter.ISO_LOCAL_DATE, DateTimeFormatter.ISO_LOCAL_TIME, DateTimeFormatter.ISO_LOCAL_DATE_TIME, // 使用本地化的不同风格来创建DateTimeFormatter格式器 DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.MEDIUM), DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG), // 根据模式字符串来创建DateTimeFormatter格式器 DateTimeFormatter.ofPattern(\"yyyy MMM dd HH:mm:ss\")&#125;;LocalDateTime date = LocalDateTime.now(); //获取当前本地时间// 依次使用不同的格式器对LocalDateTime进行格式化for(int i = 0 ; i &lt; formatters.length ; i++)&#123; System.out.println(formatters[i].format(date)); // 格式化日期&#125; Instant 时间戳12Instant instant = Instant.now(); // 获取以 UTC 时区的时间System.out.println(instant); // 2019-12-28T00:43:14.752Z Duration、Period两个类表示时间量或两个日期之间的差 两者之间的差异为：Duration基于时间值，Period基于日期值。 Duration 类 计算两个 时间(time) 之间的间隔Duration类 表示秒或纳秒时间间隔，适合处理较短的时间，需要更高的精确性。 我们能使用between() 方法比较两个瞬间的差： 123456LocalTime startTime = LocalTime.now();Thread.sleep(20000);LocalTime endTime = LocalTime.now();Duration between = Duration.between(startTime, endTime);System.out.println(between.getSeconds()); // 使用get to等方法获取所需数据 Period 类 计算两个 日期(date) 之间的间隔Period 类表示一段时间的年、月、日，使用between()方法获取两个日期之间的差作为Period 对象返回： 123456789LocalDate startDate = LocalDate.of(2015, 2, 20);LocalDate endDate = LocalDate.of(2017, 1, 15); Period period = Period.between(startDate, endDate);//用 Period 类方法获取日期单元System.out.println(period.getYears()); // 获取两个日期之间差几年System.out.println(period.getMonths());// 获取两个日期之间差几月System.out.println(period.getDays()); // 获取两个日期之间差几天 TemporalAdjuster 时间矫正器使用 TemporalAdjuster 可以对当前时间进行处理，如下个周一，下个周日等等需求。 方法通常以 With 开头。 123456789101112131415LocalDate today = LocalDate.now();System.out.println(\"今天: \" + today);// 使用DateAdjuster将今天的日期调整到下周一LocalDate nextMonday = today.with(TemporalAdjusters.next(DayOfWeek.MONDAY));System.out.println(\"下周一: \" + nextMonday);// 使用 TemporalAdjuster 将今天的日期调整为月的最后一天LocalDate lastDayOfMonth = today.with(TemporalAdjusters.lastDayOfMonth());System.out.println(\"这个月最后一天: \" + lastDayOfMonth);// 创建一个在3个月2天后日期的 TemporalAdjusterTemporalAdjuster adjuster = TemporalAdjusters.ofDateAdjuster((LocalDate date) -&gt; date.plusMonths(3).plusDays(2));LocalDate dayAfter3Mon2Day = today.with(adjuster);System.out.println(\"三月零两天后的日期: \" + dayAfter3Mon2Day);","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"Docker","slug":"容器技术/Docker","date":"2019-12-02T16:00:00.000Z","updated":"2019-12-28T00:20:05.374Z","comments":true,"path":"2019/12/03/容器技术/Docker/","link":"","permalink":"http://yoursite.com/2019/12/03/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker/","excerpt":"","text":"Docker什么是DockerDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 比虚拟机更为高端，轻量级容器技术 一个完整的Docker有以下几个部分组成： DockerClient客户端 Docker Daemon守护进程（后台进程） Docker Image镜像 DockerContainer容器 就是把Linux中的软件环境打包成镜像，在别的Linux机器上安装这个镜像，每个镜像跟镜像之间相互隔离，这就是Docker。运行中的镜像称为容器，容器的启动速度是非常快速的。 核心概念Docker主机(Host)：安装了Docker主机的机器（直接安装在操作系统上）。 Docker客户端(Client)：连接Docker主机进行操作。 Docker仓库(Registry)：用来存放打包好的软件镜像放在仓库中https://hub.docker.com/ Docker容器(Container)：镜像启动后的实例称为一个容器，容器是独立的一个或是一组应用； 使用Docker的步骤: 1、安装Docker 2、去Docker仓库找到这个软件相应的镜像，并下载在本地 3、使用Docker命令运行这个这个镜像，这个镜像就会生成一个Docker容器 4、对容器的启动停止就是对软件的启动停止 安装Docker1、查看Centos系统的内核，uname -r 必须高于3.10及以上 2、yum install docker，或者官网文档 3、启动Docker systemctl start docker 4、查看docker版本 docker -v 5、设置开机启动 systemctl enable docker 6、停止docker systemctl stop docker 查阅官方文档： https://docs.docker.com/install/linux/docker-ce/centos/ 命令如下： 12345$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo$ sudo yum install docker-ce docker-ce-cli containerd.io$ sudo systemctl start docker$ sudo docker run hello-world 常用操作镜像操作搜索：docker search xxx 拉取：docker pull xxx 查看所有镜像：docker images 删除镜像：docker rmi 镜像id 容器操作软件镜像 — 运行镜像 — 产生一个容器（正在运行的软件），一个镜像可以启动多个容器。 1、运行：–name 自定义容器名 -p 虚拟机端口到容器的映射 -d后台运行 名字 1docker run --name mytomcat -p 8080:8080 -d tomcat 创建一个容器 2、查看运行容器：docker ps 查看所有容器：docker ps -a 3、停止： docker stop 容器name | 容器id 4、启动： docker start 容器name | 容器id 5、删除 ：docker rm 容器id 容器必须停止状态 6、进入容器：docker exec -it 容器name | 容器id /bin/bash 7、查看容器的日志：docker logs 容器name | 容器id 8、查看端口占用: netstat -ntlp 5. 阿里云Docker镜像加速 https://cr.console.aliyun.com/cn-hangzhou/instances/repositories 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://gn3uz2n5.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 6. 阿里云 maven 加速 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 7. 常用容器启动命令 1、启动redis 12docker run -d -it -p 6379:6379 redis redis-server --appendonly yes docker exec -it c6cde1eddf22 redis-cli // redis客户端连接命令 2、启动RabbitMQ 5672是rabbitMQ 的容器使用端口（映射为5672），15672是web页面管理端口（对外映射为15672） 12docker run -d -p 5672:5672 -p 15672:15672 --name rabbitMQ 99cbda713eff docker exec -it rabbitMQ /bin/bash // 进入 RabbitMQ 容器 3、启动 ActiveMQ 命令 61616是 activeMQ 的容器使用端口（映射为61616），8161是web页面管理端口（对外映射为8161） 12docker run -d --name activeMQ -p 61616:61616 -p 8161:8161 webcenter/activemq docker exec -it activeMQ /bin/bash // 进入 ActiveMQ 容器","categories":[{"name":"容器技术","slug":"容器技术","permalink":"http://yoursite.com/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"Optional","slug":"JAVA/Java8/Optional","date":"2019-12-02T16:00:00.000Z","updated":"2019-12-30T14:13:50.410Z","comments":true,"path":"2019/12/03/JAVA/Java8/Optional/","link":"","permalink":"http://yoursite.com/2019/12/03/JAVA/Java8/Optional/","excerpt":"","text":"Optional容器类Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException） 简单的方法1234567891011121314151617// 得到容器中的对象，如果为null就抛出异常public T get() &#123; if (value == null) &#123; throw new NoSuchElementException(\"No value present\"); &#125; return value;&#125;// 判断容器中的对象是否为nullpublic boolean isPresent() &#123; return value != null;&#125;// 如果容器中的对象存在，则返回。否则返回传递进来的参数public T orElse(T other) &#123; return value != null ? value : other;&#125; Lambda表达式方法ifPresent()如果容器中的对象存在，则调用accept方法 123User user = new User(7L, \"张三\", 24, \"wwwwwwwww\");Optional&lt;User&gt; optional = Optional.ofNullable(user);optional.ifPresent(System.out::println); orElse(T other) 与 orElseGet(Supplier&lt;? extends T&gt; other)1234567891011121314@Testpublic void test2() &#123; Student student = new Student(1, \"A\", \"M\", 184); Student student1 = Optional.ofNullable(student).orElse(createStudent()); Student student2 = Optional.ofNullable(student).orElseGet(this::createStudent); &#125;public Student createStudent()&#123; Student student = new Student(); student.setName(\"新增的学生\"); System.out.println(\"新增的学生的方法执行了\"); return student;&#125; 这两个函数的区别： 当user值不为null时，orElse函数依然会执行 createStudent() 方法 而orElseGet函数并不会执行 createStudent() 方法，大家可自行测试。 filter()如果容器中的对象存在，并且符合过滤条件，返回装载对象的Optional容器，否则返回一个空的Optional容器。 1234Optional&lt;User&gt; optional = Optional.ofNullable(user) .filter((u) -&gt; \"张三\".equals(u.getName()));System.out.println(\"optional = \" + optional);System.out.println(\"stringOptional = \" + stringOptional); // 返回optional map()如果容器的对象存在，则对其执行调用mapping函数得到返回值。然后创建包含mapping返回值的Optional，否则返回空Optional。 123Optional&lt;User&gt; optional = Optional.ofNullable(user);Optional&lt;String&gt; stringOptional = optional.map( u -&gt; u.getEmail().toUpperCase());System.out.println(\"stringOptional = \" + stringOptional); // 返回optional","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"Stream","slug":"JAVA/Java8/Stream","date":"2019-12-01T16:00:00.000Z","updated":"2019-12-30T14:13:40.461Z","comments":true,"path":"2019/12/02/JAVA/Java8/Stream/","link":"","permalink":"http://yoursite.com/2019/12/02/JAVA/Java8/Stream/","excerpt":"","text":"StreamJava 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。 中间操作筛选与切片filter接收 Lambda，从流中过滤某些数据 123list.stream() .filter( (student -&gt; student.getNo() &gt; 3) ) //中间操作过滤编号小于4 .forEach( (student -&gt; System.out.println(student.toString()))); limit截断流，使其元素不超过指定数量 123list.stream() .limit(2) //截断流，只取前两个 .forEach((student -&gt; System.out.println(student))); skip跳过元素，返回一个扔掉了前n个元素的流，与limit相反 123list.stream() .skip(2) //跳过流的前两个 .forEach((System.out::println)); distinct通过 equals() 和 hashCode() 去除 123list.stream() .distinct() .forEach((System.out::println)); 映射map接收 Lambda，将元素转换成其他形式，接受一个函数，会作用到每一个元素上。 123list.stream() .map((String::toUpperCase)) // 映射函数 .forEach((System.out::println)); flatMap 把几个小的list转换到一个大的list,返回的是集合类型 12345678910111213141516171819202122232425262728293031323334List&lt;String&gt; list1 = Arrays.asList(\"1\", \"2\", \"3\");List&lt;String&gt; list2 = Arrays.asList(\"4\", \"5\", \"6\");List&lt;String&gt; list3 = Arrays.asList(\"7\", \"8\", \"9\");List&lt;String&gt; list4 = Arrays.asList(\"a\", \"b\", \"c\");List&lt;String&gt; list5 = Arrays.asList(\"d\", \"e\", \"f\");List&lt;String&gt; list6 = Arrays.asList(\"g\", \"h\", \"i\");List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;();lists.add(list1);lists.add(list2);lists.add(list3);lists.add(list4);lists.add(list5);lists.add(list6);// Let's print all string before Java 8List&lt;String&gt; listOfAllName = new ArrayList&lt;&gt;();for(List&lt;String&gt; team : lists)&#123; for(String name : team)&#123; listOfAllName.add(name); &#125;&#125;System.out.println(\"Players playing in world cup 2016\");System.out.println(listOfAllName);// Now let's do this in Java 8 using FlatMapList&lt;String&gt; flatMapList = lists.stream() .flatMap(pList -&gt; pList.stream()) .collect(Collectors.toList());System.out.println(\"List of all Players using Java 8\");System.out.println(flatMapList); 排序sorted()123list.stream() .sorted() // 自然排序 .forEach((System.out::println)); sorted（Comparator com） 定制排序123list.stream() .sorted(Comparator.comparingInt(String::length)) // 定制排序 .forEach((System.out::println)); 终止操作查找与匹配allMatch是否全部匹配，返回Boolean值 123boolean g = list.stream() .allMatch((student -&gt; student.getSex().equals(\"G\")));System.out.println(g); anyMatch至少匹配一个，返回Boolean值 123boolean g = list.stream() .anyMatch((student -&gt; student.getSex().equals(\"G\")));System.out.println(g); noneMatch没有匹配元素，返回Boolean值 123boolean g = list.stream() .noneMatch((student -&gt; student.getSex().equals(\"G\")));System.out.println(g); findFirst返回第一个元素，封装为一个Optional，避免了空指针 12Optional&lt;Student&gt; first = list.stream().findFirst();System.out.println(first.get()); findAny返回当前流中任意的元素 12Optional&lt;Student&gt; any = list.stream().findAny();System.out.println(any.get()); count返回流中元素总个数 12long count = list.stream().count();System.out.println(count); max返回流中最大值，找出最高学生的信息 123Optional&lt;Student&gt; max = list.stream() .max((x, y) -&gt; Float.compare(x.getHeight(), y.getHeight())); // float 比较System.out.println(max.get()); min返回流中最小值，找出学生中最矮的学生身高 1234Optional&lt;Float&gt; min = list.stream() .map((Student::getHeight)) // map 把身高拿出来，返回只有身高的流 .min(Float::compare);System.out.println(min.get()); 归纳map - reduce 模式是将流中元素反复结合起来，得到一个值，有两种表现形式 一个参数的Reduce1234Optional&lt;Float&gt; reduce = list.stream() .map((Student::getHeight)) // 获得每个学生的身高 .reduce(Float::sum); // 将身高总和加起来System.out.println(reduce.get()); 假设Stream中的元素a[0]、a[1]、a[2]…a[n - 1]，表示将a[0]与a[1]进行二合运算，结果与a[2]做二合运算，一直到最后与a[n-1]做二合运算。 两个参数的Reduce1234Float reduce = list.Float reduce = list.stream() .map((Student::getHeight)) // 获得每个学生的身高 .reduce(0f, Float::sum); // 定义一个初始化的值为0System.out.println(reduce); 它多了一个初始化的值，因此计算的顺序是identity与a[0]进行二合运算，结果与a[1]再进行二合运算，最终与a[n-1]进行二合运算，identity一般设为不影响结果的值。 收集collect是将流转换为其他形式。接收一个 Collector 接口的实现，用于给Stream中元素做汇总的方法。 1234Set&lt;String&gt; collect = list.stream() .map((Student::getName)) // 获取所有学生的身高 .collect(Collectors.toSet()); // 把学生的名字收集到 set 集合中去System.out.println(collect); // 去重结果 1234HashSet&lt;String&gt; collect = list.stream() .map((Student::getName)) //什么集合，就是 集合名字::new .collect(Collectors.toCollection(HashSet::new)); System.out.println(collect); Idea流调试工具如下代码： 1234567Arrays.asList(\"How are you\", \"Hello\", \"Tom\", \"Hi\", \"Hell\", \"Jerry\") .stream() .filter(s -&gt; s.startsWith(\"H\")) .map(s -&gt; s.substring(2)) .distinct() .sorted() .collect(Collectors.toList()); 打上断点，点击如下图标","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"Mybatis的增删改查","slug":"JAVA/Mybatis/Mybatis增删改查","date":"2019-12-01T16:00:00.000Z","updated":"2020-02-04T05:53:21.623Z","comments":true,"path":"2019/12/02/JAVA/Mybatis/Mybatis增删改查/","link":"","permalink":"http://yoursite.com/2019/12/02/JAVA/Mybatis/Mybatis%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","excerpt":"","text":"Mybatis的增删改查在上次篇文章的基础上，我们使用 MyBatis 对 student 表完成简单的增删改查操作。 增123&lt;insert id=\"addStudent\" parameterType=\"Student\" &gt; INSERT INTO student(name) value(#&#123;name&#125;) &lt;/insert&gt; 删123&lt;delete id=\"deleteStudent\" parameterType=\"java.lang.Integer\" &gt; DELETE FROM student WHERE id = #&#123;id&#125; &lt;/delete&gt; 改123&lt;update id=\"updateStudent\" parameterType=\"Student\" &gt; UPDATE student SET name = #&#123;name&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; 查都会有resultType 查询一个对象123&lt;select id=\"selectOne\" resultType=\"Student\" parameterType=\"int\"&gt; select * from student where id = #&#123;id&#125;&lt;/select&gt; 查询对象集合123&lt;select id=\"selectList\" resultType=\"Student\" &gt; select * from student&lt;/select&gt; 模糊查询:需要sql拼接，是${}拼接符，且只能是${value} 123&lt;select id=\"selectLike\" resultType=\"Student\" parameterType=\"String\"&gt; SELECT * FROM student WHERE name LIKE '%$&#123;value&#125;%' &lt;/select&gt; resultType1、基本类型：resultType = 基本类型 2、JavaBean 类型：单条记录：resultType = JavaBean 类型 ​ 多条记录：resultType = List 中 JavaBean 的类型 3、Map类型：单条记录：resultType = map ​ 多条记录：resultType = Map中 value 的类型 Map单条记录返回单条记录的map，key为属性，值为属性值。resultType为map 1234public interface HotelMapper &#123; // 返回值为Map，key为属性名，value为属性值 public Map&lt;String, Object&gt; getHotelByID(Integer id);&#125; 1234&lt;!-- 返回值为map，resultType为 map --&gt;&lt;select id=\"getHotel\" resultType=\"map\"&gt; select * from hotel where id = #&#123;id&#125;&lt;/select&gt; Map多条记录返回多条记录的map时，key为任意一属性，值为对象类型 不过key需要通过@MapKey(“hotelName”)指定对象中一个属性名为key 12345public interface HotelMapper &#123; // 返回值为Map，key需要通过@MapKey(\"属性名\")来指定javaBean中的一个属性名为key，value为对象 @MapKey(\"hotelName\") // 指定用旅店名字当key public Map&lt;String, Hotel&gt; getHotel(Integer price);&#125; 注意 resultType 返回值类型，不再是 ‘map’，而是 Map 的 value 对应的 JavaBean 类型 123&lt;select id=\"getHotel\" resultType=\"Hotel\"&gt; &lt;!-- Hotel --&gt; select * from hotel where price &gt; #&#123;price&#125;&lt;/select&gt; parameterType一般不用写这个属性，mybatis框架会自动解析传入的参数类型","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"Mybatis高级映射","slug":"JAVA/Mybatis/Mybatis高级映射","date":"2019-12-01T16:00:00.000Z","updated":"2020-02-04T05:53:30.812Z","comments":true,"path":"2019/12/02/JAVA/Mybatis/Mybatis高级映射/","link":"","permalink":"http://yoursite.com/2019/12/02/JAVA/Mybatis/Mybatis%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84/","excerpt":"","text":"Mybatis高级映射查询的语句，都会有结果集，resultType 与 resultMap不能同时出现。 插入，修改，删除，可能会遇见要使用自增长值，useGeneratedKeys=”true” 。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。接下来看如何使用resultMap。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"Mybatis入门","slug":"JAVA/Mybatis/Mybatis入门","date":"2019-12-01T16:00:00.000Z","updated":"2020-01-02T15:03:25.764Z","comments":true,"path":"2019/12/02/JAVA/Mybatis/Mybatis入门/","link":"","permalink":"http://yoursite.com/2019/12/02/JAVA/Mybatis/Mybatis%E5%85%A5%E9%97%A8/","excerpt":"","text":"Mybatis入门MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs (Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。简化了dao层操作，SQL语句不能加分号。 Mybatis依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt;&lt;/dependency&gt; 从 XML 中构建 SqlSessionFactory​ 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 mybatis-config.xml​ XML 配置文件中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- Mybatis环境的配置，配置要操作的数据库 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射器的配置，数据库操作命令所在XML文档 --&gt; &lt;mappers&gt; &lt;!-- mapper的带包路径 --&gt; &lt;mapper resource=\"mapper/StudentMapper.xml\"/&gt; &lt;!-- Student实体映射器 --&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建SqlSessionFactory​ 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但是也可以使用任意的输入流（InputStream）实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。 123String resource = \"com/mybatis/test/mybatis-config.xml\"; // 定义mybatis配置文件路径InputStream inputStream = Resources.getResourceAsStream(resource); // 获得文件输入流SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 映射器Mapper的使用Mapper，对sql语句的映射，命名为：实体名+mapper.xml，如上StudentMapper.xml。 StudentMapper.xml1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- 包+文件名，去后缀，使得xml配置文件与XXXmapper.java 相关联，后面创建mapper类简化代码会用到 --&gt;&lt;mapper namespace=\"mapper.studentMapper\"&gt; &lt;!-- 定义了查询学生的方法 --&gt; &lt;select id=\"selectOne\" resultType=\"entity.Student\"&gt; select * from student where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 通过配置文件（config）找到了映射关系（mapper），就可以通过java代码，操作数据库了。 12345678@Test public void Demo1() throws Exception &#123; String resource = \"config/mybatis-config.xml\"; //读取配置 InputStream in = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); SqlSession Session = sqlSessionFactory.openSession(); //调用mapper.studentMapper.xml的selectOne.返回实体 Student s = Session.selectOne(\"mapper.studentMapper.selectOne\", 8); System.out.println(s); //8是参数,id为8的学生 &#125; Mapper代理，简化操作创建studentMapper接口，与xml名字一样。接口中方法名与XML中定义的statement的id对应，定义的方法最多只能有一个参数，可以为Map或对象。接口的返回类型与参数类型与Mapper.xml文件对应！ 创建代理接口： 123public interface StudentMapper &#123; public Student selectOne(int id); //查询一个学生方法 &#125; 使用完全限定名调用 Java 对象的方法类似。这样，该命名就可以直接映射到在命名空间中同名的 Mapper 类，并将已映射的 select 语句中的名字、参数和返回类型匹配成方法。可以容易地调用这个对应 Mapper 接口的方法，就像下面这样： 12345//代理mapper方式，由sqlSession对象获得代理对象 studentMapper mapper = Session.getMapper(studentMapper.class); //传入代理接口字节码 //由代理对象操作数据库 Student student = mapper.selectOne(10); System.out.println(student); 第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点； 其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择已映射的 SQL 语句。 加强配置信息typeAliases类型别名​ 简化 mapper.xml 中 resultType 的书写，在mybatis-config.xml 后面添加，typeAliases 标签，后面可以加入package 标签。 1234&lt;!-- 类型别名 --&gt;&lt;typeAliases&gt; &lt;package name=\"entity\"/&gt; &lt;!-- 所有的实体以类名命名 --&gt;&lt;/typeAliases&gt; 这样，我们在写resultType 时就可以直接写类名了 123&lt;select id=\"selectOne\" resultType=\"Student\"&gt; select * from student where id = #&#123;id&#125; &lt;/select&gt; 注解方式使用Mybatis对于像 StudentMapper 这样的映射器类来说，还有另一种方法来处理映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可被替换如下： 修改StudentMapper.java文件 1234public interface StudentMapper &#123; @Select(\"SELECT * FROM student WHERE id = #&#123;id&#125;\") public Student selectOne(int id); //查询一个学生方法 &#125; 使用注解来映射简单语句会使代码显得更加简洁，然而对于稍微复杂一点的语句，Java 注解就力不从心了，并且会显得更加混乱。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"Lambda","slug":"JAVA/Java8/Lambda","date":"2019-11-30T16:00:00.000Z","updated":"2019-12-28T00:48:55.610Z","comments":true,"path":"2019/12/01/JAVA/Java8/Lambda/","link":"","permalink":"http://yoursite.com/2019/12/01/JAVA/Java8/Lambda/","excerpt":"","text":"Lambda 表达式复制小括号，写死右箭头，落地大括号。 函数式接口函数式接口就是只显式声明一个抽象方法的接口。为保证方法数量不多不少，java8提供了一个专用注解 @FunctionalInterface，这样，当接口中声明的抽象方法多于或少于一个时就会报错。如下图所示： Java内置的四大核心函数式接口1234567891011Consumer&lt;T&gt; 消费型接口 消费对象 void accept(T t);Supplier&lt;T&gt; 供给型接口 生成对象 T get();Function&lt;R,T&gt; 函数型接口 指定特定功能 R apply(T t);Predicate&lt;T&gt; 断言型接口 进行条件判断 boolean test(T t); Lambda表达式Lambda表达式本质上是一个匿名方法。让我们来看下面这个例子： 123public int add(int x, int y) &#123; return x + y; &#125; 转成Lambda表达式后是这个样子： 1(int x, int y) -&gt; &#123; x + y; &#125; // 复制小括号 写死右箭头 落地大括号 参数类型也可以省略，Java编译器会根据上下文推断出来： 1(x, y) -&gt; &#123; x + y; &#125; // 隐式的自动返回 或者 1(x, y) -&gt; &#123; return x + y; &#125; // 显式指明返回值 可见Lambda表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。 Lambda表达式几种类型有参无返回值接口 1234@FunctionalInterfacepublic interface InterfaceWithParams &#123; void run(String s);&#125; 实现 12345678InterfaceWithParams params = new InterfaceWithParams() &#123; @Override public void run(String s) &#123; System.out.println(\"通过\" + s + \"实现run(String)\"); &#125;&#125;;InterfaceWithParams params1 = (String s) -&gt; System.out.println(\"通过\" + s + \"实现run(String)\"); 测试 12this.params.run(\"匿名类\");this.params1.run(\"Lambda\"); 无参有返回值接口 1234@FunctionalInterfacepublic interface InterfaceUnVoidWithNoParam &#123; String run();&#125; 实现 123456789InterfaceUnVoidWithNoParam interfaceUnVoidWithNoParam = new InterfaceUnVoidWithNoParam() &#123; @Override public String run() &#123; return \"Hello World!\"; &#125;&#125;;//省略掉了returnInterfaceUnVoidWithNoParam interfaceUnVoidWithNoParam1 = () -&gt; \"Hello Lambda!\"; 测试 1234String s = this.interfaceUnVoidWithNoParam.run();System.out.println(\"返回结果是：\" + s);String s0 = this.interfaceUnVoidWithNoParam1.run();System.out.println(\"返回结果是：\" + s0); 有参有返回值接口 1234@FunctionalInterfacepublic interface InterfaceUnVoidWithParams &#123; String run(Integer integer);&#125; 实现 12345678InterfaceUnVoidWithParams interfaceWithParams = new InterfaceUnVoidWithParams() &#123; @Override public String run(Integer integer) &#123; return String.valueOf(integer); &#125;&#125;;InterfaceUnVoidWithParams interfaceWithParams1 = (Integer integer) -&gt; String.valueOf(integer); 测试 1234String s1 = this.interfaceWithParams.run(1);System.out.println(\"您输入的是：\" + s1);String s2 = this.interfaceWithParams1.run(2);System.out.println(\"您输入的是：\" + s2);","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"SpringBoot集成Swagger2","slug":"SpringBoot/Swagger","date":"2019-11-30T13:17:24.000Z","updated":"2019-12-28T00:23:44.023Z","comments":true,"path":"2019/11/30/SpringBoot/Swagger/","link":"","permalink":"http://yoursite.com/2019/11/30/SpringBoot/Swagger/","excerpt":"","text":"Swagger我们提供Restful接口的时候，API文档是尤为的重要，它承载着对接口的定义，描述等。它还是和API消费方沟通的重要工具。在实际情况中由于接口和文档存放的位置不同，我们很难及时的去维护文档。个人在实际的工作中就遇到过很多接口更新了很久，但是文档却还是老版本的情况，其实在这个时候这份文档就已经失去了它存在的意义。而Swagger是目前我见过的最好的API文档生成工具，使用起来也很方便，还可以直接调试我们的API。我们今天就来看下Swagger2与SpringBoot的结合。 导入依赖12345678910111213&lt;!-- swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; Swagger 的配置类1234567891011121314151617181920212223242526272829303132333435363738@Configuration@EnableSwagger2public class SwaggerConfig extends WebMvcConfigurationSupport &#123; @Bean public Docket productApi() &#123; return new Docket(DocumentationType.SWAGGER_2).select() // 扫描的包路径 .apis(RequestHandlerSelectors.basePackage(\"com.yf.controller\")) // 定义要生成文档的Api的url路径规则 .paths(PathSelectors.any()) .build() // 设置swagger-ui.html页面上的一些元素信息。 .apiInfo(metaData()); &#125; private ApiInfo metaData() &#123; return new ApiInfoBuilder() // 标题 .title(\"SpringBoot集成Swagger2测试\") // 描述 .description(\"这是一篇博客演示\") // 文档版本 .version(\"1.0.0\") .license(\"Apache License Version 2.0\") .licenseUrl(\"https://www.apache.org/licenses/LICENSE-2.0\") .build(); &#125; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); &#125;&#125; Swagger 常用注解 @Api() 用于类：表示标识这个类是swagger的资源 tags——表示说明 value——也是说明，可以使用tags替代 但是tags 如果有多个值，会生成多个list 12345@Api(value=\"用户controller\",tags=\"用户操作接口\")@RestControllerpublic class UserController &#123;&#125; @ApiOperation() 用于方法：表示一个 http 请求的操作 value——用于方法描述 notes——用于提示内容 tags可以重新分组（视情况而用） 12345@ApiOperation(value = \"获取用户列表\",notes = \"获取所有用户的信息\")@GetMapping(\"/users\")public Object index() &#123; &#125; @ApiParam() 用于参数：对方法参数的补充说明 name——参数名 value——参数的描述 required——是否必填 123456@ApiOperation(value = \"根据用户ID查询用户\",notes = \"查询单个用户的信息\")@ApiParam(name =\"id\",value = \"用户id\",required = true)@GetMapping(\"/users/&#123;id&#125;\")public Object getUserById(@PathVariable(\"id\") String id) &#123; &#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"树","slug":"数据结构/树","date":"2019-11-27T16:00:00.000Z","updated":"2020-01-01T02:52:27.572Z","comments":true,"path":"2019/11/28/数据结构/树/","link":"","permalink":"http://yoursite.com/2019/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/","excerpt":"","text":"树树是n(n&gt;=0)个结点的有限集。n=0时称为空树。在任意一棵非空树种：(1)有且仅有一个特定的称为根(Root)的结点；(2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集，其中每一个集合本身又是一棵树，并且称为根的子树。 定义之前的顺序表 栈 队列 都是一对一的线性结构，现在需要一对多的结构，树就是一对多的数据结构。 结点分类根节点 内部结点 叶节点/终端结点。 其他定义如果树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 树中结点的最大层次称为树的深度。 森林是m(m&gt;=0)棵互不相交的树的集合。 树的存储结构之前有顺序存储结构，现在有链式存储结构。但是那都是一对一的关系，现在需要一对多的关系。如果树中结点只是简单的顺序结构，那就体现不了结点之间的一对多关系。可以充分结合链式和顺序存储的特点，让它能体现出一对多的关系。 双亲表示法每个结点都有一个指针域来指向它的父节点。根节点的指针域为-1。 特点是找结点的双亲方便。 孩子表示法每个结点都有多个指针域，其中每一个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法。 把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。 特点是找结点的孩子方便。 孩子兄弟表示法任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。 特点是找结点的兄弟结点方便。 二叉树一个结点只有左右两个结点。 折半查找目的是有规律的缩减筛选条件，当条件小到中间只差1，不就找到那个元素了。 二叉树定义二叉树(Binary Tree)是n(n&gt;=0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根节点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成。 二叉树特点 每个结点最多两棵子树，且每个结点的度最大也为2 子树需要区分顺序，左和右本来就是他们的特点 满二叉树可以说把二叉树填充满就是完全二叉树。在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 完全二叉树特点：满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。 对一棵具有n个结点的二叉树按层序排号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这可二叉树称为完全二叉树。 上面的解释读起来有点抽象，比喻一下就是，每一层的结点只能是从左向右按次序排，这层排满才能排下一层的结点。 遍历二叉树因为每个结点对应至多两个方向，那么每选择一个方向就是一个新的路线。限制遍历顺序是从左往右，就有以下几种顺序。二叉树的定义是递归的方式，每一个结点和子结点都可以看做一个最短二叉树。那么实现遍历算法也可以采用递归。 前序遍历代码如图： 123456789public void preOrder()&#123; System.out.println(this); if (this.lrft != null)&#123; this.lrft.preOrder(); &#125; if (this.right != null)&#123; this.right.preOrder(); &#125;&#125; 从根结点开始记录，一直读左子树，直到终端结点，再读右终端节点往上读。 中序遍历代码如图： 123456789public void infixOrder()&#123; if (this.lrft != null)&#123; this.lrft.infixOrder(); &#125; System.out.println(this); if (this.right != null)&#123; this.right.infixOrder(); &#125; &#125; 从左子树的终端结点开始读，再读终端结点父结点，再读右终端结点。 后序遍历代码如图： 123456789public void lastOrder()&#123; if (this.lrft != null)&#123; this.lrft.lastOrder(); &#125; if (this.right != null)&#123; this.right.lastOrder(); &#125; System.out.println(this); &#125; 从左子树的终端结点开始读，再读右终端结点，再读终端结点父结点。 遍历方式意义方便计算机识别，计算机只有循环、判断等方式处理，它只会处理线性序列；而上边的遍历顺序就是把在树中的结点变成某种意义的线性序列。 如果给出前序和中序遍历的结果请推导出后序遍历像这种情况，就是需要充分理解上面的算法的特点。递归和前中后这两个特点是推导的关键，我们可以把每一个子树中在最后或者最前位置的结点看为根结点(根据前序和后序的特点)，中序遍历就是确定谁是左子树谁是右子树。 线索话二叉树将二叉树的每一个结点都增加两个指针域，其中左指针域指向它的孩子结点，同理右指针域。这样总会有一些空指针域，为了提高利用率，就将空指针域进行改造；左边的空指针域就指向中序遍历的前结点，右边的空指针域就指向中序遍历的后结点。仅仅这样还是无法知道结点的左指针域指向的到底是左孩子还是它的前驱结点。那么给结点再增加两个布尔域，用来辨别它的左右指针指向的是前驱还是孩子。 二叉排序树二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。 对于二叉排序树，要求任何一个非叶子结点，其左子树结点的值比当前结点小，右子结点的值比当前结点大。 平衡二叉树（AVL），对BST的升级 每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。&gt;1 的时候，就需要考虑用旋转了。** 并且左右两个子树都是一棵平衡二叉树。 单旋转1、左单旋：任何一个结点，他的右子树的高度 - 左子树的高度 &gt;1 的时候，就要考虑左旋了，左旋是为了解决右子树太高的问题。 https://img-blog.csdn.net/20180722220546910 2、右单旋：任何一个结点，他的左子树的高度 - 右子树的高度 &gt;1 的时候，就要考虑右旋了，右旋是为了解决左子树太高的问题。 https://img-blog.csdn.net/20180722222413303 方案：将左子树的右子树链接到父亲结点的左孩子结点，父亲结点作为左孩子结点的右孩子结点便完成了旋转。 3、双旋转：当一个结点的左右子树中，有不是AVL 树时，就需要对 左子树 或 右子树 进行旋转，情况有以下四种，递归执行。 只有当每个子树都是AVL树的时候，才能操作Root结点。 当左子结点的 左子树 的高度大于 右子树 的高度时，需要右旋 当左子结点的 左子树 的高度小于 右子树 的高度时，需要左旋 当右子结点的 左子树 的高度大于 右子树 的高度时，需要右旋 当右子结点的 左子树 的高度小于 右子树 的高度时，需要左旋 红黑树 红黑树 和 AVL 树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的 n 是树中元素的数目。 红黑树的性质 根节点是黑色 父子不能同为红色 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 平衡多叉树（B树，B+树）将树的度设为 1024，600亿 个元素最多只需要 4次 I/O 操作就可以取得想要的元素，效率是非常的快的。 B树广泛的应用于 文件存储系统 和 数据库系统中（索引） 。 2-3树2-3树是最简单的B树结构，2-3树 满足如下条件： 所有叶子结点都在同一层（平衡多叉树必须满足的条件） 有两个子结点的结点叫二结点，二结点要么没有子结点，要么有两个子结点 有三个子结点的结点叫三结点，三结点要么没有子结点，要么有三个子结点 2-3树 是由二结点和三结点构成的树 B树 B树的特点 从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束； 没有命中，则进入查询关键字所属范围的儿子结点进行查找； 重复以上步骤，直到所对应的儿子指针为空，或已经是叶子结点； 搜索性能等于在关键字全集中做二分查找。查找很不稳定，最好就是根节点，最坏就在叶子结点。 B+树B+树，是B树的一种变体，也是一种多路搜索树。他们差别是： B+树中所有的数据都会放在叶子结点，而不会放在非叶子结点 B+树的特点 B+树 跟 B树 搜索基本相同，区别是 B+树 只有达到叶子结点才会命中，搜索性能等于在关键字全集中做二分查找。 所有的 关键字都出现在叶子结点的链表中，（即关键字只能在叶子结点【稠密索引】），且链表中的关键字恰好是有序的。 非叶子结点相当于是叶子结点的索引【稀疏索引】，叶子结点相当于是存储（关键字）的箱子。 适合做文件索引系统，数据库索引系统。 为什么说 B+树 比 B 树 更适合实际应用中操作系统的文件索引和数据库索引？1、B+树的磁盘读写代价更低B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更 小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 而B+树非叶子节点没有Data数据，所以同样大小的磁盘页可以容纳更多的节点元素。所以数据量相同的情况下，B+树比B树更加“矮胖“，因此使用的IO查询次数更少。 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。 2、B+树的的查询效率更加稳定由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 而B树的查找并不稳定（最好的情况是查询根节点，最坏查询叶子节点）。而B树每一次查找都是稳定的。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"队列","slug":"数据结构/队列","date":"2019-11-26T16:00:00.000Z","updated":"2020-01-01T02:52:22.153Z","comments":true,"path":"2019/11/27/数据结构/队列/","link":"","permalink":"http://yoursite.com/2019/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/","excerpt":"","text":"队列queue是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。是一种先进先出的线性表，简称FIFO。允许插入的叫队尾，允许删除的一端称为队头。 键盘输入到屏幕输出用的就是队列。 循环队列当队列是顺序结构时，假设这个队列能放n个元素，那么它的长度必须是大于n的，并且要把队列的所有元素存储在数组的前n个单元，数组下标为0的一端就是队头。入队，就是在队尾加入一个元素，不用移动任何元素。出队，需要将除第一个元素的所有元素前移。所以入队的时间复杂度为o(1)，出队是o(n)。 如果我们不去限制队列的元素必须放在数组的前n个单元，出队的下标就不需要一定在下标为0的位置。 我们把队列这种头尾相接的顺序存储结构称为循环队列。 如何判断是否为空或者满呢？ 设置一个标识flag，当front==rear，且flag=0时为队列空；当front==rear，且flag=1时为队列满 当队列空时，条件就是front==rear。当队列满，数组中会有一个空闲位置，不让rear==front。 循环队列入队操作(顺序结构)1234567891011Status EnQueue(SqQueue *Q,QElemType e)&#123; //判断队列是否满 if((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front) return ERROR; //将元素e赋值给队尾，数组 Q-&gt;data[Q-&gt;rear]=e; //rear指针后移 Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE; return OK;&#125; 循环队列出队操作(顺序结构)1234567891011Status DeQueue(SqQueue *Q,QElemType *e)&#123; //队列为空的判断 if(Q-&gt;front == Q-&gt;rear) return ERROR; //取出要删除的数据 *e=Q-&gt;data[Q-&gt;front]; //队头后移 Q-&gt;front=(Q-&gt;front+1)%MAXSIZE; return OK;&#125; 入队(链式结构)将队头指针指向链对列的头结点，而队尾指针指向终端结点 1234567891011121314Status EnQueue(LinkQueue *Q,QElemType e)&#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); if(!s) exit(OVERFLOW); //对入队结点赋值 s-&gt;data=e; s-&gt;next=NULL; //将结点加入队列 Q-&gt;rear-&gt;next=s; //移动队尾指针 Q-&gt;rear=s; return OK;&#125; 出队(链式结构)出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点。如果链表除了头结点外只有一个元素，则需要将rear指向头结点。 12345678910111213141516Status DeQueue(LinkQueue *Q,QElemType *e)&#123; //新结点来保存信息 QueuePtr p; if(Q-&gt;front == Q-&gt;rear) return ERROR; //头结点的后继(被删除的结点)信息保存在p结点中 p=Q-&gt;front-&gt;next; *e=p-&gt;data; Q-&gt;front-&gt;next=p-&gt;next; //如果删除的结点是唯一结点 if(Q-&gt;rear==p) q-&gt;rear=Q-&gt;front; free(p); return OK;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"栈","slug":"数据结构/栈","date":"2019-11-25T16:00:00.000Z","updated":"2020-01-01T02:52:15.320Z","comments":true,"path":"2019/11/26/数据结构/栈/","link":"","permalink":"http://yoursite.com/2019/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/","excerpt":"","text":"栈栈是限定仅在表尾进行插入和删除操作的线性表。队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表。 栈的操作顺序类似idea等软件的撤销按钮，后来的先返回。把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom）。栈是后进先出，LAST IN FIRST OUT，叫LIFO结构。 栈的顺序存储结构可以把栈想成线性表顺序存储结构的简化，简称顺序栈。把栈顶看成游标卡尺的游标，栈底固定位置，栈顶来回移动。 也可以看成子弹上膛。 两栈共享空间栈的存库空间必须事先定好，所以一般都会设计出合适的大小数组来处理。但是对于两个同类型的栈，我们可以做到最大限度利用他们的存储空间。 让第一个满了的栈的栈顶接上另一个未满栈的栈顶。使用这样的数据结构，通常是两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。如果不是两个具有相同数据类型的栈的，使用这个办法反而会使问题变复杂。 栈的的链式存储结构简称链栈。栈顶放在链表的头部，头指针和栈顶指针合二为一。对于链栈来说，基本不存在栈满的情况。 入栈操作： 123456789101112Status Push(LinkStack *S,SElemType e) &#123;//先创建一个需要插入的结点 LinkStackPtr s = (LinkStackPtr)malloc(sizeOf(StackNode)); //对s结点进行赋值和指向操作 s-&gt;data=e; //因为栈中的元素是从栈顶往栈底传递的，栈顶元素保存的下一结点的地址就是它下面一位元素 s-&gt;next=S-&gt;top; //对栈操作 S-&gt;top=s; S-&gt;count++; return ok;&#125; 出栈操作： 123456789101112131415Status Pop(LinkStack *S,SElemType *e)&#123; LinkStackPtr p; if(StackEmpty(*S)) return ERROR; //拿到栈顶的数据 *e=S-&gt;top-&gt;data; p=S-&gt;top; //将栈顶指针下移 S-&gt;top=S-&gt;top-&gt;next; //释放删除的结点 free(p); S-&gt;count--; return OK;&#125; 顺序栈和链栈的区别它们的时间复杂度是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定长度，可能会存在内存空间浪费问题，但是它存取时定位很方便，而链栈则要求每个元素都有指针域，这同时增加了内存开销，但对于栈的长度无限制。如果栈使用过程中元素变化不可预料，有时很小，有时非常大，那么最好用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。 栈的作用为何我们不用数组或者链表直接实现功能？因为栈的引入简化了程序设计的问题，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组，会需要分散精力去考虑数组的下标增减等细节问题，反而有掩盖了问题的本质。 栈的应用-递归关键词：斐波那契数列(Fibonacci) 迭代 递归 现在假设有一个数学函数： 打印前40位的斐波那契数列数，使用迭代，代码如下： 123456789101112131415int main()&#123; int i; int a[40]; a[0]=0; a[1]=1; printf(\"%d\",a[0]); printf(\"%d\",a[1]); for(i=2;i&lt;40;i++) &#123; a[i]=a[i-1]+a[i-2]; printf(\"%d\",a[i]); &#125; return 0;&#125; 使用迭代代码简单，容易理解，但是过于冗长。 使用递归： 123456789101112131415int Fbi(int i)&#123; if(i&lt;2) return i== 0?0:1; return Fbi(i-1)+Fbi(i-2);&#125;int main()&#123; int i; for(int i=0;i&lt;40;i++) &#123; printf(\"%d\",Fbi(i)); &#125; return 0;&#125; 递归是自己调用自己，我们可以把它看做是调用另一个函数；只不过，这个函数和自己长得一样。 每个递归定义必须至少有一个条件，满足时递归不在进行，即不再引用自身而是返回值退出。避免陷入永不结束的无穷递归中。 递归和迭代的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰，更简洁，更容易让人理解，从而减少读懂代码的时间。但大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代不需要反复调用函数和占用额外的内存。 这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合这样的数据结构，因此，编译器使用栈实现递归。 后缀表达式这是波兰逻辑学家提出的，它将传统的四则运算表达式，改造成去掉括号，运算符在运算数字之后出现的形式。 例如：9+(3-1)*3+10/2改造为9 3 1 - 3 * + 10 2 / + 如何看这个改造结果呢？理解起来就是：从左到右写数字，原则是运算符在计算的两个数字之后，但是要考虑括号和乘除优先写运算符。所以看成三块9 |+| (3-1)*3 |+| 10/2每一块又按这个原则来分。 9 3 1 - 3 * + 10 2 / +这个表达式计算机如何处理呢？计算机的做法是遇到数字就入栈，遇到运算符就将栈顶的两个数出栈进行运算(注意顺序)，将运算结果再入栈，这样直到最后的运算符。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"线性表","slug":"数据结构/线性表","date":"2019-11-24T16:00:00.000Z","updated":"2020-01-01T04:35:13.646Z","comments":true,"path":"2019/11/25/数据结构/线性表/","link":"","permalink":"http://yoursite.com/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"概念筑基 数据 数据对象 有相同数量和类型数据项的数据元素的集合 数据元素 组成数据的基本单位 数据项 数据结构 包含相互关系数据元素的集合 逻辑结构与物理结构逻辑针对数据元素之间的关系，物理针对计算机存储单元之间的关系 逻辑关系：元素之间无关联、一对一、一对多、多对多；分别对应集合结构、线性结构、树形结构、图形结构。 物理结构：数据存储单元之间顺序存储、链式存储。 算法求解特定问题的求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 算法的特性： 输入 输出 有穷性 确定性 可行性 算法设计的特性： 正确性 可读性 健壮性 对输入不合法的情况做出合适的处理 时间效率高，存储量低‘ 算法效率的度量： 测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数。运行时间与这个计数成正比。 判断一个算法的效率，函数中常数和其他次要项常常可以忽略，更应该关注主项（最高阶项）的阶数。 推导时间复杂度的方法： 用常数1取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是1，则去除与整个项相乘的常数。 得到的结果就是大O阶 对于循环体来说，时间复杂度就是内循环的复杂度乘循环的次数。 线性表有顺序结构和链式结构。单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但是如果我们希望从第i个位置，插入10个元素，对于顺序存储结构意味着，每一次插入都要移动n-i个元素，每次都是O(n)。而单链表，我们只需要第一次找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针，事件复杂度为O(1)。显然，对于插入和删除数据越频繁的操作，单链表的效率优势就越明显。 单链表的整表创建1.头插法：让不断生成的结点始终位于第一的位置。新结点指向上一次的新结点，头指针指向新结点。 2.尾插法：把每次新结点都插在终端结点后面。上一次的新结点指向新结点。 单链表的整表删除链表中每个元素只有数据域和指向下一个元素的指针；要删除的话，只能从第一个开始删除，然后不断往后循环。 单链表结构与顺序存储结构优缺点时间性能上，单链表查找弱于顺序存储结构，插入和删除在多元素时优于顺序存储结构。空间性能上，顺序存储需要预先分配空间，这就直接导致会有浪费或者上溢。 例如：1.在游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况下都是读取，所以应该考虑使用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家游戏的过程中，可能随时增加或删除，此时再用顺序存储就太不合适了。2.当线性表中的元素个数变化较大或者根本不知道多大时，为了空间考虑还是使用单链表结构。如果事先知道线性表的大致长度，比如一年12个月，一周共7天，这种用顺序存储结构效率高很多。 静态链表当最初期的编程高级语言Basic、Fortran，由于没有指针，链表结构如何实现呢？和我在Java中定义链表差不多，我用一个包装类里面放数据和它指向的下个元素的地址。那这些没有指针的语言，它们可以使用数组来代替指针。首先是数组中的每个元素都是由两个数据域组成，data和cur；这个cur放的就是该元素的后继在数组中的下标。这种用数组描述的链表就是静态链表，还有叫游标实现法的。 光这样放元素还是不够完善，我们需要对数组第一个和最后一个元素作为特殊元素处理，不存数据。通常把未被使用数组元素（剩余空闲的数组元素连在一起的）称为备用链表。而数组第一个元素，下标为0的数组元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数组的元素的下标，相当于头结点。如下图：第一个节点中cur为7，庚元素的cur为0，数组的末尾的cur为1，这三个表示的意思，我们都应该要知道。7是备用链表的起始位置，0是表示当前数组元素为不为空的元素最后一个，1是表示数组中不为空的第一个位置的下标。7、0、1都是下标。 静态链表的插入与删除静态链表要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。 插入那么如何模拟结点创建呢？我们将数组中未被使用过的及已经被删除的分量用游标链成一个备用的链表，每当进行插入时，就从备用链表中取得一个结点作为待插入的新结点。 1234567891011121314/*备用链表非空，就返回要分配出去的结点的下标，否则返回0*/int Malloc_SLL(StaticLinkList space) &#123; //静态链表的第一个位置放的就是备用链表 //第一个元素的下标，现在我们先拿到 //备用链表的第一个元素 int i = space[0].cur; //如果能拿到备用链表的第一个结点，那就把它下一个 //结点作为新一个第一结点。因为需要人能顶起下次被取出的任务 if (space[0].cur) &#123; space[0].cur = space[i].cur; &#125; return i;&#125; 现在能从备用链表中拿到新的空间作为放新结点的位置了。那我们就来实现如何给静态链表插入一个元素。大致思路还是：先判断插入位置是否合理；再拿到插入位置的前一个结点，让它把它的后继结点的游标给我们新插入的结点来继承；然后新结点再作为前面结点的后继。很好理解，每个元素只有下一个元素的游标，我们要插入某个位置，那就要把这个位置的上游指向新结点且新结点指向上游的后继结点；那就先把上游的后继结点游标拿到，不然赋值就覆盖了。 12345678910111213141516171819Status ListInsert(StaticLinkList L,int i,ElemTyp e) &#123; //j用来接收分配位置,k用来接收静态链表的最后一位元素的下标， //位于该k位置元素的游标指向第一个放元素的下标；l用来计数。 int j,k,l; k = MAX_SIZE - 1; if (i&lt;1 ||i&gt;ListLength(L) +1) return ERROR; j = Malloc_SSL(L); /*获得空闲分量的下标*/ if (j) &#123; L[j].data = e; /*插入位置数据域赋值*/ for (l=1; l&lt;i; l++) &#123; /*l是相对于长度来说，l=1下面第一次循环就拿到开头元素的下标，那么他要循环到插入位置前一个元素，那对应的下标就是i-1，就循环i-1次*/ k = L[k].cur; &#125; L[j].cur = L[k].cur; L[k].cur = j; return OK; &#125; return ERROR;&#125; 这里面比较难理解的就是找到插入位置的前一个元素。一个循环，它的结束条件还是要看它循环体什么时候符合条件；符合条件了就要结束循环。 删除要删除i位置的结点，很简单，就是把i上游的游标不再指向i了，指向i的下游；然后将i位置结点释放。直接上代码： 1234567891011121314Status ListDelete(StaticLinkList L,int i) &#123; int j,k; if (i &lt;1 || i&gt;ListLength(L)) &#123; return ERROR; &#125; k = MAX_SIZE - 1; for (j = 1;j&lt;=i-1;j++) &#123; k = L[k].cur; &#125; j = L[k],cur; L[k].cur = L[j].cur; Free_SSL(L,j); return OK;&#125; 其中的Free_SSL(L,j)是释放元素： 123456/*将下标为k的空闲结点回收到备用链表*/void Free_SSL(StaticLinkList space,int k) &#123; /*用了头插法，把新产生的空闲结点放到备用链表第一个元素之前*/ space[k].cur = space[0].cur; space[0].cur = k;&#125; 为啥这里不用尾插法？理论上是可行，反正都是把空闲结点放进备用链表。不过尾插就得找到备用链表的最后一个结点，在静态链表中只能不断遍历才能拿到。这就过于麻烦了吧！静态链表有三个特殊位置，第一个是第一位指向了备用链表的位置，第二个是最后一位指向了有元素的第一个位置，第三个是备用链表的起始位置，它指向备用链表的后继。头插法是，我们只要把插入的结点指向之前的第一个结点就行；在静态链表中，除了要这样做之外，还要把第一个结点指向的位置换成新结点。 静态链表的优缺点优点是继承了单链表的优点，缺点是没有解决表长难确定的问题，失去了顺序存储结构随机存取的特性。静态链表理解它的思想就ok了。 循环链表第一个特点，从任一结点都能完整遍历链表。我们把单链表的尾结点的指针从空指针改为指向头结点。这样就把整个单链表形成一个环，这种头尾相连的单链表就是单循环链表。简称循环链表（circular linked list）。通常为了让空链表和非空链表处理一致，通常设置一个头结点。循环链表和单链表的主要差异就在于循环的判断条件，原来是判断p-&gt;next是否为空，现在是p-&gt;next不等于头结点，则循环未结束。循环链表就是为了解决从任一结点都能遍历链表，我们都知道链表的头和尾是两个特殊位置，如果我们想要不遍历整个链表就拿到头和尾，那该咋整呢？我们用一个尾指针来指向尾结点，不就解决了。 现在咋们有两个循环链表A和B，我们要让B接在A后面，如果只有头指针的情况下，怎么办？那就得遍历A，指导尾结点结束，然后让尾结点不再指向A的头结点；让它指向B的头结点，然后遍历B，让B的尾结点不指向B的头结点，去指向A的头结点。这里用到了两个遍历时间复杂度O(n)。如果现在有尾指针的情况下呢？A的尾指针去指向B的尾指针的next-&gt;next也就是B的头，让B的next指向A的尾指针的next-&gt;next也就是A的头。这里的时间复杂度是多少？也就两步吧？这不就很简单了。这就是尾指针的爽点。文字看起来不爽，来用代码表示一下： 1234p = rearA-&gt;next; /*拿到A的头结点*/rearA-&gt;next=rearB-&gt;next-&gt;next; /*A的尾结点指向B的头结点*/rearB-&gt;next=p; /*B的尾结点指向A的头结点*/free(p); 双向链表在一个循环链表的情况下，我们现在需要从尾结点开始，遍历整个链表，并且最后要回到头结点。遍历一次咋们还是在尾结点，还得多走一步才能回到头结点。现在我们整一个双向链表，啥是双向链表？先不管，反正能反着访问就行，那我们就可以从尾结点逆序访问到头结点，还不用多走一步。我们在单链表中，有了next指针，使得我们要查找下一结点的时间复杂度为O(1)。可是如果我们要找的是上一个结点，就得是O(n)了。因为我们每次都得从头开始查找。为了克服单向性这一个访问缺点，我们的科学家设计出了双向链表。double linked list是在单链表的每一个节点中，再设置一个指向其前驱结点的指针域。那么现在双向链表的每一个结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。 双向链表的插入与删除思路：在a1（p结点）与a2之间插入一个s结点，现在能知道的就是p结点和e结点。进行指针操作必须要注意p-&gt;next只能最后被赋值，因为它表示的就是a1与a2之间的联系，如果他改变了就表示联系断了。 1234567/*先给插入的s结点的两个指针域赋值，完成s结点的指向*/s-&gt;next = p-&gt;next; s-&gt;prior = p;/*对a2结点的priod指针（指向前一结点的指针域）赋值*/p-&gt;next-&gt;prior = s;/*对a1结点的next指针赋值*/p-&gt;next = s; 双向链表插入得修改三个结点，首先是插入结点的前后指针，再是插入位置的后一结点的前指针，最后是插入结点位置的前一结点的后指针。 删除：假如删除的就是p结点，它的前后结点的指针都与他无关了，之前和它有关的都得改变。 123p-&gt;next-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=p-&gt;next;free(p);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"职责链模式","slug":"JAVA/设计模式/职责链模式","date":"2019-10-01T16:00:00.000Z","updated":"2020-03-02T06:39:29.945Z","comments":true,"path":"2019/10/02/JAVA/设计模式/职责链模式/","link":"","permalink":"http://yoursite.com/2019/10/02/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"职责链模式 OA系统采购问题 处理人抽象类​ 里面包含了下一个处理人，拥有处理请求的方法，跟链表的形式有点像。 12345678910111213141516public abstract class Approver &#123; Approver approver; // 职责链，下一个处理者 String name; public Approver(String name) &#123; this.name = name; &#125; // 注入下一个处理者 public void setApprover(Approver approver) &#123; this.approver = approver; &#125; // 处理请求的方法 public abstract void processRequest(Request request);&#125; 学院​ 实际处理者，处理 5000 到 10000 金额的审批 1234567891011121314public class CollegeApprover extends Approver &#123; public CollegeApprover(String name) &#123; super(name); &#125; @Override public void processRequest(Request request) &#123; if (request.getPrice() &gt; 5000 &amp;&amp; request.getPrice() &lt;= 10000)&#123; System.out.println(\" 请求编号id =:\"+request.getType()+\"被\"+this.name+\"处理了!\"); &#125;else &#123; approver.processRequest(request); // 下一个处理人处理 &#125; &#125; 系​ 实际处理者，处理金额 &lt; 5000 12345678910111213141516public class DepartmentApprover extends Approver &#123; public DepartmentApprover(String name) &#123; super(name); &#125; @Override public void processRequest(Request request) &#123; if (request.getPrice() &lt;= 5000)&#123; System.out.println(\" 请求编号id =:\"+request.getType()+\"被\"+this.name+\"处理了!\"); &#125;else &#123; approver.processRequest(request); &#125; &#125;&#125; 请求类​ 发送的请求，在处理人中被处理的请求 1234567891011121314public class Request &#123; private int type = 0; // 请求类型 private float price = 0.0f; // 金额 private int id = 0; public Request(int type, float price, int id) &#123; this.type = type; this.price = price; this.id = id; &#125; // Setter Getter&#125; 客户端123456789101112131415public class Client &#123; public static void main(String[] args) &#123; Request request = new Request(1, 8000f, 1); // 8000元的请求 DepartmentApprover departmentApprover = new DepartmentApprover(\"系主任\"); CollegeApprover collegeApprover = new CollegeApprover(\"院长\"); // 链式处理,构成环形 departmentApprover.setApprover(collegeApprover); // 系 -&gt; 院 collegeApprover.setApprover(departmentApprover); // 院 -&gt; 系 // 由系去处理请求，不能处理则去找学院，同理不该学院处理，则去找系 departmentApprover.processRequest(request); &#125;&#125; 职责链模式在MVC框架中的运用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"策略模式","slug":"JAVA/设计模式/策略模式","date":"2019-09-30T16:00:00.000Z","updated":"2020-03-02T06:28:01.544Z","comments":true,"path":"2019/10/01/JAVA/设计模式/策略模式/","link":"","permalink":"http://yoursite.com/2019/10/01/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式​ 面向接口编程，把类的行为抽离出来。 策略模式在JDK源码中的运行","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"状态模式","slug":"JAVA/设计模式/状态模式","date":"2019-09-29T16:00:00.000Z","updated":"2020-03-02T06:21:32.492Z","comments":true,"path":"2019/09/30/JAVA/设计模式/状态模式/","link":"","permalink":"http://yoursite.com/2019/09/30/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"状态模式​ React里面三大对象，不同的状态，不同的展现形式。 APP 抽奖问题 状态模式实际运用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"解释器模式","slug":"JAVA/设计模式/解释器模式","date":"2019-09-28T16:00:00.000Z","updated":"2020-03-02T06:17:41.791Z","comments":true,"path":"2019/09/29/JAVA/设计模式/解释器模式/","link":"","permalink":"http://yoursite.com/2019/09/29/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"解释器模式 计算表达式的值​ 计算 a+b-c+d+e，使用解释器模式完成 解析器抽象类12345public abstract class Expression &#123; // HashMap 用来存每个表达式所对应的值 public abstract int interpreter(HashMap&lt;String, Integer&gt; var);&#125; 变量解析器1234567891011121314public class VarExpression extends Expression &#123; private String key; // a,b,c public VarExpression(String key) &#123; this.key = key; &#125; // 获取变量所对应的值 @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return var.get(this.key); &#125;&#125; 抽象符号解析器1234567891011121314151617public abstract class SymbolExpression extends Expression &#123; // 抽象的 符号解释器，每个符号只知道左右两个解析器 protected Expression left; // 左变量表达式 protected Expression right; // 右变量表达式 public SymbolExpression(Expression left, Expression right) &#123; this.left = left; this.right = right; &#125; // 让其具体计算子类来实现这个方法，本身不实现 @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return 0; &#125;&#125; 具体的加法与减法12345678910111213141516171819202122232425public class AddExpression extends SymbolExpression &#123; public AddExpression(Expression left, Expression right) &#123; super(left, right); &#125; // 处理相加 @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return super.left.interpreter(var) + super.right.interpreter(var); &#125;&#125;public class SubExpression extends SymbolExpression &#123; public SubExpression(Expression left, Expression right) &#123; super(left, right); &#125; // 处理相减 @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return super.left.interpreter(var) - super.right.interpreter(var); &#125;&#125; 计算器12345678910111213141516171819202122232425262728293031323334353637383940414243public class Calculator &#123; private Expression expression; public Calculator(String expression) &#123; // 类似 a+b-c // 安排运算先后顺序 Stack&lt;Expression&gt; stack = new Stack&lt;&gt;(); // 表达式拆接为单个字符 char[] chars = expression.toCharArray(); // [a,+,b,-,c] Expression left = null; Expression right = null; // 遍历表达式，放入栈中做处理 for (int i = 0; i &lt; chars.length; i++) &#123; switch (chars[i]) &#123; case '+': left = stack.pop(); // a right = new VarExpression(String.valueOf(chars[++i])); // b stack.push(new AddExpression(left, right)); // 传入加法表达式 break; case '-': left = stack.pop(); // a+b 的结果 sum right = new VarExpression(String.valueOf(chars[++i])); // c stack.push(new SubExpression(left, right)); // 传入减法表达式 sum - c break; default: stack.push(new VarExpression(String.valueOf(chars[i]))); break; &#125; &#125; // 当处理完运算表达式后，栈中应该只剩一个表达式了，应该是各个Expression组合的 this.expression = stack.pop(); &#125; // 算出最后的结果 public int run(HashMap&lt;String,Integer&gt; var )&#123; return this.expression.interpreter(var); &#125;&#125; 客户端123456789101112131415161718192021222324252627282930public class Client &#123; public static void main(String[] args) throws IOException &#123; String expression = getExpression(); // a+b-c HashMap&lt;String, Integer&gt; value = getValue(expression); // 获得表达式的值 Calculator calculator = new Calculator(expression); int run = calculator.run(value); System.out.println(\"run = \" + run); &#125; // 获取表达式 public static String getExpression() throws IOException &#123; System.out.println(\" 请输入表达式： \"); return (new BufferedReader(new InputStreamReader(System.in))).readLine(); &#125; // 获取表达式对应的值 public static HashMap&lt;String, Integer&gt; getValue(String expression) throws IOException &#123; HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(); for (char c : expression.toCharArray()) &#123; if (c != '+' &amp;&amp; c != '-') &#123; if (!hashMap.containsKey(String.valueOf(c))) &#123; System.out.println(\" 请输入\" + String.valueOf(c) + \"的值\"); String in = (new BufferedReader(new InputStreamReader(System.in))).readLine(); hashMap.put(String.valueOf(c),Integer.valueOf(in)); &#125; &#125; &#125; return hashMap; &#125;&#125; 解释器模式在Spring框架中的运用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"备忘录模式","slug":"JAVA/设计模式/备忘录模式","date":"2019-09-26T16:00:00.000Z","updated":"2020-03-01T15:11:11.904Z","comments":true,"path":"2019/09/27/JAVA/设计模式/备忘录模式/","link":"","permalink":"http://yoursite.com/2019/09/27/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"备忘录模式​ 游戏，或者别的程序中做备份的模式。 保存英雄攻击力问题​ 随着英雄挑战boos，把英雄每个状态下的攻击力保存下来。 被保存的对象12345678910111213141516public class Originator &#123; private String state; //状态信息，被保存的属性 // Getter Setter // 保存状态的方法，返回一个备忘录，把当前状态传给备忘录 public Memento seveState()&#123; return new Memento(state); &#125; // 从备忘录中恢复状态信息 public void getStateFromMemento(Memento memento)&#123; state = memento.getState(); &#125;&#125; 备忘录123456789101112public class Memento &#123; private String state; // 保存的状态 public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return this.state; &#125;&#125; 备忘录的集合123456789101112public class Caretaker &#123; // 在list集合中 有很多的备忘录对象 private List&lt;Memento&gt; mementoList = new ArrayList&lt;&gt;(); public void add(Memento memento)&#123; mementoList.add(memento); &#125; public Memento get(int index)&#123; return mementoList.get(index); &#125;&#125; 客户端1234567891011121314151617181920public class Client &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); // 将保存的对象 Caretaker caretaker = new Caretaker(); // 备忘录集合 originator.setState(\"100\"); caretaker.add(originator.seveState()); // 保存当前状态，加入备忘录 System.out.println(\"originator.状态1 = \" + originator.getState()); originator.setState(\"80\"); caretaker.add(originator.seveState()); // 保存当前状态，加入备忘录 System.out.println(\"originator.状态2 = \" + originator.getState()); originator.setState(\"50\"); caretaker.add(originator.seveState()); // 保存当前状态，加入备忘录 System.out.println(\"originator.状态3 = \" + originator.getState()); originator.getStateFromMemento(caretaker.get(0)); // 恢复到100的状态 System.out.println(\"originator.恢复后 = \" + originator.getState()); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"中介者模式","slug":"JAVA/设计模式/中介者模式","date":"2019-09-25T16:00:00.000Z","updated":"2020-03-01T14:10:54.371Z","comments":true,"path":"2019/09/26/JAVA/设计模式/中介者模式/","link":"","permalink":"http://yoursite.com/2019/09/26/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"中介者模式 聊天室问题我们通过聊天室实例来演示中介者模式。 实例中，多个用户可以向聊天室发送消息，聊天室显示用户消息。 我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 的方法来分享他们的消息。 创建中介类123456public class ChatRoom &#123; public static void showMessage(User user, String message)&#123; System.out.println(new Date().toString() + \" [\" + user.getName() +\"] : \" + message); &#125;&#125; 创建 user 类12345678910111213public class User &#123; private String name; // Getter Setter public User(String name)&#123; this.name = name; &#125; public void sendMessage(String message)&#123; ChatRoom.showMessage(this,message); &#125;&#125; 客户端123456789public class Test &#123; public static void main(String[] args) &#123; User robert = new User(\"Robert\"); User john = new User(\"John\"); robert.sendMessage(\"Hi! John!\"); john.sendMessage(\"Hello! Robert!\"); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"观察者模式","slug":"JAVA/设计模式/观察者模式","date":"2019-09-24T16:00:00.000Z","updated":"2020-03-01T03:06:51.532Z","comments":true,"path":"2019/09/25/JAVA/设计模式/观察者模式/","link":"","permalink":"http://yoursite.com/2019/09/25/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式 天气预报问题 Subject 接口1234567public interface Subject &#123; // 被观察的类需要实现的接口 public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers();&#125; Observer 接口123456// 观察者接口public interface Observer &#123; // 核心方法，修改天气的方法 public void update(float temperature, float pressure, float humidity);&#125; 实现了 Subject 接口的气象站12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 被观察的气象站public class WeatherData implements Subject&#123; private float temperature; // 温度 private float pressure; // 压力 private float humidity; // 湿度 // 维护了观察者集合，可以做 Subject 类里面的三个操作 private List&lt;Observer&gt; observerList; public WeatherData() &#123; this.observerList = new ArrayList&lt;&gt;(); // 构造方法初始化集合 &#125; // Getter Setter public void dataChange() &#123; notifyObservers(); // 调用 唤醒所有观察者方法 &#125; // 改变天气数据 public void setData(float temperature, float pressure, float humidity) &#123; this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; dataChange(); &#125; @Override public void registerObserver(Observer o) &#123; observerList.add(o); // 添加观察者 &#125; @Override public void removeObserver(Observer o) &#123; if (observerList.contains(o))&#123; observerList.remove(o); // 删除观察者 &#125; &#125; // 遍历每一个在集合中的观察者，并调用各自的 update() 方法 @Override public void notifyObservers() &#123; observerList.forEach( observer -&gt; observer.update(this.temperature, this.pressure, this.humidity)); &#125;&#125; 具体的观察者1234567891011121314151617181920public class CurrentConditions implements Observer &#123; private float temperature; // 温度 private float pressure; // 压力 private float humidity; // 湿度 public void update(float temperature, float pressure, float humidity) &#123; this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); &#125; // 每个观察者不同的处理逻辑，这里是直接打印 public void display() &#123; System.out.println(\" == Today temperature is :\" + temperature); System.out.println(\" == Today pressure is :\" + pressure); System.out.println(\" == Today humidity is :\" + humidity); &#125;&#125; 客户端调用12345678910public class Clent &#123; public static void main(String[] args) &#123; // 创建被观察者 WeatherData weatherData = new WeatherData(); // 添加 观察者，放在被观察者里面的集合中 weatherData.registerObserver(new CurrentConditions()); weatherData.setData(12f, 10f, 30f); &#125;&#125; 观察者模式在JDK源码中的运用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"迭代者模式","slug":"JAVA/设计模式/迭代者模式","date":"2019-09-23T16:00:00.000Z","updated":"2020-02-29T09:11:50.930Z","comments":true,"path":"2019/09/24/JAVA/设计模式/迭代者模式/","link":"","permalink":"http://yoursite.com/2019/09/24/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"迭代者模式 大学的问题，不同的结构，有不同的访问方式 创建系123456789101112public class Department &#123; private String name; // 系的名字 private String des; // 系的描述 public Department(String name, String des) &#123; this.name = name; this.des = des; &#125; // getter setter toString&#125; 学院接口拥有一个返回 Iterator 的方法，每个学院中保存院系的方式不一致，所以需要自己重写 123456public interface College &#123; public String getName(); // 学院的名字 public void addDepartment(String name,String Description); // 添加系 public Iterator createIterator(); // 返回一个迭代器的方法&#125; 计算机学院与信息学院123456789101112131415161718192021222324252627282930// 计算机学院public class Computer implements College &#123; private Department[] departments; // 用数组存这个学院下的系别 private int numOfDepartment = 0; // 保存当前这个数组的下标 public Computer() &#123; this.departments = new Department[5]; addDepartment(\" 计算机科学与技术 \",\" 计算机科学与技术 \"); addDepartment(\" 软件工程 \",\" 软件工程 \"); addDepartment(\" 物联网 \",\" 物联网 \"); &#125; @Override public String getName() &#123; return \"计算机学院\"; &#125; @Override public void addDepartment(String name, String description) &#123; Department department = new Department(name, description); departments[numOfDepartment] = department; numOfDepartment++; &#125; @Override public Iterator createIterator() &#123; // 返回数组方式的迭代器，把数据传过去 return new ComputerCollegeIterator(departments); &#125;&#125; 12345678910111213141516171819202122232425262728// 信息学院public class Info implements College &#123; private List&lt;Department&gt; departmentList; // 用集合存系 public Info() &#123; departmentList = new ArrayList&lt;&gt;(); addDepartment(\" 信息安全 \",\" 信息安全 \"); addDepartment(\" 通信 \",\" 通信 \"); addDepartment(\" 5G \",\" 5G \"); &#125; @Override public String getName() &#123; return \"信息工程学院\"; &#125; @Override public void addDepartment(String name, String description) &#123; Department department = new Department(name, description); departmentList.add(department); &#125; @Override public Iterator createIterator() &#123; // 返回集合方式的迭代器，把数据传过去 return new InfoCollegeIterator(departmentList); &#125;&#125; 两个不同的 Iterator 实现类​ 分别对 数组 与 列表 的迭代，对数据的真实操作。 1234567891011121314151617181920212223242526// 计算机学院 数组迭代器public class ComputerCollegeIterator implements Iterator &#123; private Department[] departments; // 数组 private int position = 0; // 遍历开始的位置 public ComputerCollegeIterator(Department[] departments) &#123; this.departments = departments; &#125; @Override public boolean hasNext() &#123; if(position &gt; departments.length - 1 || departments[position] == null)&#123; return false; &#125;else &#123; return true; &#125; &#125; @Override public Object next() &#123; Department department = departments[position]; position++; return department; &#125;&#125; 12345678910111213141516171819202122232425// 信息学院 list集合迭代器public class InfoCollegeIterator implements Iterator &#123; private List&lt;Department&gt; departmentList; // 集合 int index = -1; // 索引 public InfoCollegeIterator(List&lt;Department&gt; departmentList) &#123; this.departmentList = departmentList; &#125; @Override public boolean hasNext() &#123; if ( index &gt;= departmentList.size() -1)&#123; return false; &#125;else &#123; index++; return true; &#125; &#125; @Override public Object next() &#123; return departmentList.get(index); &#125;&#125; 工具类1234567891011121314151617181920212223242526272829public class OutPut &#123; private List&lt;College&gt; collegeList; // 持有一个学院集合 public OutPut(List&lt;College&gt; collegeList) &#123; this.collegeList = collegeList; &#125; // 学院输出系，各种学院不同的迭代方式自己定，如数组或集合 public void printDepartment(Iterator iterator)&#123; while (iterator.hasNext())&#123; Department next = (Department)iterator.next(); System.out.println(next.getName()); &#125; &#125; // 遍历所有的学院，在调用学院输出系的方法 public void printCollege()&#123; Iterator&lt;College&gt; iterator = collegeList.iterator(); while (iterator.hasNext())&#123; College next = iterator.next(); System.out.println(\" ===\"+ next.getName()+\"== \"); // 不同的学院返回不同的默认数据与迭代器 Iterator iterator1 = next.createIterator(); printDepartment(iterator1); &#125; &#125;&#125; 客户端调用1234567891011121314public class Client &#123; public static void main(String[] args) &#123; List&lt;College&gt; colleges = new ArrayList&lt;&gt;(); colleges.add(new Computer()); // 添加计算机学院 colleges.add(new Info()); // 添加信息学院 OutPut outPut = new OutPut(colleges); outPut.printCollege(); // 输出方法 &#125;&#125; 迭代器模式在jdk源码中的使用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"命令模式","slug":"JAVA/设计模式/命令模式","date":"2019-09-22T16:00:00.000Z","updated":"2020-02-29T07:12:58.834Z","comments":true,"path":"2019/09/23/JAVA/设计模式/命令模式/","link":"","permalink":"http://yoursite.com/2019/09/23/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"命令模式 智能家电问题买了一堆智能家电，现在用命令模式实现对他们的操作，完成一个复杂的任务。 命令接口123456public interface Command &#123; public void execute(); // 执行 public void undo(); // 不执行&#125; 智能电灯，具体的执行者拥有高内聚特性，所有电灯的操作都在这里封装。具体的操作方 12345678910public class LightExecute &#123; public void on ()&#123; System.out.println(\" 电灯打开了 \"); &#125; public void off ()&#123; System.out.println(\" 电灯关闭了 \"); &#125;&#125; 电灯操作的三个命令123456789101112131415161718public class LightOffCommand implements Command &#123; private LightExecute lightExecute; // 聚合电灯操作者 public LightOffCommand(LightExecute lightExecute) &#123; this.lightExecute = lightExecute; &#125; @Override public void execute() &#123; lightExecute.off(); &#125; @Override public void undo() &#123; lightExecute.on(); &#125;&#125; 12345678910111213141516171819public class LightOnCommand implements Command &#123; private LightExecute lightExecute; // 聚合电灯操作者 public LightOnCommand(LightExecute lightExecute) &#123; this.lightExecute = lightExecute; &#125; @Override public void execute() &#123; lightExecute.on(); &#125; @Override public void undo() &#123; lightExecute.off(); &#125;&#125; 空按钮，没有具体的功能，避免了判空的问题 123456789101112public class NoCommand implements Command &#123; // 空按钮，用于初始化，避免了判空问题 @Override public void execute() &#123; &#125; @Override public void undo() &#123; &#125;&#125; 遥控器面板123456789101112131415161718192021222324252627282930313233343536373839404142434445public class RemoteController &#123; private Command[] onCommands; // 开按钮组 private Command[] offCommands; // 关按钮组 private Command undoCommand; // 撤销按钮 public RemoteController() &#123; onCommands = new Command[5]; offCommands = new Command[5]; // 用空按钮初始化遥控器 for (int i = 0; i &lt; 5; i++) &#123; onCommands[i] = new NoCommand(); offCommands[i] = new NoCommand(); &#125; &#125; // 给按钮设置具体的操作 public void setCommands(int no,Command onCommand,Command offCommand)&#123; onCommands[no] = onCommand; offCommands[no] = offCommand; &#125; // 按下开按钮 public void onButtonWasPushed(int no)&#123; // 找到你按下的开按钮，并调用其执行者的对应方法 onCommands[no].execute(); // 记录这次的操作，用于撤销 undoCommand = onCommands[no]; &#125; // 按下关按钮 public void offButtonWasPushed(int no)&#123; // 找到你按下的开按钮，并调用其执行者的对应方法 offCommands[no].execute(); // 记录这次的操作，用于撤销 undoCommand = offCommands[no]; &#125; // 按下撤销按钮 public void undoButtonWasPushed()&#123; // 找到你按下的开按钮，并调用其执行者的对应方法 undoCommand.undo(); &#125;&#125; 客户端调用，使用遥控器12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; LightExecute lightExecute = new LightExecute(); // 初始化电灯执行者 LightOnCommand lightOnCommand = new LightOnCommand(lightExecute); // 电灯开命令 LightOffCommand lightOffCommand = new LightOffCommand(lightExecute); // 电灯关命令 RemoteController remoteController = new RemoteController(); // 初始化遥控器 remoteController.setCommands(0,lightOnCommand,lightOffCommand); // 给遥控器按钮添加操作 remoteController.onButtonWasPushed(0); // 开电灯 remoteController.offButtonWasPushed(0); // 关电灯 remoteController.undoButtonWasPushed(); // 撤销按钮 &#125;&#125; 命令模式在Spring框架中的使用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"模板方法模式","slug":"JAVA/设计模式/模板方法模式","date":"2019-09-21T16:00:00.000Z","updated":"2020-02-29T03:31:00.498Z","comments":true,"path":"2019/09/22/JAVA/设计模式/模板方法模式/","link":"","permalink":"http://yoursite.com/2019/09/22/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板方法模式​ 模板方法模式强调流程相对固定，可变部分很少的问题。 ​ 可以使用钩子方法，看是否需要添加自定义的方法。 做饭问题​ 买菜、做米饭、炒菜，一般都是这三个步骤，不同的菜做法大致相同。 ​ 所以使用模板方法模式来解决这个问题。 做饭的抽象类​ 把大体的骨架都定了下来，具体不同的由子类去具体实现，addCondition（） 123456789101112131415161718192021222324252627public abstract class Cooking &#123; public final void make()&#123; buy(); rice(); addCondition(); cooking(); &#125; // 买菜 public void buy()&#123; System.out.println(\"去菜市场买菜\"); &#125; // 每个菜自己特有的 public abstract void addCondition(); // 做米饭 public void rice()&#123; System.out.println(\"做米饭\"); &#125; // 炒菜 public void cooking()&#123; System.out.println(\"炒菜，准备吃饭了！\"); &#125;&#125; 回锅肉 与 青椒肉丝123456789101112131415public class A extends Cooking &#123; @Override public void addCondition() &#123; System.out.println(\"回锅肉\"); &#125;&#125;public class B extends Cooking &#123; @Override public void addCondition() &#123; System.out.println(\"青椒肉丝\"); &#125;&#125; 客户端调用123456789101112public class Client &#123; public static void main(String[] args) &#123; // 回锅肉 Cooking a = new A(); a.make(); System.out.println(\"------------------------------------\"); // 青椒肉丝 Cooking b = new B(); b.make(); &#125;&#125; 钩子方法 ​ 没有配菜，就是炒菜，提供一个Boolean的方法，为真就是做具体的菜，假都是炒菜 修改后的抽象类1234567891011121314151617181920212223242526272829303132333435public abstract class Cooking &#123; public final void make()&#123; buy(); rice(); // 只有当钩子方法为 true 时，才会执行 if(isTure())&#123; addCondition(); &#125; cooking(); &#125; // 买菜 public void buy()&#123; System.out.println(\"去菜市场买菜\"); &#125; // 每个菜自己特有的 public abstract void addCondition(); // 做米饭 public void rice()&#123; System.out.println(\"做米饭\"); &#125; // 炒菜 public void cooking()&#123; System.out.println(\"炒菜，准备吃饭了！\"); &#125; // 钩子方法，相当于一个标记，为 ture 才会添加独有的步骤，即是 addCondition（） 方法 boolean isTure()&#123; return true; &#125;&#125; 水煮肉片12345678910111213public class C extends Cooking &#123; @Override public void addCondition() &#123; System.out.println(\"水煮肉片\"); System.out.println(\"我不会被执行\"); &#125; @Override boolean isTure() &#123; return false; &#125;&#125; 客户端12345678910111213public class Client &#123; public static void main(String[] args) &#123; Cooking a = new A(); a.make(); System.out.println(\"------------------------------------\"); Cooking b = new B(); b.make(); System.out.println(\"------------------------------------\"); Cooking c = new C(); c.make(); &#125;&#125; 模板模式在Spring框架中源码分析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理模式","slug":"JAVA/设计模式/代理模式","date":"2019-09-20T16:00:00.000Z","updated":"2020-02-08T04:26:58.151Z","comments":true,"path":"2019/09/21/JAVA/设计模式/代理模式/","link":"","permalink":"http://yoursite.com/2019/09/21/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"代理模式 静态代理代理对象与被代理对象，实现同一个接口 创建一个老师的接口123public interface ITeach &#123; public void teach(); // 教书的方法&#125; 创建语文老师123456public class Teacher implements ITeach &#123; @Override public void teach() &#123; System.out.println(\"我是语文老师，教语文\"); &#125;&#125; 创建语文老师的代理对象​ 与被代理类，实现同一个接口 1234567891011121314public class TeachProxy implements ITeach &#123; private ITeach teacher; // 代理对象，这里通过接口来组合 public TeachProxy(Teacher teacher) &#123; this.teacher = teacher; &#125; @Override public void teach() &#123; teacher.teach(); System.out.println(\"静态代理，实现(继承) 同一个接口(父类)，聚合这个接口(父类)\"); &#125;&#125; 客户端123456public class Client &#123; public static void main(String[] args) &#123; TeachProxy teachProxy = new TeachProxy(new Teacher()); teachProxy.teach(); &#125;&#125; 动态代理 动态代理工厂1234567891011121314151617181920212223242526272829public class ProxyFactory &#123; // 维护被代理对象，使用最终父类 Object private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; // 生成代理对象的方法 public Object getProxyInstance()&#123; // 参数说明 // 1、loader 被代理对象使用的类加载器，获取加载器的方法是固定的 // 2、interface 被代理对象实现的接口类型，使用泛型的方式确认类型 // 3、h 额外的功能，执行被代理目标的方法时，会自动触发，添加的额外功能 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"动态代理开始\"); // 反射机制调用被代理对象的方法,返回调用结果 Object invoke = method.invoke(target, args); System.out.println(\"动态代理结束\"); return invoke; &#125; &#125;); &#125;&#125; Cglib代理 创建被代理的类12345678910public class Dog&#123; final public void run(String name) &#123; System.out.println(\"狗\"+name+\"----run\"); &#125; public void eat() &#123; System.out.println(\"狗----eat\"); &#125;&#125; 方法拦截器，实现 MethodInterceptor1234567891011public class MyMethodInterceptor implements MethodInterceptor&#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(\"Cglib代理开始\"); // 注意这里的方法调用，不是用反射哦！！！ Object object = .invokeSuper(obj, args); System.out.println(\"Cglib代理结束\"); return object; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"享元模式","slug":"JAVA/设计模式/享元模式","date":"2019-09-19T16:00:00.000Z","updated":"2020-02-08T03:46:49.099Z","comments":true,"path":"2019/09/20/JAVA/设计模式/享元模式/","link":"","permalink":"http://yoursite.com/2019/09/20/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"享元模式​ 说到享元模式，第一个想到的应该就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，所以说享元模式是池技术的重要实现方式。 ​ 比如我们每次创建字符串对象时，都需要创建一个新的字符串对象的话，内存开销会很大，所以如果第一次创建了字符串对象 “adam“，下次再创建相同的字符串 ”adam“ 时，只是把它的引用指向”adam“，这样就实现了 ”adam“ 字符串在内存中的共享。 ​ 主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 ​ 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。 网站项目问题 抽象类1234public abstract class WebSite &#123; // 用户使用网站 public abstract void use(User user);&#125; 具体的网站类1234567891011121314public class ConcreteWebSite extends WebSite &#123; public ConcreteWebSite(String type) &#123; this.type = type; //网站的类型 &#125; // 可以多个用户共享的内部状态 private String type = \"\"; // 网站的类型,网站自己的属性 @Override public void use(User user) &#123; System.out.println(user.getName()+\" :使用网站的类型是 \"+ type); &#125;&#125; 网站工厂类里面维护了一个网站池，享元模式最主要就是被用到了池技术中 12345678910111213public class WebSiteFactory &#123; // 网站池 private Map&lt;String,WebSite&gt; pool = new HashMap&lt;&gt;(); // 根据类型，返回网站,没有就创建一个网站，加入到池中返回 public WebSite getWebSite(String type)&#123; if ( !pool.containsKey(type))&#123; pool.put(type,new ConcreteWebSite(type)); &#125; return pool.get(type); &#125;&#125; 用户类1234567public class User &#123; private String name; public User(String name) &#123; this.name = name; &#125;&#125; 客户端1234567891011public class Client &#123; public static void main(String[] args) &#123; WebSiteFactory webSiteFactory = new WebSiteFactory(); WebSite webSite1 = webSiteFactory.getWebSite(\"微博\"); webSite1.use(new User(\"张三\")); WebSite webSite2 = webSiteFactory.getWebSite(\"博客\"); webSite2.use(new User(\"李四\")); &#125;&#125; 享元模式在Integer中的运用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"外观模式","slug":"JAVA/设计模式/外观模式","date":"2019-09-18T16:00:00.000Z","updated":"2020-02-08T03:17:50.226Z","comments":true,"path":"2019/09/19/JAVA/设计模式/外观模式/","link":"","permalink":"http://yoursite.com/2019/09/19/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"外观模式 投资案例​ 投资者自己买股票时，由于众多投资者对众多股票的联系太多，反而不利于操作，这在软件中就成为耦合性太高，而有了基金后，就变成众多用户只和基金打交道，关心基金的上涨和下跌，而实际上的操作确是基金经理人与股票和其它投资产品打交道，这就是外观模式。 ​ 通过一个代理人类的操作，代理人组合一些具有具体功能的类，解耦 创建2个子系统角色​ 两个子系统类分别实现了不同的逻辑 12345678910111213public class SubSystemA &#123; public void dosomethingA() &#123; System.out.println(\"子系统方法A\"); &#125;&#125;public class SubSystemB &#123; public void dosomethingB() &#123; System.out.println(\"子系统方法B\"); &#125;&#125; 创建 facade 类1234567891011121314151617181920public class Facade &#123; // 组合了 子系统A 与 子系统B private SubSystemA subSystemA; private SubSystemB subSystemB; public Facade() &#123; this.subSystemA = new SubSystemA(); this.subSystemB = new SubSystemB(); &#125; // 对外暴露的方法 public void callA()&#123; this.subSystemA.dosomethingA(); &#125; public void callB()&#123; this.subSystemB.dosomethingB(); &#125;&#125; 客户端1234567public class Client &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); facade.callA(); // 代理人类间接调用子系统A facade.callB(); // 代理人类间接调用子系统B &#125;&#125; 外观模式在 Mybatis 源码的运用 总结​ 有点像是 controller 调用 service，service 调用 dao，在我们平常写的代码中经常用到外观模式！！！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"组合模式","slug":"JAVA/设计模式/组合模式","date":"2019-09-17T16:00:00.000Z","updated":"2020-02-07T13:59:15.269Z","comments":true,"path":"2019/09/18/JAVA/设计模式/组合模式/","link":"","permalink":"http://yoursite.com/2019/09/18/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"组合模式​ 组合模式解决这样的问题： ​ 当我们要处理的对象可以生成一颗树形结构，而我们要对树上的结点和叶子进行操作时，它能够提供一致的方式，而不用考虑它是结点还是叶子。 ​ 这个系统中所有对象都具有相同的方法。他们都继承共同的抽象类。 大学，学院，系的问题​ 输出大学下面的学院，学院下面的系 公共的抽象方法类123456789101112131415161718192021222324public abstract class Organization &#123; public Organization(String name, String description) &#123; this.name = name; this.description = description; &#125; private String name; // 名字 private String description; // 描述 // Setter Getter // 默认空实现两个方法，叶子结点不需要 add remove public void add(Organization organization)&#123; &#125; public void remove(Organization organization)&#123; &#125; // 输出方法 public abstract void print();&#125; 大学1234567891011121314151617181920212223242526// 大学 -&gt; 管理学院public class University extends Organization&#123; List&lt;Organization&gt; college = new ArrayList&lt;&gt;(); // 被管理学院的集合 public University(String name, String description) &#123; super(name, description); &#125; @Override public void add(Organization organization) &#123; college.add(organization); &#125; @Override public void remove(Organization organization) &#123; college.remove(organization); &#125; @Override public void print() &#123; System.out.println(super.getName()); college.stream().forEach(Organization::print); // 调用每一个学院的输出 &#125;&#125; 学院123456789101112131415161718192021222324// 学院 -&gt; 管理系public class College extends Organization &#123; List&lt;Organization&gt; department = new ArrayList&lt;&gt;(); // 被管理系的集合 public College(String name, String description) &#123; super(name, description); &#125; @Override public void add(Organization organization) &#123; department.add(organization); &#125; @Override public void remove(Organization organization) &#123; department.remove(organization); &#125; @Override public void print() &#123; System.out.println(super.getName()); department.stream().forEach(Organization::print); // 调用每一个系的输出 &#125;&#125; 系1234567891011121314 // 树形结构的最下面一层，只需要做展示就okpublic class Department extends Organization &#123; public Department(String name, String description) &#123; super(name, description); &#125; // 不再重写 add 与 remove 方法了，因为它是叶子结点 @Override public void print() &#123; System.out.println(super.getName()); &#125;&#125; 客户端12345678910111213141516171819202122232425public class Client &#123; public static void main(String[] args) &#123; Organization university = new University(\"清华大学\",\"top1\"); // 大学 Organization college1 = new College(\"计算机学院\",\"计算机学院\"); // 学院 Organization college2 = new College(\"文学院\",\"文学院\"); // 学院 Department department1 = new Department(\"C++\",\"C++\"); Department department2 = new Department(\"JAVA\",\"JAVA\"); Department department3 = new Department(\"JS\",\"JS\"); Department department4 = new Department(\"语言文学\",\"语言文学\"); university.add(college1); university.add(college2); college1.add(department1); college1.add(department2); college1.add(department3); college2.add(department4); university.print(); // 打印大学的组成结构 &#125;&#125; 组合模式 在 HashMap 中的运用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰者模式","slug":"JAVA/设计模式/装饰者模式","date":"2019-09-16T16:00:00.000Z","updated":"2020-02-07T03:25:36.464Z","comments":true,"path":"2019/09/17/JAVA/设计模式/装饰者模式/","link":"","permalink":"http://yoursite.com/2019/09/17/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"装饰者模式​ 在不改变原有对象的基础之上，将功能附加到对象上。提供了比继承更有弹性的替代方案（扩展原有对象功能）。 装饰者与被装饰者继承同一个类，装饰者里面维护了一个被装饰的类，通过递归的方式依次添加新的功能。 咖啡问题​ 星巴克有各种不同的咖啡，每一种咖啡都可以加牛奶，巧克力等等的配料，每一种咖啡与配料的价格都不一样，为了以后方便扩充咖啡和配料，进行如下设计： 抽象饮料父类​ 饮料下面还可以有许多具体的类，这里是给出一个规范。 12345678910public abstract class Drink &#123; private String description; // 饮品的描述 private float price = 0.0f; // 饮品的价格 // Setter Getter // 计算价格的方法 public abstract float cost();&#125; 抽象配料父类（抽象装饰者）​ 必须能够替代饮料类，所以继承自饮料类，从而获得同样的类型，继承+组合的关系。 1234567891011121314151617181920public abstract class Decorator extends Drink &#123; private Drink drink; // 组合了被装饰的对象 Drink public Decorator(Drink drink) &#123; this.drink = drink; &#125; @Override public float cost() &#123; // 配料的价钱 + 饮料的价钱 return super.getPrice() + drink.cost(); &#125; @Override public String getDescription() &#123; // 配料的名字 + 配料的价钱 + 饮品的名字 return super.getDescription() + \" \" + super.getPrice() + \" $$ \" + drink.getDescription(); &#125;&#125; 抽象Coffee 类​ 是一个咖啡抽象类，饮料可以分为咖啡、啤酒、奶茶等等 12345678// 饮料中的咖啡类public class Coffee extends Drink &#123; @Override public float cost() &#123; return super.getPrice(); &#125;&#125; 两种不同的 Coffee123456789101112131415public class ACoffee extends Coffee&#123; public ACoffee() &#123; super.setDescription(\" A类型的咖啡 \"); super.setPrice(15.0f); &#125;&#125;public class BCoffee extends Coffee&#123; public BCoffee() &#123; super.setDescription(\" B类型的咖啡 \"); super.setPrice(20.0f); &#125;&#125; 两种不同的配料（装饰者）1234567891011121314151617public class ADecorator extends Decorator &#123; public ADecorator(Drink drink) &#123; super(drink); super.setDescription( \" 巧克力 \"); super.setPrice(3.0f); &#125;&#125;public class BDecorator extends Decorator &#123; public BDecorator(Drink drink) &#123; super(drink); super.setDescription(\" 牛奶 \"); super.setPrice(2.5f); &#125;&#125; 客户端1234567891011121314151617181920public class Client &#123; public static void main(String[] args) &#123; ACoffee aCoffee = new ACoffee(); // A类型咖啡 BDecorator bDecorator = new BDecorator(aCoffee); // 加了一份B String description = bDecorator.getDescription(); System.out.println(\"description = \" + description); float cost = bDecorator.cost(); System.out.println(\"cost = \" + cost); System.out.println(\"---------------------------------\"); ADecorator aDecorator = new ADecorator(bDecorator); // 加了一份A String description1 = aDecorator.getDescription(); System.out.println(\"description1 = \" + description1); float cost1 = aDecorator.cost(); System.out.println(\"cost1 = \" + cost1); &#125;&#125; 装饰者模式在 JDK 中的运用，I/O流","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"桥接模式","slug":"JAVA/设计模式/桥接模式","date":"2019-09-15T16:00:00.000Z","updated":"2020-02-04T08:02:44.311Z","comments":true,"path":"2019/09/16/JAVA/设计模式/桥接模式/","link":"","permalink":"http://yoursite.com/2019/09/16/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"桥接模式画图问题​ 这里有一个画笔，可以画正方形、长方形、圆形。 ​ 但是现在我们需要给这些形状进行上色，这里有三种颜色：白色、灰色、黑色。 ​ 这里我们可以画出3*3=9种。图形：白色正方形、白色长方形、白色圆形。。。。。。到这里了我们几乎到知道了这里存在两种解决方案： 为每种形状都提供各种颜色的版本。 根据实际需要对颜色和形状进行组合。 方案一来实现的话，我们是不是也可以这样来理解呢？为每种颜色都提供各种形状的版本呢？这个是完全的可以的。如下： 方案二所提供的就是解决方法是： 提供两个父类一个是颜色、一个形状，颜色父类和形状父类两个类都包含了相应的子类，然后根据需要对颜色和形状进行组合。 对于有几个变化的维度，我们一般采用方案二来实现，这样除了减少系统中的类个数，也利于系统扩展。对于方案二的应用我们称之为桥接模式。 抽象形状类12345678public abstract class Shape &#123; Color color; // 组合了颜色 public void setColor(Color color) &#123; this.color = color; &#125; public abstract void draw(); // 抽象方法，子类各自实现自己的逻辑&#125; 颜色父接口123public interface Color &#123; public void bepaint(String shape); // 画图形实际的方法&#125; 圆形1234567public class Circle extends Shape&#123; @Override public void draw() &#123; color.bepaint(\"圆形\"); // 桥接调用了颜色的方法 &#125;&#125; 白色1234567public class White implements Color&#123; @Override public void bepaint(String shape) &#123; System.out.println(\"白色的\" + shape); &#125;&#125; 客户端1234567891011public class Client &#123; public static void main(String[] args) &#123; Color white = new White(); // 白色 Circle circle = new Circle(); // 圆形 circle.setColor(white); square.draw(); // 白色的圆形 &#125;&#125; 桥接的理解​ Sharp 类中组合了 Color 接口，Sharp 类的 draw() 方法实际是调用了实现Color 接口的类里面的 bepaint() 方法，怎么去画 是由 实现了 Color 接口的类自己说了算，这样就理解为桥接了。（间接调用） 桥接模式在JDBC中的分析 白色的圆形，黑色的长方形，这样的语句，可以把修饰词作为一类接口 而被修饰的东西，可以设计为抽象类，这样也方面以后扩展代码，避免连续继承。 如：面积为10M的长方形。。。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","slug":"JAVA/设计模式/适配器模式","date":"2019-09-14T16:00:00.000Z","updated":"2020-02-04T07:33:56.494Z","comments":true,"path":"2019/09/15/JAVA/设计模式/适配器模式/","link":"","permalink":"http://yoursite.com/2019/09/15/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"适配器模式 类适配器 220V电压类12345678public class V220 &#123; public int outPut220V() &#123; int src = 220; System.out.println(\"输出电压 :\"+src+\"伏!\"); return src; &#125;&#125; 将要被转换成5V的目标接口123public interface V5 &#123; public int outPut5V();&#125; 电压配器类继承220V，实现5V 1234567891011public class Adapter extends V220 implements V5 &#123; // 把220V 电压 转换成 5V @Override public int outPut5V() &#123; int src = outPut220V(); int dst = src/44; System.out.println(\"转换后输出电压 :\"+dst+\"伏!\"); return dst; &#125;&#125; 手机1234567891011public class Phone &#123; public void charGing(V5 v5)&#123; int i = v5.outPut5V(); if (i == 5)&#123; System.out.println(\"电压为5V，可以充电\"); &#125;else &#123; System.out.println(\"无法充电\"); &#125; &#125;&#125; 客户端1234567public class Client &#123; public static void main(String[] args) &#123; System.out.println(\"类适配器模式\"); Phone phone = new Phone(); phone.charGing(new Adapter()); &#125;&#125; 对象适配器 修改后的适配器类不再继承220V，而是在适配器类中，持有了220V对象 1234567891011121314public class Adapter implements V5 &#123; private V220 v220 = new V220(); // 聚合了 220V // 把220V 电压 转换成 5V @Override public int outPut5V() &#123; System.out.println(\"对象适配器模式\"); int src = v220.outPut220V(); int dst = src/44; System.out.println(\"转换后输出电压 :\"+dst+\"伏!\"); return dst; &#125;&#125; 接口适配器 定义一个接口，可以输出很多种类的电压12345public interface V &#123; public int outPut5V(); // 输出5V public int outPut220V(); // 输出220V public int outPut380V(); // 输出380V&#125; 定义接口适配器，空实现1234567891011121314151617public class Adapter implements V &#123; @Override public int outPut5V() &#123; return 0; &#125; @Override public int outPut220V() &#123; return 0; &#125; @Override public int outPut380V() &#123; return 0; &#125;&#125; 客户端只需要覆盖实现自己所需要的方法就行 12345678910111213public class Phone &#123; public void charGing()&#123; // 匿名内部类的方式调用适配器 new Adapter()&#123; @Override public int outPut5V() &#123; System.out.println(\"使用5V的电压充电\"); return 5; &#125; &#125;; &#125;&#125; 适配器模式在MVC框架中的源码分析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者模式","slug":"JAVA/设计模式/建造者模式","date":"2019-09-13T16:00:00.000Z","updated":"2020-02-04T07:11:46.660Z","comments":true,"path":"2019/09/14/JAVA/设计模式/建造者模式/","link":"","permalink":"http://yoursite.com/2019/09/14/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式​ 建造者模式又叫创建者模式，是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 ​ 创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。 KFC套餐问题​ 建造者模式可以用于描述KFC如何创建套餐 ​ 套餐是一个复杂对象，它一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。 KFC123456public class KFC&#123; private String food; // 主食 private String drink; // 饮料 // Setter Getter toString&#125; Builder抽象建造者，组合了KFC套餐 抽象类的作用是有一个公共的属性，可以说是容器，暂存每一个子类继承后，自己单独设置的属性。 1234567891011public abstract class KFCBuilder &#123; KFC kfc = new KFC(); // KFC 套餐 public abstract void buildFood(); public abstract void buildDrink(); public KFC getKFC()&#123; return kfc; // 返回建造的KFC套餐 &#125;&#125; ConcreteBuilder具体建造者，继承 Builder，实现了不同的构建逻辑 套餐A： 123456789101112public class A extends KFCBuilder&#123; @Override public void buildDrink() &#123; kfc.setDrink(\"可乐\"); // 套餐A的饮品 &#125; @Override public void buildFood() &#123; kfc.setFood(\"薯条\"); // 套餐A的食物 &#125;&#125; 套餐B： 123456789101112public class B extends KFCBuilder &#123; @Override public void buildFood() &#123; kfc.setFood(\"鸡肉卷\"); // 套餐B的食物 &#125; @Override public void buildDrink() &#123; kfc.setDrink(\"果汁\"); // 套餐B的饮品 &#125;&#125; Director包工头，构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象，它主要有三个作用： 隔离了客户与对象的生产过程 负责控制产品对象的生产过程 传什么给包工头，就生产什么种类的KFC 12345678910111213141516public class KFCWaiter &#123; private KFCBuilder kfcBuilder; // 维护了一个抽象的 Builder, public KFCWaiter(KFCBuilder kfcBuilder) &#123; this.kfcBuilder = kfcBuilder; &#125; public KFC construct()&#123; //准备食物 kfcBuilder.buildFood(); //准备饮料 kfcBuilder.buildDrink(); //准备完毕，返回一个完整的套餐给客户 return kfcBuilder.getKFC(); &#125;&#125; 客户端12345678910111213public class Test &#123; public static void main(String[] args) &#123; //套餐A A a = new A(); //准备套餐A的服务员 KFCWaiter waiter = new KFCWaiter(a); //获得套餐 KFC mealA = waiter.construct(); System.out.print(\"套餐A的组成部分:\"); System.out.println(mealA); &#125;&#125; JDK中建造者模式使用例子，StringBuilder.Class","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"原型模式","slug":"JAVA/设计模式/原型模式","date":"2019-09-12T16:00:00.000Z","updated":"2020-02-04T06:57:55.727Z","comments":true,"path":"2019/09/13/JAVA/设计模式/原型模式/","link":"","permalink":"http://yoursite.com/2019/09/13/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型模式通过Clone生成实例 在面向对象系统中，使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一模一样的对象。 另外在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。 克隆羊问题原型类，实现Cloneable接口1234567891011121314151617181920212223242526public class Sheep implements Cloneable &#123; // 可克隆的 private String name; // 羊的名字 private int age; // 羊的年龄 private String color; // 羊的颜色 public Sheep(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; // setter getter toString // 重写 Object 类中的 Clone 方法 @Override protected Sheep clone() &#123; Sheep sheep = null; try &#123; sheep = (Sheep)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; System.out.println(e.getMessage()); &#125; return sheep; &#125;&#125; 客户端1234567Sheep sheep = new Sheep(\"多莉\",1,\"白色\");Sheep clone1 = sheep.clone();Sheep clone2 = sheep.clone();Sheep clone3 = sheep.clone();System.out.println(\"clone1 = \" + clone1);System.out.println(\"clone2 = \" + clone2);System.out.println(\"clone3 = \" + clone3); 原型模式在spring中的使用12&lt;bean id=\"bean1\" class=\"spring.scope.Person\" scope=\"prototype\"/&gt; // 原型&lt;bean id=\"bean1\" class=\"spring.scope.Person\" scope=\"singleton\"/&gt; // 单例 深拷贝与浅拷贝浅拷贝 深拷贝","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂模式-工厂方法模式","slug":"JAVA/设计模式/工厂模式-工厂方法模式","date":"2019-09-12T16:00:00.000Z","updated":"2020-02-04T07:03:06.008Z","comments":true,"path":"2019/09/13/JAVA/设计模式/工厂模式-工厂方法模式/","link":"","permalink":"http://yoursite.com/2019/09/13/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂模式-工厂方法模式​ 定义一个创建对象的接口，但让实现这个接口的子类来决定实例化哪个类，工厂方法让类的实例化推迟到子类进行。 工厂加工塑料问题小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品； 冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本； 解决方案：小成决定置办塑料分厂B来生产B类产品，一种产品由一种工厂生产 抽象工厂类定义工厂的公共接口 1234// 抽象的工厂父类abstract class Factory&#123; public abstract Product Manufacture();&#125; 抽象产品类定义产品的公共接口 1234// 抽象的产品父类abstract class Product&#123; public abstract void Show();&#125; 具体产品类继承抽象产品类， 定义每一个具体生产的产品类型 123456789101112131415//具体产品A类class ProductA extends Product&#123; @Override public void Show() &#123; System.out.println(\"生产出了产品A\"); &#125;&#125; //具体产品B类class ProductB extends Product&#123; @Override public void Show() &#123; System.out.println(\"生产出了产品B\"); &#125;&#125; 具体工厂类继承抽象工厂类，定义创建对应具体产品实例的方法，实例化产品的方法由每个字类去具体实现 123456789101112131415//工厂A类 - 生产A类产品class FactoryA extends Factory&#123; @Override public Product Manufacture() &#123; return new ProductA(); &#125;&#125; //工厂B类 - 生产B类产品class FactoryB extends Factory&#123; @Override public Product Manufacture() &#123; return new ProductB(); &#125;&#125; 客户端外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例 123456789101112//生产工作流程public class FactoryPattern &#123; public static void main(String[] args)&#123; //客户要产品A FactoryA mFactoryA = new FactoryA(); mFactoryA.Manufacture().Show(); //客户要产品B FactoryB mFactoryB = new FactoryB(); mFactoryB.Manufacture().Show(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂模式-简单工厂模式","slug":"JAVA/设计模式/工厂模式-简单工厂模式","date":"2019-09-11T16:00:00.000Z","updated":"2020-02-04T06:54:44.082Z","comments":true,"path":"2019/09/12/JAVA/设计模式/工厂模式-简单工厂模式/","link":"","permalink":"http://yoursite.com/2019/09/12/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂模式-简单工厂模式简单工厂模式（静态工厂模式） 简单工厂模式专门定义一个类（工厂类）来负责创建其他类的实例。 被创建的实例通常都具有共同的父类（或接口）。 加减乘除问题定义一个运算操作的接口1234// 运算操作的接口public interface Operation &#123; public double getResult(double numberA,double numberB) throws Exception;&#125; 定义具体的四个操作类（加，减，乘，除）123456789101112131415161718192021222324252627282930public class Add implements Operation&#123; // 加法计算 public double getResult(double numberA, double numberB) &#123; return numberA + numberB; &#125;&#125; public class Sub implements Operation&#123; // 减法计算 public double getResult(double numberA, double numberB) &#123; return numberA-numberB; &#125;&#125;public class Mul implements Operation&#123; // 乘法计算 public double getResult(double numberA, double numberB) &#123; return numberA * numberB; &#125;&#125;public class Div implements Operation &#123; // 除法计算 public double getResult(double numberA, double numberB) throws Exception &#123; if (numberB == 0) &#123; throw new Exception(\"除数不能为0！\"); &#125; return numberA / numberB; &#125;&#125; 定义简单工厂类123456789101112131415161718192021public class EasyFactory &#123; // 简单工厂，根据字符串创建相应的对象 public static Operation createOperation(String name) &#123; Operation operationObj = null; // 操作接口 switch (name) &#123; case \"+\": operationObj = new Add(); break; case \"-\": operationObj = new Sub(); break; case \"*\": operationObj = new Mul(); break; case \"/\": operationObj = new Div(); break; &#125; return operationObj; &#125;&#125; 客户端123456789101112131415public class Client &#123; public static void main(String[] args) throws Exception &#123; Operation add = EasyFactory.createOperation(\"+\"); Operation sub = EasyFactory.createOperation(\"-\"); Operation mul = EasyFactory.createOperation(\"*\"); Operation div = EasyFactory.createOperation(\"/\"); System.out.println(add.getResult(1, 1)); System.out.println(sub.getResult(1, 1)); System.out.println(mul.getResult(1, 1)); System.out.println(div.getResult(1, 1)); &#125;&#125; 我们无需提供具体的子类类名，只需要提供一个字符串即可得到相应的实例对象。这样的话，当子类的类名更换或者增加子类时我们都无需修改客户端代码，只需要在简单工厂类上增加一个分支判断代码即可。 简单工厂方法的缺点 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响。 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 JDK中简单工厂模式使用例子，Calendar.class 通过 createCalender() 方法来创建 Calender","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"JAVA/设计模式/单例模式","date":"2019-09-10T16:00:00.000Z","updated":"2020-02-04T06:37:50.882Z","comments":true,"path":"2019/09/11/JAVA/设计模式/单例模式/","link":"","permalink":"http://yoursite.com/2019/09/11/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式​ 采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象的实例的静态方法。 私有化构造函数，防止外部 new 对象 在类里面自己 new 一个静态对象 对外提供一个公开的获得实例的方法，返回自己 new 的对象 静态常量–饿汉式12345678910class Singleton&#123; private Singleton()&#123;&#125; private static final Singleton instance = new Singleton(); public static Singleton getInstance()&#123; return instance; &#125;&#125; 静态代码块–饿汉式1234567891011121314class Singleton2&#123; private Singleton2()&#123;&#125; private static Singleton2 instance; // 给出定义不赋值 static &#123; instance = new Singleton2(); // 静态代码块中创建单例对象 &#125; public static Singleton2 getInstance()&#123; return instance; &#125;&#125; 线程不安全–懒汉式12345678910111213class Singleton3&#123; private Singleton3()&#123;&#125; private static Singleton3 instance; public static Singleton3 getInstance()&#123; if (instance == null)&#123; // 懒汉会先判断一下，才会创建，懒加载模式 instance = new Singleton3(); &#125; return instance; &#125;&#125; 线程安全，同步方法–懒汉式12345678910111213class Singleton4&#123; private Singleton4()&#123;&#125; private static Singleton4 instance; public synchronized static Singleton4 getInstance()&#123; // 加锁，加的是类锁 if (instance == null)&#123; instance = new Singleton4(); &#125; return instance; &#125;&#125; 线程不安全，同步代码块–懒汉式123456789101112131415class Singleton5&#123; private Singleton5()&#123;&#125; private static Singleton5 instance; public static Singleton5 getInstance()&#123; if (instance == null)&#123; synchronized (Singleton5.class)&#123; instance = new Singleton5(); &#125; &#125; return instance; &#125;&#125; 双重检查 —- 推荐1234567891011121314151617class Singleton6&#123; private Singleton6()&#123;&#125; private static volatile Singleton6 instance; public static Singleton6 getInstance()&#123; if (instance == null)&#123; synchronized (Singleton6.class)&#123; if (instance == null)&#123; // 对等待的线程再判断 instance = new Singleton6(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类 —- 推荐123456789101112class Singleton7&#123; private Singleton7()&#123; &#125; private static class SingletonInstance&#123; private static final Singleton7 INSTANCE = new Singleton7(); &#125; public static Singleton7 getInstance()&#123; return SingletonInstance.INSTANCE; &#125;&#125; JDK中单例模式使用例子，RunTime.class","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式的7大原则","slug":"JAVA/设计模式/设计模式的7大原则","date":"2019-09-10T16:00:00.000Z","updated":"2020-02-04T06:27:43.139Z","comments":true,"path":"2019/09/11/JAVA/设计模式/设计模式的7大原则/","link":"","permalink":"http://yoursite.com/2019/09/11/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%847%E5%A4%A7%E5%8E%9F%E5%88%99/","excerpt":"","text":"设计模式的7大原则单一职责、认真做好一件事对类来说，就是一个类只负责一项职责。 如果一个A类负责两个不同的职责：职责1与职责2。当职责1需求改变时去改变A时，可能造成职责2的错误。就需要把A类粒度分解为A1，A2。 接口隔离、接口细化对接口来说，建立单一的接口，不要建立臃肿庞大的接口。 也就是接口尽量细化，同时接口中的方法尽量少，细化。 依赖倒转，面向接口编程程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 里氏替换、子替换父所有引用基类的地方必须能透明地使用其子类的对象，也可以简单理解为任何基类可以出现的地方，子类一定可以出现。子类尽量不要重写父类的方法。 开闭原则 OCP对扩展开放（提供方），对修改关闭（使用方） 迪米特法则、高内聚，解耦合一个软件实体应当尽可能少地与其他实体发生相互作用。 每一个软件实体对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 每一个软件实体应该包含本类独有的属性与方法 合成复用、少继承尽量使用合成/聚合，而不是通过继承达到复用的目的。 组合与聚合的差别组合和聚合是有很大区别的，这个区别不是在形式上，而是在本质上： 比如A类中包含B类的一个引用b，当A类的一个对象消亡时，b这个引用所指向的对象也同时消亡（没有任何一个引用指向它，成了垃圾对象），这种情况叫做组合。 反之b所指向的对象还会有另外的引用指向它，这种情况叫聚合。 组合方式一般会这样写： A类的构造方法里创建B类的对象，也就是说，当A类的一个对象产生时，B类的对象随之产生，当A类的这个对象消亡时，它所包含的B类的对象也随之消亡。 1234567// 组合： class Person &#123; private Computer computer; public Person() &#123; computer = new Computer(); &#125; &#125; 聚合方式则是这样： A类的对象在创建时不会立即创建B类的对象，而是等待一个外界的对象传给它的这个对象的方法不是构造方法，通常是setter/getter方法。 1234567// 聚合： class Person &#123; private Computer computer; public setComputer() &#123; computer = new Computer(); &#125; &#125; 总结 找出程序中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程 为交互对象之间的松耦合设计而努力","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"一天学一个设计模式","slug":"一天学一个设计模式","permalink":"http://yoursite.com/tags/%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Explain使用例子","slug":"JAVA/Mysql/Explain使用例子","date":"2019-06-12T16:00:00.000Z","updated":"2020-02-04T06:24:13.272Z","comments":true,"path":"2019/06/13/JAVA/Mysql/Explain使用例子/","link":"","permalink":"http://yoursite.com/2019/06/13/JAVA/Mysql/Explain%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90/","excerpt":"","text":"Explain使用例子​ 首先先说总结，然后看具体案例的例子。 带头大哥不能少，中间兄弟不能断，索引列上别计算，范围之后全失效，百分like加右边，字符串上有引号。 左前缀保留原则如果索引了多个字段，查询从索引的最左端字段开始，并且不会跳过索引中的字段eg：索引字段1，2，3，对应楼层的1，2，3层如果没有1层，索引2和3，那么无法找到2楼和3楼如果没有中间层2层，那么无法找到3楼 1ALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(name, age, pos); -- 三个字段的组合索引 创建索引 idx_staffs_nameAgePos(name, age, pos)，索引字段从左往右依次是name、age、pos 表1和表2没有name，所以索引无法查找，possible_keys和key都是NULL，出错 表3中有name，possible_keys和key使用索引idx_staffs_nameAgePos查询，正确 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换） 已经建立好了索引，在select时，在where列表中对索引列表进行修改，容易引起索引失效，从而变成全表扫描ALL，降低数据库的效能 索引的列是字符串时，在 where 语句中，一定要加引号，如果不加，mysql会自动的做类型转换，从而导致索引失效，这是一个很常见的错误 存储引擎不能使用索引中范围条件range（&lt;、&gt;、between、in等）右边的索引字段 最下面的索引，age&gt;11是范围条件，它右边的字段pos=’manger’索引失效 所以最后索引只用到了两个字段，name和age；key_len是78 范围之后全失效 like形式查询，以通配符%开头时，要将%放在字母右边，否则索引失效转为全表扫描 可以发现，当like后面字段通配符%放在左边时，索引失效，type转为全表扫描ALL 因为字段扫描时，%在最左边无法确定字段，所以索引失效 若字母在字段右边，可以确定字段，索引有效 百分like加右边 尽量使用覆盖索引（Covering Index）​ 减少使用select *，提高索引效率； 使用不等于（!=、&lt;&gt;）时，无法使用索引会导致全表扫描ALL 原本的name=’July’时，使用的查询类型type是ref非唯一性索引； 当变成!=和&lt;&gt;后，转为全表扫描ALL，索引失效； 不能使用不等于 在创建table中数据时，字段的null/not null，要与explain select where列表中字段保持一致eg：创建表时，插入数据，字段a为null；explain select where列表中字段a not null；查询会出问题； 字符串不加单引号，索引会失效 name=‘917’，变成了name=917；优化器自动转换字段的类型，结果索引失效，key为NULL； 索引列上别计算，自动类型转换也是计算 字符串上加引号 别用or，用它来连接时，索引会失效","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Explain","slug":"JAVA/Mysql/Explain","date":"2019-06-10T16:00:00.000Z","updated":"2020-02-04T06:22:40.477Z","comments":true,"path":"2019/06/11/JAVA/Mysql/Explain/","link":"","permalink":"http://yoursite.com/2019/06/11/JAVA/Mysql/Explain/","excerpt":"","text":"Explain​ 在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，这时我们常常用到 explain 这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。 使用方法：explain + SQL语句 1234-- 实际SQL，查找用户名为杨发的员工select * from emp where name = '杨发';-- 查看SQL是否使用索引，前面加上explain即可explain select * from emp where name = '杨发'; expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra Explain 怎么玩 id：SQL执行的顺序SELECT识别符。这是SELECT的查询序列号 我的理解是SQL执行的顺序的标识，SQL从大到小的执行 id相同时，执行顺序由上至下 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行 12-- 查看在研发部并且名字以杨开头的员工，经典查询explain select e.no, e.name from emp e left join dept d on e.dept_no = d.no where e.name like '杨%' and d.name = '研发部'; select_type：select语句的类型 SIMPLE ：查询中不包含 子查询 与 Union，最简单的查询 PRIMARY ：最外面的 SELECT，最后加载的查询 SUBQUERY：子查询中的第一个SELECT语句 DERIVED：导出表的SELECT(FROM子句的子查询)，也就是虚表，mysql会递 归执行这些子查询，把结果放在子查询里。 UNION：第二个SELECT语句出现在UNION之后，则会被标记为UNION； UNION包含在FROM子句的子查询中，外出SELECT会被标记为DERIVED。 UNION RESULT ：UNION结果集 type：查询的方式对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。 常用的类型有： ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好），一般到range，ref就比较好了。 ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行 index: Full Index Scan，index与ALL区别为index类型只遍历索引树 range:只检索给定范围的行，只使用一个索引来选择行 ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值，索引与记录一对多 eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件，唯一性索引扫描，一对一 const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system。相当于系统表 NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。 possible_keys：可能会用到的索引key：查询实际用到的索引​ 属于 possible_keys key_len：表示索引中使用的字节数​ 可通过该列计算查询中使用的索引的长度，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。 ref：表示上述表的连接匹配条件​ 即哪些列或常量被用于查找索引列上的值 Extra，该列包含MySQL解决查询的详细信息，都是错误信息！！！ Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为 “文件排序”，此时应该查看索引建立顺序，按照索引顺序排序。 Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ， order by，包含了上面了 的 Using filesort","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"SQL JOIN","slug":"JAVA/Mysql/SQL JOIN","date":"2019-06-09T16:00:00.000Z","updated":"2020-02-04T06:15:23.257Z","comments":true,"path":"2019/06/10/JAVA/Mysql/SQL JOIN/","link":"","permalink":"http://yoursite.com/2019/06/10/JAVA/Mysql/SQL%20JOIN/","excerpt":"","text":"SQL JOIN SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。 最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）、SQL LEFT JOIN、SQL RIGHT JOIN、SQL FULL JOIN，其中前一种是内连接，后三种是外链接。 假设我们有两张表， A: id name 1 Google 2 淘宝 3 微博 4 Facebook B: id address 1 美国 3 中国 5 中国 6 美国 INNER JOIN 内连接是最常见的一种连接，只连接匹配的行。 1select * from A inner join Table B on A.id = B.id 执行以上SQL输出结果如下： id name address 1 Google 美国 3 微博 中国 LEFT JOIN LEFT JOIN产生表1的完全集，而2表中匹配的则有值，没有匹配的则以null值取代。 1select * from A left join B on A.id = B.id 执行以上SQL输出结果如下： id name address 1 Google 美国 2 淘宝 null 3 微博 中国 4 Facebook null RIGHT JOIN RIGHT JOIN产生表2的完全集，而1表中匹配的则有值，没有匹配的则以null值取代。 1select * from A right join B on A.id= B.id 执行以上SQL输出结果如下： id name address 1 Google 美国 5 null 中国 3 微博 中国 6 null 美国 FULL OUTER JOIN FULL OUTER JOIN产生1和2的并集。但是需要注意的是，对于没有匹配的记录，则会以null做为值。 1select * from A full outer join B on A.id = B.id 执行以上SQL输出结果如下： id name address 1 Google 美国 2 淘宝 null 3 微博 中国 4 Facebook null 5 null 中国 6 null 美国","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"存储引擎","slug":"JAVA/Mysql/存储引擎","date":"2019-06-08T16:00:00.000Z","updated":"2020-02-04T05:57:50.153Z","comments":true,"path":"2019/06/09/JAVA/Mysql/存储引擎/","link":"","permalink":"http://yoursite.com/2019/06/09/JAVA/Mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","excerpt":"","text":"存储引擎存储引擎是什么东西​ 在讲清楚什么是存储引擎之前，我们先来个比喻，我们都知道录制一个视频文件，可以转换成不同的格式，例如mp4，avi，wmv等，而存在我们电脑的磁盘上也会存在于不同类型的文件系统中如windows里常见的ntfs、fat32，存在于linux里常见的ext3，ext4，xfs，但是，给我们或者用户看的实际视频内容都是一样的。直观区别是，占用系统的空间大小与清晰程度可能不一样。 ​ 那么数据库表里的数据存储在数据库里及磁盘上和上述的视频格式及存储磁盘文件的系统格式特征类似，也有很多种存储方式。 ​ 但是对于用户和应用程序来说同样一张表的数据，无论用什么引擎来存储，用户能够看到的数据是一样的。不同储引擎存取，引擎功能，占用空间大小，读取性能等可能有区别。 ​ 说白了，存储引擎就是在如何存储数据、提取数据、更新数据等技术方法的实现上，底层的实现方式不同，那么就会呈现出不同存储引擎有着一些自己独有的特点和功能，对应着不同的存取机制。 其实MySQL支持多种存储引擎，每种引擎有着一些自己独特的功能，用户在使用的时候，可以根据自己的业务场景来使用不同的存储引擎，其中MySQL最常用的存储引擎为：MyISAM和InnoDB。 MySQL存储引擎分类MySQL5.1之前，默认的存储引擎是MyISAM，之后都改为InnoDB MyISAM​ MyISAM是非聚集索引，使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 InnoDB​ InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。 InnoDB为什么推荐使用自增ID作为主键？答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。 InnoDB引擎的4大特性插入缓冲（insert buffer)，二次写(double write)，自适应哈希索引(ahi)，预读(read ahead)。 MyISAM 与 InnoDB 的差别 B+树结构B+树，是B树的一种变体，也是一种多路搜索树。他们差别是： B+树中所有的数据都会放在叶子结点，而不会放在非叶子结点 B+数的特点 B+树 跟 B树 搜索基本相同，区别是 B+树 只有达到叶子结点才会命中，搜索性能等于在关键字全集中做二分查找。 所有的 关键字都出现在叶子结点的链表中，（即关键字只能在叶子结点【稠密索引】），且链表中的关键字恰好是有序的。 非叶子结点相当于是叶子结点的索引【稀疏索引】，叶子结点相当于是存储（关键字）的箱子。 适合做文件索引系统，数据库索引系统。 B+树的磁盘读写代价更低​ B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 ​ B+树非叶子节点没有Data数据，所以同样大小的磁盘页可以容纳更多的节点元素。所以数据量相同的情况下，B+树比B树更加“矮胖“，因此使用的IO查询次数更少。 ​ 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。 B+树的查询效率更加稳定​ 由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 而B树的查找并不稳定（最好的情况是查询根节点，最坏查询叶子节点）。而B树每一次查找都是稳定的。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"日期处理函数","slug":"JAVA/Mysql/日期处理函数","date":"2019-06-07T16:00:00.000Z","updated":"2020-02-04T05:54:57.999Z","comments":true,"path":"2019/06/08/JAVA/Mysql/日期处理函数/","link":"","permalink":"http://yoursite.com/2019/06/08/JAVA/Mysql/%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/","excerpt":"","text":"日期处理函数​ 在 Mysql数据库中，已经给我们内定了许多的函数，如下使用所示： 获取系统当前日期时间： SYSDATE()、NOW() 1SELECT SYSDATE() = SELECT NOW() --&gt; 2019-07-10 19:15:31 获取系统当前日期：CURDATE() 1SELECT CURDATE() --&gt; 2019-07-10 获取系统当前时间：CURTIME() 1SELECT CURTIME() --&gt; 19:16:20 获取给定日期的年： YEAR(date)，求系统当前日期的年份 1SELECT YEAR(SYSDATE()) --&gt; 2019 获取给定日期的季度： QUARTER(date)，求系统当前日期的季度 1SELECT QUARTER(SYSDATE()) --&gt; 1 获取给定日期的月：MONTH(date)，求系统当前日期的月份 1SELECT MONTH(SYSDATE()) --&gt; 7 获取给定日期是星期几：DAYOFWEEK(date)，求系统当前日期的是星期几 1=星期天，2=星期一，…………，7=星期六 1SELECT DAYOFWEEK(SYSDATE()) --&gt; 2 获取该日期为当月的第几天：DAYOFMONTH(date)，求系统当前日期的是这个月的第几天 1SELECT DAYOFMONTH(SYSDATE()) --&gt; 3 获取该日期为当年的第几天：DAYOFYEAR(date)，求系统当前日期的是今年的第几天 1SELECT DAYOFYEAR(SYSDATE()) --&gt; 34 操作时间，为指定日期增加一个时间间隔的函数：DATE_ADD(date，INTERVAL expr unit) 1234DATE_ADD(now(), interval 1 day); --&gt; 加1天 DATE_ADD(now(), interval -1 day); --&gt; 减1天DATE_ADD(now(), interval -1 year); --&gt; 减1年DATE_ADD(now(), interval 2 MONTH); --&gt; 加2月 获取两个日期间的时间差：TIMESTAMPDIFF(求时间的什么，begindate，enddate) 12HOUR DAY WEEK MONTH QUARTER YEARSELECT TIMESTAMPDIFF(year,'1999-12-31','2999-12-31') --&gt; 1000","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"SQL语句执行的顺序","slug":"JAVA/Mysql/SQL语句执行的顺序","date":"2019-06-06T16:00:00.000Z","updated":"2020-02-04T06:11:57.317Z","comments":true,"path":"2019/06/07/JAVA/Mysql/SQL语句执行的顺序/","link":"","permalink":"http://yoursite.com/2019/06/07/JAVA/Mysql/SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"SQL语句执行的顺序 from &gt; on &gt; where &gt; group by &gt; select &gt; order by ​ 理解sql语句的执行顺序对优化sql非常重要，那么sql语句的执行顺序是怎样的呢，以一条SQL语句做分析： 获得来自北京，并且订单数少于2的客户; 12345678SELECT u.user_id,COUNT(o.order_id) as total_ordersFROM user as uLEFT JOIN orders as oON u.user_id = o.user_idWHERE u.city = 'beijing'GROUP BY u.user_idHAVING COUNT(o.order_id) &lt; 2ORDER BY total_orders desc 在这些SQL语句的执行过程中，都会产生一个虚拟表，用来保存SQL语句的执行结果 第一步，执行FROM语句​ 我们首先需要知道最开始从哪个表开始的，这就是FROM告诉我们的。现在有了&lt;left_table&gt;和&lt;right_table&gt;两个表，我们到底从哪个表开始，还是从两个表进行某种联系以后再开始呢？它们之间如何产生联系呢？——笛卡尔积 经过FROM语句对两个表执行笛卡尔积，会得到一个虚拟表，VT1（vitual table 1），内容如下： 总共有28（user的记录条数 * orders的记录条数）条记录。这就是VT1的结果，接下来的操作就在VT1的基础上进行 第二步，执行ON过滤​ 执行完笛卡尔积以后，接着就进行ON a.user_id = b.user_id条件过滤，根据ON中指定的条件，去掉那些不符合条件的数据,得到VT2如下： 第三步，添加外部行​ 这一步只有在连接类型为OUTER JOIN时才发生，如LEFT OUTER JOIN、RIGHT OUTER JOIN和FULL OUTER JOIN。在大多数的时候，我们都是会省略掉OUTER关键字的，但OUTER表示的就是外部行的概念。 ​ LEFT OUTER JOIN把左表记为保留表：即左表的数据会被全部查询出来，若右表中无对应数据，会用NULL来填充： ​ RIGHT OUTER JOIN把右表记为保留表：即右表的数据会被全部查询出来，若左表中无对应数据，则用NULL补充； ​ FULL OUTER JOIN把左右表都作为保留表，但在Mysql中不支持全连接，可以通过以下方式实现全连接： ​ 由于我在准备的测试SQL查询逻辑语句中使用的是LEFT JOIN，得到的VT3表如下： 第四步，执行where条件过滤​ 对添加了外部行的数据进行where条件过滤，只有符合条件的记录会被筛选出来，执行WHERE a.city = &#39;beijing得到VT4如下： 但是在使用WHERE子句时，需要注意以下两点： 由于数据还没有分组，因此现在还不能在 where 过滤条件中使用where_condition=MIN(col)这类的聚合函数对分组统计的过滤； 由于还没有进行列的选取操作，因此在select中使用列的别名也是不被允许的，如：select city as c from table1 where c = &#39;beijing&#39; 是不允许的 第五步，执行group by分组语句GROUP BY子句主要是对使用WHERE子句得到的虚拟表进行分组操作，执行GROUP BY a.user_id得到VT5如下： 第六步，执行havingHAVING子句主要和GROUP BY子句配合使用，对分组得到VT5的数据进行条件过滤，执行 HAVING COUNT(b.order_id) &lt; 2，得到VT6如下： 第七步，select列表现在才会执行到SELECT子句，不要以为SELECT子句被写在第一行，就是第一个被执行的。 我们执行测试语句中的SELECT a.user_id,user_name,COUNT(b.order_id) as total_orders，从VT6中选择出我们需要的内容，得到VT7如下： 第八步，执行distinct去重复数据​ 如果在查询中指定了DISTINCT子句，则会创建一张内存临时表（如果内存放不下，就需要存放在硬盘了）。 ​ 这张临时表的表结构和上一步产生的虚拟表是一样的，不同的是对进行DISTINCT操作的列增加了一个唯一索引，以此来除重复数据。测试SQL中没有DISTINCT字句，所以不会执行 第九步，执行order by字句对虚拟表VT7中的内容按照指定的列进行排序，然后返回一个新的虚拟表，我们执行测试SQL语句中的ORDER BY total_orders DESC ，得到结果如下： DESC倒序排序，ASC升序排序 第十步，执行limit字句LIMIT子句从上一步得到的虚拟表中选出从指定位置开始的指定行数据，常用来做分页； MySQL数据库的LIMIT支持如下形式的选择：limit n,m 表示从第n条记录开始选择m条记录。对于小数据，使用LIMIT子句没有任何问题，当数据量非常大的时候，使用LIMIT n, m是非常低效的。 因为LIMIT的机制是每次都是从头开始扫描，如果需要从第60万行开始，读取3条数据，就需要先扫描定位到60万行，然后再进行读取，而扫描的过程是一个非常低效的过程。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"索引","slug":"JAVA/Mysql/索引","date":"2019-06-04T16:00:00.000Z","updated":"2020-02-04T06:25:43.890Z","comments":true,"path":"2019/06/05/JAVA/Mysql/索引/","link":"","permalink":"http://yoursite.com/2019/06/05/JAVA/Mysql/%E7%B4%A2%E5%BC%95/","excerpt":"","text":"索引详解","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Config 分布式配置中心","slug":"SpringCloud/Config 分布式配置中心","date":"2019-03-21T16:00:00.000Z","updated":"2020-02-10T06:40:21.069Z","comments":true,"path":"2019/03/22/SpringCloud/Config 分布式配置中心/","link":"","permalink":"http://yoursite.com/2019/03/22/SpringCloud/Config%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/","excerpt":"","text":"Config 分布式配置中心分布式系统面临的问题微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理是必不可少的。 Spring Cloud Config 是什么？Spring Cloud Config 分为两个部分：Config Server 和 Config Client。我们先来看一下整个 Spring Cloud Config 的一个流程。 Config Client：客户端通过指定的配置中心来管理应用资源、以及业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。 Config Server：服务端也称为分布式配置中心，它是一个独立的微服务应用。用来连接配置服务器并为 Spring Client 客户端提供配置信息。 Config Server 的搭建新建 repository在 GitHub 上新建一个 repository，我们命名为：microservice-config 在本地新建仓库并克隆1git clone https://github.com/yangfa4j/microservice-config.git 建立YML文件，并推送到GitHub1234567891011121314spring: profiles: active: - dev---spring: profiles: dev application: name: microservice-config-client-dev---spring: profiles: test application: name: microservice-config-client-test 相当于我们写了两个配置，指定的是 dev 的配置，推送到 GitHub 之后，那么配置信息就搞好了，等下我们来读取这些配置信息。 添加依赖在本地新建一个 model 项目：microservice-config，用作 Spring Cloud 的配置中心模块。导入依赖： 12345&lt;!-- configServer --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt; 修改Boot应用入口主启动类需要添加 @EnableConfigServer 注解。 1234567@SpringBootApplication@EnableConfigServer //开启配置中心服务public class MicroserviceConfig &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceConfig.class, args); &#125;&#125; 配置YML1234567891011server: port: 5555spring: application: name: microservice-config cloud: config: server: git: uri: https://github.com/yangfa4j/microservice-config.git # github repository位置 端口号我们定为 5555，服务名称为：microservice-config。 最重要的就是 spring.cloud.config.server.git.uri 这个值了，该值就是我们刚刚新建的 repository 的对应 git 地址。这样 Config Server 端就知道从哪获取配置信息了。 测试启动该配置中心，在浏览器输入：http://localhost:5555/application-dev.yml 可以获取如下信息： 再输入：http://localhost:5555/application-test.yml 可以获取如下信息： 说明 Config Server 和 GitHub 通信成功，可以获取相应的配置信息，接下来我们就要来搞一下 Config Client 端了。 Config Client 的搭建Conifg Client 通过 Config Server 与 GitHub 通信。 之前我们写代码，客户端都是直接通过 application.yml 配置文件，获取相关的配置，也就是说，配置信息都写在服务本身的 application.yml 里了。 现在客户端通过上面的 Config Server（即配置中心），能否获取到我们传在 GitHub 上的配置呢？ 添加依赖我们新建一个客户端的 model 工程，取名为：microservice-config-client。导入 config 依赖： 12345&lt;!-- config client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 然后在 resource 目录下新建一个 bootstrap.yml 文件，application.yml 是用户级的资源配置项，bootstrap.yml 是系统级的，优先级更高。 新增一个 bootstrap.yml1234567spring: cloud: config: uri: http://localhost:5555 # 与ConfigServer 关联起来 name: application # 从github上读取的资源名称，不要加 .yml后缀 label: master # 从master分支上 profile: dev # 获取dev配置 解释： 启动该服务，表示去 5555 服务找配置，5555 服务连了 GitHub。 Spring.cloud.config.name: microservice-config 表示读取 GitHub 上 microservice-config.yml 文件内容 Spring.cloud.config.label: master 表示读取 master 分支 Spring.cloud.config.profile: dev 表示读取 profile 为 dev 的配置 测试写一个Controller测试一下： 1234567891011121314151617181920@RestController@RequestMapping(\"/config\")public class ClientController &#123; @Value(\"$&#123;spring.application.name&#125;\") private String springApplicationName; @Value(\"$&#123;server.port&#125;\") private String serverPort; @Value(\"$&#123;eureka.client.service-url.defaultZone&#125;\") private String defaultEurekaZone; @GetMapping(\"/test\") public String getConfig() &#123; return \"applicationName=\" + springApplicationName + \"; serverPort=\" + serverPort + \"; defaultEurekaZone=\" + defaultEurekaZone; &#125;&#125; 启动 5555 服务，再启动该服务，在浏览器输入 http://localhost:8881/config/test即可出现： applicationName=microservice-config-client; serverPort=8881; defaultEurekaZone=http://eureka01:7001/eureka/ 说明配置读取完成。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"Zuul 路由网关","slug":"SpringCloud/Zuul 路由网关","date":"2019-03-20T16:00:00.000Z","updated":"2020-02-10T06:09:33.253Z","comments":true,"path":"2019/03/21/SpringCloud/Zuul 路由网关/","link":"","permalink":"http://yoursite.com/2019/03/21/SpringCloud/Zuul%20%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3/","excerpt":"","text":"Zuul 路由网关Zuul 包含了对请求的 路由 过滤 两个最主要的功能。 其中，路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础。 而过滤功能则是负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。 Zuul 和 eureka 进行整合，将 zuul 自身注册为eureka服务治理下的应用，同时从 eureka 中获得其他微服务的消息，也即以后的访问微服务都是通过zuul跳转之后获得。 Zuul的使用我们自定义一个新的项目工程：microservice-zuul-gateway。 添加依赖12345&lt;!-- zuul 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 修改Boot应用入口在主启动类中需要添加：@EnableZuulProxy 注解，表示开启 zuul 代理。 123456789@EnableZuulProxy //开启 zuul 代理@EnableEurekaClient@SpringBootApplicationpublic class SpringcloudApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringcloudApplication.class, args); &#125;&#125; 配置YML123456789101112131415161718# 服务端口号server: port: 6001spring: application: name: microservice-zuul-gateway # 对外暴露的服务名称# zuul客户端注册进eureka服务列表里eureka: client: service-url: defaultZone: http://localhost:1111/eureka #绑定Eureka 服务中心，将自己注册到服务中心 healthcheck: enabled: true instance: instance-id: zuul网关服务-6001 # 人性化显示出服务的信息 prefer-ip-address: true # 访问路径可显示ip地址 测试我们首先直接访问一下订单服务，确保服务可用：http://localhost:8001/provider/order/get/1 然后我们通过 zuul来访问该订单服务： http://localhost:6001/microservice-order/provider/order/get/1 6001 端口就是 zuul 的服务端口，是通过 zuul 服务 去请求的服务， microservice-order 是订单服务的服务名。 即 zuul 在 eureka 里找到了一个叫 microservice-order 的订单服务，然后去请求数据。所以说，zuul 是可以根据注册到 eureka 中的服务名称来访问服务的。 那么我们自然会想到，如果我把三个订单服务都启动起来，因为它们的服务名称都是 microservice-order，zuul 到底会将请求转发给哪个服务呢？ 启动下 8001、8002 和 8003，然后还是访问 http://localhost:6001/microservice-order/provider/order/get/1 ，查看输出的信息，可以知道，zuul 中默认集成了轮询的规则，三个服务轮流调用。 自定义路由规则如果我们不想像上面那样在 url 中直接暴露微服务名称，可以在配置文件中配一下路由规则。 1234567# 配置路由规则zuul: routes: # 如下指定新的映射 order: serviceId: microservice-order # 服务提供者在YML中的名字 path: /order/** # 自定义的路由规则，代替了上面的 serviceId 这样的话，在配置了路由规则之后，就可以使用： http://localhost:6001/order/provider/order/get/1 来访问订单服务了。 但是这样的话，原来使用微服务名称的方式还是可以访问，所以我们可以禁用原来使用微服务名称的方式访问。如下 12345678# 配置路由规则zuul: ignored-services: microservice-order # 不允许用微服务名访问了，如果禁用所有的，可以使用 \"*\" routes: # 如下指定新的映射 order: serviceId: microservice-order path: /order/** 我们还可以给路由加一个统一的前缀： 123456789# 配置路由规则zuul: ignored-services: microservice-order # 不允许用微服务名访问了，如果禁用所有的，可以使用 \"*\" routes: prefix: /zuul # 给路由加一个统一的前缀 # 如下指定新的映射 order: serviceId: microservice-order path: /order/** 这样的话，就可以使用：http://localhost:6001/zuul/order/provider/order/get/1 来访问订单服务了。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"Hystrix Dashboard的使用","slug":"SpringCloud/Hystrix Dashboard 的使用","date":"2019-03-19T16:00:00.000Z","updated":"2020-02-10T03:15:49.398Z","comments":true,"path":"2019/03/20/SpringCloud/Hystrix Dashboard 的使用/","link":"","permalink":"http://yoursite.com/2019/03/20/SpringCloud/Hystrix%20Dashboard%20%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Hystrix Dashboard 的使用Hystrix 还提供了准实时的调用监控（Hystrix Dashboard），Hystrix 会持续记录所有通过 Hystrix 发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求，有多少成功或者失败等。 Spring Cloud 也提供了 Hystrix Dashboard 的整合，对监控内容转化成可视化界面。 服务提供者 与 服务消费者 都应该添加依赖。 添加依赖我们新建一个工程：microservice-order-consumer-hystrix-dashboard，用来完成可视化监控。端口号设置为 9002。 12345678910111213&lt;dependencies&gt; &lt;!-- hystrix --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- hystrix-dashboard --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 修改Boot应用入口在启动类中，需要添加 @EnableHystrixDashboard 注解。 12345678@SpringBootApplication@EnableHystrixDashboard // 开启 hystrix 监控面板public class OrderConsumerHystrixDashboard &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderConsumerHystrixDashboard.class, args); &#125;&#125; 服务提供方需要添加监控依赖在服务提供方，也需要添加一个 Spring Boot 监控依赖： 12345&lt;!-- spring boot actuator 监控信息 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 测试这样的话，hystrix dashboard 就基本配置好了，启动一下我们新建的这个监控项目，在浏览器中输入： http://localhost:9002/hystrix 如果出现下面的这只豪猪兄，那说明 hystrix dashboard 没有问题。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"hystrix dashboard 监控其他服务","slug":"SpringCloud/hystrix dashboard 监控其他服务","date":"2019-03-19T16:00:00.000Z","updated":"2020-02-10T05:30:35.464Z","comments":true,"path":"2019/03/20/SpringCloud/hystrix dashboard 监控其他服务/","link":"","permalink":"http://yoursite.com/2019/03/20/SpringCloud/hystrix%20dashboard%20%E7%9B%91%E6%8E%A7%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"hystrix dashboard 监控其他服务上面我们能正常启动豪猪兄了，但是如何监控其他服务呢？我们以带有 hystrix 的订单提供服务为例（端口号为8001）。如果要实现被监控，我们需要在被监控的服务上做一些准备。 依赖导入首先在这个订单服务上添加 hystrix 依赖（当然了，该8001端口的订单提供服务已经添加过了该依赖了） 12345&lt;!-- hystrix --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 修改Boot应用入口类在启动类上添加注解：@EnableCircuitBreaker 123456789@SpringBootApplication@EnableEurekaClient @EnableCircuitBreaker // hystrix 启动注解public class OrderProvider01 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderProvider01.class, args); &#125;&#125; 配置YML最后，在配置文件中开启指标流端点，这个在后面监控时候需要用到，下文再来描述。 1234567# 配置hystrix dashboard的url访问# 开启指标流端点management: endpoints: web: exposure: include: hystrix.stream # 指标流端点 测试首先：使用8001端口的订单服务为例，首先启动eureka集群，然后启动带有hsytrix的订单服务，我们在浏览器里输入 http://localhost:8001/provider/order/get/1 可以获取订单服务信息，确定订单服务正常。 然后打开 http://localhost:9002/hystrix 能出现豪猪兄，能看到已经开启了 Hystrix.Stream 流， 说明 dashboard 没有问题。 我们看到，这个url 就是用来监控某个服务的状态，上面在application.yml文件里配置的url就是作用于此，我们新打开一个浏览器窗口，输入：http://localhost:8001/actuator/hystrix.stream，可以看到一直在刷一些信息，这些信息就是该服务相关接口的信息，但是很不直观，接下来我们看一下直观的效果。 1http://localhost:8001/actuator/hystrix.stream // Hystrix 流服务访问格式 在豪猪兄的页面输入 http://localhost:8001/actuator/hystrix.stream， delay延迟设置为2000（2秒），Title自己取个名字即可。打开后即可在可视化页面监控 8001 这个端口的接口调用信息，我们调用两个接口： 12http://localhost:8001/provider/order/get/1http://localhost:8001/provider/order/get/list 多刷新几次调用，可以看到可视化界面的一些信息，如下： Hystrix dashboard 面板正常显示，所监控的接口方法上必须要有 @HystrixCommand 注解，否则会一直显示 Loading，这是一个注意的地方。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"Hystrix 熔断器","slug":"SpringCloud/Hystrix 熔断器","date":"2019-03-18T16:00:00.000Z","updated":"2020-02-10T03:04:05.784Z","comments":true,"path":"2019/03/19/SpringCloud/Hystrix 熔断器/","link":"","permalink":"http://yoursite.com/2019/03/19/SpringCloud/Hystrix%20%E7%86%94%E6%96%AD%E5%99%A8/","excerpt":"","text":"Hystrix 熔断器 Hystrix 的作用就相当于家庭电路的保险丝，当出现任何异常的时候，他就会来来帮我们处理异常。 Hystrix 是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多服务无法避免会调用失败，比如超时、异常等等，Hystrix 能够保证在一个服务出现问题的情况下，不会导致整体服务的失败，避免级联故障，以提高分布式系统的弹性。 那么当某个服务发生故障时，通过 Hystrix，会向调用方返回一个符合预期的、可处理的默认响应（也称备选响应，即fallBack），而不是长时间的等待或者直接返回一个异常信息。 服务熔断和服务降级服务熔断服务熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应时间太长，就会进行服务的降级，快速熔断该节点微服务的调用，返回默认的响应信息。当检测到该节点微服务调用响应正常后即可恢复。 服务降级上面提到服务的降级，什么意思呢？我打个比方： 比如你去银行办理业务，本来有四个窗口都可以办理，现在3号窗口和4号窗口的办理人员有事要离开，那么自然地，用户就会跑去1号窗口或者2号窗口办理，所以1号和2号窗口就会承担更多的压力。 3号窗口和4号窗口的人有事走了，不能让人还在这排队等着吧，否则就出现了上文说的雪崩了，所以会挂一个牌子：暂停服务。这个牌子好比上文提到的熔断，然后返回一个默认的信息，让用户知道。等3号和4号窗口的人回来了，就会把这个牌子拿走，这两个窗口又可以继续回复服务了。 Hystrix 熔断器的使用每一个接口必须加 @HystrixCommand 注解，标明如果接口出现错误，就会使用 Hystrix 熔断器来处理。 消费者添加hystrix依赖12345&lt;!-- Hystrix 熔断器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 修改Boot应用入口消费者启动入口类，添加 @EnableCircuitBreaker，开启断路器功能 123456789@EnableCircuitBreaker //开启断路器功能@SpringBootApplication@EnableEurekaClient public class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; 修改 Controller 层添加 @HystrixCommand 注解 然后我们创建一个 HelloController 类，如下： 即是请求失败时，就会由 Hystrix 自动调用 error 方法 通过 fallbackMethod 属性指定出现错误时调用的方法 1234567891011121314public class HelloController &#123; @Autowired private RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \"error\") public String hello() &#123; ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(\"http://HELLO-SERVICE/hello\", String.class); return responseEntity.getBody(); &#125; public String error() &#123; return \"不好意思，暂时无法接通。。\"; // 可以自定义复杂的方法 &#125;&#125; 思考@HystrixCommand 注解是加在 Controller 层的接口方法上的，这会导致两个问题： 如果接口方法很多，那么我是不是要在每个方法上都得加上该注解，而且，针对每个方法，我都要指定一个处理函数，这样会导致 Controller 变得越来越臃肿。 这也不符合设计规范，理论上来说，Controller 层就是 Controller 层，我只管写接口即可。就像上一节介绍的 Feign，也是面向接口的，做均衡处理，我自己定义一个接口专门用来做均衡处理，在 Controller 层将该接口注入即可。那么 hystrix 是否也可以有类似的处理呢？ 答案是肯定的，这跟面向切面编程一个道理，Cotroller 你只管处理接口逻辑，当出了问题，OK，交给我 hystrix ，我 hystrix 不在你 Controller 这捣蛋，我去其他地方呆着，你有问题了，我再来处理。这才是正确的、合理的设计方式。 定义 Hystrix 处理类，绑定 Feign 接口我们新建一个 hystrix 处理类：HelloServiceFallbackFactory，要实现 FallbackFactory 接口，其中 HelloService 就是前面定义的 Feign 接口的名称。（与Feign接口完成了绑定） 也就是说，把 hystrix 和 feign 绑定起来，因为都是客户端的东东。我通过 feign 去调用服务的时候，如果出问题了，就来执行我自定义的 hystrix 处理类中的方法，返回默认数据。代码如下： 1234567891011121314151617181920212223** * 统一处理熔断 * HelloService 是Feign接口，所有访问都会走feign接口 * @author yangfa */@Componentpublic class HelloServiceFallbackFactory implements FallbackFactory&lt;HelloService&gt; &#123; @Override public HelloService create(Throwable throwable) &#123; return new HelloService() &#123; /** * 当HelloService服务的hello()方法出异常后的熔断处理方法 * @return 返回信息 */ @Override public String hello() &#123; return \"不好意思，暂时无法接通。。\" &#125; &#125;; &#125;&#125; OK，现在 hystrix 是绑定了 Feign 接口了，但是 Feign 接口中的某个方法如果出问题了，它怎么知道找谁去做熔断呢？ 给 Feign 指定 hystrixFeign 接口也需要绑定一下我们定义的 hystrix 处理类： 1234567@FeignClient( value = \"hellospringCloudService\", //绑定生产者在yml中定义的服务名 fallbackFactory = HelloServiceFallbackFactory.class) // 绑定 Hystrix 处理类public interface HelloService &#123; //这里的RequestMapping里面的值 一定要跟 生产者中的方法路径对应 @RequestMapping(\"/test\") String hello();&#125; YML 中开启熔断1234# 开启熔断feign: hystrix: enabled: true","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"Feign 接口声明式服务调用","slug":"SpringCloud/Feign 接口声明式服务调用","date":"2019-03-17T16:00:00.000Z","updated":"2020-02-10T03:18:34.091Z","comments":true,"path":"2019/03/18/SpringCloud/Feign 接口声明式服务调用/","link":"","permalink":"http://yoursite.com/2019/03/18/SpringCloud/Feign%20%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/","excerpt":"","text":"Feign 接口声明式服务调用 使用Feign 只需要创建一个接口和一个注解。 出现 Feign 的原因在使用Ribbon的时候，在controller中定义了一段服务地址 12345678910111213141516@RestController@RequestMapping(\"/\")public class Consumer &#123; // 通过注册到 Eureka 中的微服务名称进行访问 private static final String REST_PREFIX = \"http://HELLOSPRINGCLOUDSERVICE\"; @Autowired RestTemplate restTemplate; @RequestMapping(\"consumer/testHello\") // 访问的是 服务提供者的 /test 请求 public String testHello()&#123; return restTemplate.getForObject(REST_PREFIX+\"/test\",String.class); &#125;&#125; 这样做虽然对每个请求的访问地址很清晰，却不太好，当微服务逐渐多了起来的时候，工作量也会变大，出现Feign之后，就是面向接口编程了。 简化了RestTemplate + ribbon 的开发方式，进一步封装。 消费者导入依赖12345&lt;!-- feign 负载均衡 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 配置YML123456789server: port: 80eureka: client: service-url: defaultZone: http://localhost:1111/eureka #绑定Eureka 服务中心，将自己注册到服务中心spring: application: name: feign-consumer #消费者服务名字 修改Boot应用入口在工程的入口类上添加 @EnableFeignClients 注解表示开启Spring Cloud Feign的支持功能，如下： 12345678@EnableFeignClients //开启 Feign 支持@EnableEurekaClient //开启 Eureka 客户端@SpringBootApplicationpublic class FeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignApplication.class, args); &#125;&#125; 创建接口，声明绑定服务定义一个 HelloService 接口，通过 @FeignClient 注解来 与 指定微服务名 进行绑定，然后再通过SpringMVC中提供的注解来绑定服务提供者提供的接口，如下： 123456@FeignClient(\"hellospringCloudService\") //绑定服务提供者在yml中定义的服务名public interface HelloService &#123; //这里的RequestMapping里面的值 一定要跟 生产者中的方法路径一一对应 @RequestMapping(\"/test\") String hello();&#125; 调用服务提供者这里的/hello，其实是访问了HelloService 中配置的方法入口 实际是访问名为 hellospringCloudService 微服务里面的 /test 请求 既是 controller 调用了 Feign 接口中的hello() 方法，Feign 中的 hello() 方法，与其接口上绑定的微服务名的指定请求路径为/test的方法是绑定的。 这样通过接口与注解就与微服务绑定在一起了 1234567891011@RestControllerpublic class FeignConsumerController &#123; @Autowired HelloService helloService; @RequestMapping(\"/hello\") public String hello() &#123; return helloService.hello(); &#125;&#125; 服务提供者代码如下： 测试浏览器访问 http://localhost:80/hello Feign 如何结合 Ribbon 切换均衡算法Feign 的存在，相当与是通过接口，做了一个中间层，使得每一个服务对应一个接口，这样便于管理，最好访问路径都一致，便于排错。 那么使用 Feign 的时候，如何去切换到 Ribbon 中其他均衡策略呢？甚至切换到自定义的策略呢？也很简单，我们可以在 application.yml 配置文件中来指定，如下： 当这个消费者去访问如下微服务是，使用什么负载均衡算法 1234# feign和 ribbon结合，指定策略。feign默认的是轮询的策略，这里的配置可以自定义hellospringCloudService: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule hellospringCloudService 表示作用到哪个微服务，写 yml 中配置的微服务名字就好 com.netflix.loadbalancer.RandomRule 即前面介绍 Ribbon 时里面的随机策略，当然，我们也可以指定为其他策略，包括我们自己定义的，只要把相应的包路径写到这即可，很方便。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"Ribbon 负载均衡算法","slug":"SpringCloud/Ribbon 负载均衡算法","date":"2019-03-16T16:00:00.000Z","updated":"2020-02-09T13:40:26.022Z","comments":true,"path":"2019/03/17/SpringCloud/Ribbon 负载均衡算法/","link":"","permalink":"http://yoursite.com/2019/03/17/SpringCloud/Ribbon%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/","excerpt":"","text":"Ribbon 负载均衡算法Ribbon 默认是轮询算法（RoundRobinRule），即当有消费者请求时，会依次派给生产者，每个生产者仅接受一次请求。 但是在 Ribbon 中，可以自定义负载均衡算法，用到 IRule 。 Ribbon 中默认的7种负载均衡算法 切换负载均衡算法在配置 RestTemplate 类中添加 @LoadBalanced 注解，并且 加入 IRule 类 123456789101112131415@Configurationpublic class BeanConfig &#123; @LoadBalanced //使这个传递类访问时 开启负载均衡 @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125; @Bean // 手动定义随机算法 public IRule getRule()&#123; return new RandomRule(); &#125;&#125; 自定义负载均衡算法在主类添加 @RibbonClient 让消费者在启动的时候，就使用自定义的负载均衡算法 ​ 也就是不能放在SpringBoot能够扫描的包下面 负载均衡算法类在与启动类同层的目录下，建立rule包，创建MyRule类，避免被 SpringBoot 启动就扫描到。 12345678@Configurationpublic class MyRule &#123; @Bean public IRule getRule()&#123; return new RandomRule(); //默认轮询，自定义为随机 &#125;&#125; 启动类上使用自定义的算法12345678910@SpringBootApplication@EnableEurekaClient// 为这个指定的微服务使用 我们自定义的负载均衡算法@RibbonClient(name = \"HELLOSPRINGCLOUDSERVICE\",configuration = MyRule.class)public class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125;","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"Ribbon 客户端的负载均衡","slug":"SpringCloud/Ribbon 客户端的负载均衡","date":"2019-03-15T16:00:00.000Z","updated":"2020-02-10T03:19:04.439Z","comments":true,"path":"2019/03/16/SpringCloud/Ribbon 客户端的负载均衡/","link":"","permalink":"http://yoursite.com/2019/03/16/SpringCloud/Ribbon%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"Ribbon 客户端的负载均衡将客户端的请求平均的分配多个服务器上，保证合理的资源调用。 Ribbon是一个基于 HTTP 和 TCP 的客户端负载均衡器，当我们将 Ribbon 和 Eureka 一起使用时，Ribbon 会从Eureka注册中心去获取服务端列表，然后进行轮询访问以到达负载均衡的作用。 服务端是否在线这些问题则交由Eureka去维护。 Ribbon 依赖Ribbon是客户端的负载均衡，所以在消费者模块添加依赖 12345&lt;!-- Ribbon 客户端负载均衡 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 修改消费者YML绑定Eureka服务中心，通过 Eureka 访问，不再是通过绝对地址访问了。 123456789server: port: 80eureka: client: service-url: defaultZone: http://localhost:1111/eureka #绑定Eureka 服务中心，将自己注册到服务中心spring: application: name: Ribbon-consumer #消费者服务名字 修改 RestTemplate在注册 RestTemplate 类上添加 @LoadBalanced 注解，开启负载均衡 123456789@Configurationpublic class BeanConfig &#123; @LoadBalanced //使这个传递类访问时 开启负载均衡 @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; 修改主启动类在主启动类添加 @EnableEurekaClient ，开启 Eureka 客户端服务 12345678@SpringBootApplication@EnableEurekaClient //本服务注册到Eureka服务注册中心public class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; 修改消费者 controller 类通过微服务访问 12//之前通过绝对地址访问private static final String REST_PREFIX = \"http://localhost:9090\"; 修改后 12345678910111213141516@RestController@RequestMapping(\"/\")public class Consumer &#123; // 通过注册到 Eureka 中的微服务名称进行访问 private static final String REST_PREFIX = \"http://HELLOSPRINGCLOUDSERVICE\"; @Autowired RestTemplate restTemplate; @RequestMapping(\"consumer/testHello\") // 访问的是 服务提供者的 /test 请求 public String testHello()&#123; return restTemplate.getForObject(REST_PREFIX+\"/test\",String.class); &#125;&#125; 测试浏览器访问 http://localhost/consumer/testHello 这样就通过Eureka 与 Ribbon 整合后，访问成功，此时Eureka 服务中心 发现一个消费者，一个生产者。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"Eureka 集群的搭建","slug":"SpringCloud/Eureka 集群的搭建","date":"2019-03-14T16:00:00.000Z","updated":"2020-02-09T13:38:39.043Z","comments":true,"path":"2019/03/15/SpringCloud/Eureka 集群的搭建/","link":"","permalink":"http://yoursite.com/2019/03/15/SpringCloud/Eureka%20%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Eureka 集群的搭建创建配置文件之前创建了一个名叫 eureka-server 的服务注册中心，现在在这个工程中添加两个配置文件application-peer1.properties 和 application-peer2.properties： 两个配置文件的内容分别如下： application-peer1.properties: 12345server.port=1111eureka.instance.hostname=peer1eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.service-url.defaultZone=http://peer2:1112/eureka/ application-peer2.properties: 12345server.port=1112eureka.instance.hostname=peer2eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.service-url.defaultZone=http://peer1:1111/eureka/ 关于这两个配置文件我说如下几点： 在peer1的配置文件中，让它的service-url指向peer2，在peer2的配置文件中让它的service-url指向peer1 为了让peer1和peer2能够被正确的访问到，我们需要在C:\\Windows\\System32\\drivers\\etc目录下的hosts文件总添加两行配置，如下: 12127.0.0.1 peer1 127.0.0.1 peer2 由于peer1和peer2互相指向对方，实际上我们构建了一个双节点的服务注册中心集群 生成jar文件 启动项目生成jar文件之后，我们在命令行通过java命令来启动项目，在启动的时候我们可以设置采用不同的配置文件来启动项目，命令如下： 12java -jar eureka-server-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1 java -jar eureka-server-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2 用浏览器访问 http://localhost:1112/ 与 http://localhost:1111/ 因为刚刚已经在host中把peer1 peer2 与 localhost 对了映射，所以dns服务器能找到这个地址，在peer1的页面能看到peer2，peer2的页面能看到peer1。 测试修改服务提供者模块的配置文件，在service-url中添加了两个注册中心地址，两个地址中间用”逗号”隔开，如下： 1eureka.client.service-url.defaultZone=http://peer1:1111/eureka,http://peer2:1112/eureka","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"注册服务消费者","slug":"SpringCloud/注册服务消费者","date":"2019-03-13T16:00:00.000Z","updated":"2020-02-10T03:18:12.530Z","comments":true,"path":"2019/03/14/SpringCloud/注册服务消费者/","link":"","permalink":"http://yoursite.com/2019/03/14/SpringCloud/%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/","excerpt":"","text":"注册服务消费者已经在 Eureka 服务中心 注册了 服务提供者，现在我们写一个消费者模块来使用服务。 创建一个新的Spring Boot工程，选择Web模块 添加Eureka依赖12345678910111213141516171819202122232425262728&lt;!-- springCloud启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- eureka 客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 配置YML12server: port: 80 # 消费者的端口 使用RestTemplateRestTemplate 简化了 Http 请求的方式，通过这个类可以把请求转发，这里的消费者就是通过 RestTemplate 把请求转发到对应的生产者，让生产者提供服务。 注册 RestTemplate123456@Configurationpublic class BeanConfig &#123; @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125; 使用 RestTemplate使用 RestTemplate，进行绝对地址访问，没有通过Eureka 123456789101112131415@RestController@RequestMapping(\"/\")public class Consumer &#123; private static final String REST_PREFIX = \"http://localhost:9090\"; // 服务提供者的端口 @Autowired RestTemplate restTemplate; @RequestMapping(\"consumer/testHello\") // 访问的是 服务提供者的 /test 请求 public String testHello()&#123; return restTemplate.getForObject(REST_PREFIX+\"/test\",String.class); &#125;&#125; 测试浏览器访问 http://localhost/consumer/testHello 访问 消费者 的 controller，由 RestTemplate 转发http请求 到 生产者，由 生产者 提供服务。 这样一组 流程我们就走完了。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"注册服务提供者","slug":"SpringCloud/注册服务提供者","date":"2019-03-12T16:00:00.000Z","updated":"2020-02-10T05:37:43.373Z","comments":true,"path":"2019/03/13/SpringCloud/注册服务提供者/","link":"","permalink":"http://yoursite.com/2019/03/13/SpringCloud/%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85/","excerpt":"","text":"注册服务提供者现在服务注册中心有了之后，我们可以考虑向这个服务注册中心注册一个服务提供者了，即是生产者。 创建一个新的Spring Boot工程，选上Web功能就可以了 添加Eureka依赖在创建好的工程中，我们需要添加Eureka依赖，添加方式如下： 12345678910111213141516171819202122232425262728&lt;!-- springCloud启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- eureka 客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 修改Boot应用入口添加 @EnableEurekaClient注解， 激活服务 这是一个web工程，所以我们添加一个 Controller，在该 Controller 中提供一个访问入口。 123456789101112@RequestMapping(\"/\")@RestControllerpublic class HelloController &#123; @Autowired private DiscoveryClient discoveryClient; @GetMapping(\"/test\") public String hello ()&#123; return \"test server privider\"; &#125;&#125; 在Spring Boot的入口类上添加一个 @EnableEurekaClient 1234567@EnableEurekaClient //本服务注册到Eureka服务注册中心@SpringBootApplicationpublic class ServerProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 配置YML最后的最后，我们在 application.yml 文件中配置一下服务名称和注册中心地址即可，如下： 最后一个参数指向服务中心地址，把自己注册到Eruka服务注册中心。 123456789server: port: 9090 #服务的端口spring: application: name: helloSpringCloudService #服务的名字eureka: client: service-url: defaultZone: http://localhost:1111/eureka #注册到某个服务中心的地址,之前的Eureka 服务中心地址 ​ 直接运行这个Spring Boot工程，运行成功之后，我们刷新刚才的 http://localhost:1111 就可以看到有一个服务已经注册成功了。 如下：","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"Eureka 服务中心","slug":"SpringCloud/Eureka 服务中心","date":"2019-03-11T16:00:00.000Z","updated":"2020-02-10T05:37:37.960Z","comments":true,"path":"2019/03/12/SpringCloud/Eureka 服务中心/","link":"","permalink":"http://yoursite.com/2019/03/12/SpringCloud/Eureka%20%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%BF%83/","excerpt":"","text":"注册服务中心 EurekaEureka 简介 Eureka 服务注册中心（Eureka Server），提供服务的注册与发现，服务提供者把服务注册到服务中心，服务消费者通过服务中心使用服务，Eureka 相当于Spring 管理 Bean一样管理服务。 Eureka 使用，添加Eureka依赖首先我们需要创建一个普通的Spring Boot工程，命名为eureka-server，普通到什么程度呢?就是一个starter都不需要添加 12345678910111213141516171819202122232425262728&lt;!-- springCloud启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- eureka-server 服务端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 修改Boot应用入口启动一个服务注册中心的方式很简单，就是在Spring Boot的入口类上添加一个 @EnableEurekaServer 注解，如下： 12345678import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer //eurekaServer 启动类，接受其他服务进来@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 配置服务注册中YML最后我们再做一点简单的配置就可以了，配置就写在Spring Boot的配置文件application.yml中，写法如下： 1234567891011server: port: 1111eureka: instance: hostname: localhost client: register-with-eureka: false # 是否将自己注册到Eureka Server， 默认为true。 由于当前应用就是Eureka Server， 因此设为 false。 fetch-registry: false # 是否从Eureka Server获取注册信息，默认为true。 如果这是一个单点的 Eureka Server，不需要同步其他节点的数据，可以设为false。 service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 说明： server.port=1111表示设置该服务注册中心的端口号 eureka.instance.hostname = localhost 表示设置该服务注册中心的 hostname eureka.client.register-with-eureka = false,由于我们目前创建的应用是一个服务注册中心，而不是普通的应用，默认情况下，这个应用会向注册中心（也是它自己）注册它自己，设置为false表示禁止这种默认行为 eureka.client.fetch-registry = false，表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它也不需要去检索其他服务 eureka.client.register-with-eureka 与 eureka.client.fetch-registry 设置为true时，是对生产者与消费者设置，而不是服务中心 ！！默认都为ture！！ 测试OK，做完这一切之后，我们就可以启动这一个Spring Boot 服务，服务启动成功之后，在浏览器中输入: http://localhost:1111 就能够看到如下页面: 看到上面这个页面之后，表示你的服务注册中心已经搭建好了。 Eureka中细节的完善修改主机映射名 在服务yml配置中添加 123eureka: instance: instance-id: xxxxxxxxxx #一般是服务名称-端口号 修改ip地址123eureka: instance: prefer-ip-address: true #访问路径显示ip地址 Eureka的自我保护机制 关闭自我保护机制，建议不要关闭！！！ 123eureka: server: enable-self-preservation: false","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"消费者模式","slug":"JAVA/多线程/消费者模式","date":"2019-01-04T16:00:00.000Z","updated":"2020-01-11T13:45:30.593Z","comments":true,"path":"2019/01/05/JAVA/多线程/消费者模式/","link":"","permalink":"http://yoursite.com/2019/01/05/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"需求​ 车站有30张票，现在用3个窗口在进行卖票服务，现在用 ReentrantLock 与 synchronized 分别来实现。 分析​ 资源类的编写标准 高内聚 ，我们把票写出一个类，在类中有卖票的操作。 ​ 由于是多线程（3个窗口去买票），我们需要使用多线程代码编写标准： try前加锁 lock try里操作 对 临界资源 操作 finally解锁 unlock 两种实现方式对比Synchronized 实现资源类 用 synchronized 关键字给 卖票的方法加上锁。 1234567891011121314// 票就是一个资源class Tiket&#123; private int number = 30; // 初始30张票，3个线程同时去卖这30张票，票既为临界资源 //访问 临界资源 的代码 ，就是临界区 public synchronized void sale()&#123; try &#123; if (number &gt; 0)&#123; // 对 临界资源 操作 System.out.println(Thread.currentThread().getName()+\"\\t卖出第：\"+(number--)+\"\\t 还剩下：\"+number); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 主程序123456789public static void main(String[] args) &#123; // 初始化30张票 Tiket tiket = new Tiket(); // 三个线程开始等待cpu调度卖票 new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 40; i++) tiket.sale(); &#125;,\"AAA\").start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 40; i++) tiket.sale(); &#125;,\"BBB\").start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 40; i++) tiket.sale(); &#125;,\"CCC\").start();&#125; ReentrantLock 实现ReentrantLock 在资源类中维护了一个示例，通过这个示例手动的实现加锁，解锁。 因为是一个消费者，所以不需要使用 Condition 来区分，直接加锁就ok。 资源类12345678910111213141516171819// 票就是一个资源class Tiket&#123; private int number = 30; // 初始30张票，3个线程同时去卖这30张票，票既为临界资源 private final Lock lock = new ReentrantLock(); // 得到可重入锁 //访问 临界资源 的代码 ，就是临界区 public void sale()&#123; lock.lock(); // 加锁 try &#123; if (number &gt; 0)&#123; // 对 临界资源 操作 System.out.println(Thread.currentThread().getName()+\"\\t卖出第：\"+(number--)+\"\\t 还剩下：\"+number); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); // 解锁 &#125; &#125;&#125; 主程序123456789public static void main(String[] args) &#123; // 初始化30张票 Tiket tiket = new Tiket(); // 三个线程开始等待cpu调度卖票 new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 40; i++) tiket.sale(); &#125;,\"AAA\").start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 40; i++) tiket.sale(); &#125;,\"BBB\").start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 40; i++) tiket.sale(); &#125;,\"CCC\").start();&#125; 运行结果","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多个生产者与多个消费者","slug":"JAVA/多线程/多个生产者与多个消费者","date":"2019-01-04T16:00:00.000Z","updated":"2020-02-04T05:12:19.891Z","comments":true,"path":"2019/01/05/JAVA/多线程/多个生产者与多个消费者/","link":"","permalink":"http://yoursite.com/2019/01/05/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E4%B8%AA%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E5%A4%9A%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85/","excerpt":"","text":"需求​ 多个线程，操作一个初始值为 0 的变量，生产者与消费者谁抢到CPU执行权，谁就工作，不再需要依次交替进行。 分析​ 资源类的编写标准 高内聚 ，我们把需求具象话一个做蛋糕的点，在类中有生产蛋糕与购买蛋糕的互逆操作，不是依次进行。 try前加锁 lock try里操作 对 临界资源 操作 finally解锁 unlock 两种实现方式对比Synchronized 实现资源类1234567891011121314151617181920212223242526272829class Cake&#123; // 资源类 private int num = 0; // 生产蛋糕的方法 public synchronized void add() throws InterruptedException &#123; // 判断 if(num != 0) &#123; this.wait(); // 线程等待 &#125; // 操作 num++; System.out.println(Thread.currentThread().getName()+\"生产了一个蛋糕\"+\"目前总共有：\"+num+\"个!\"); // 通知 this.notifyAll(); // 唤醒所有等待的线程 &#125; // 消费蛋糕的问题 public synchronized void reduce() throws InterruptedException &#123; // 判断 if (num == 0)&#123; this.wait(); // 线程等待 &#125; // 操作 num--; System.out.println(Thread.currentThread().getName()+\"购买了1个蛋糕，\"+\"还剩下\"+num+\"个！\"); // 通知 this.notifyAll(); // 唤醒所有等待的线程 &#125;&#125; 主程序12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Cake cake = new Cake(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 10 ; i++) &#123; try &#123; cake.add(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"生产者1\").start(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 10 ; i++) &#123; try &#123; cake.reduce(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"消费者1\").start(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 10 ; i++) &#123; try &#123; cake.add(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"生产者2\").start(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 10 ; i++) &#123; try &#123; cake.reduce(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"消费者2\").start();&#125; 出现问题，虚假唤醒！！！虚假唤醒，if 只判断一次，通过后，便不再判断。。。 多线程中出现的常见问题， 通过 if 后，在还没有对临界资源操作的时候，失去了CPU的执行权（Wait），进入等待状态。 此时同类型的线程抢到了CPU的执行权，临界资源没有变化，他也进入了同样的逻辑（消费蛋糕），对临界资源操作，然后释放CPU。 之前通过 if 条件的等待状态的线程被唤醒后，还是会执行对临界资源进行操作，所以就出现了复数。 解决虚假唤醒问题的办法使用 synchronized 需要配合 while 使用，否则出现虚假唤醒。 当我们把 if 换成 while 时 123456789101112131415161718192021222324252627class Cake&#123; // 资源类 private int num = 0; public synchronized void add() throws InterruptedException &#123; // 判断， 换成 While 判断后，通过的线程在被唤醒时还会被拉回来判断一次 while(num != 0) &#123; this.wait(); // 线程等待 &#125; // 操作 num++; System.out.println(Thread.currentThread().getName()+\"生产了一个蛋糕\"+\"目前总共有：\"+num+\"个!\"); // 通知 this.notifyAll(); // 唤醒所有等待的线程 &#125; public synchronized void reduce() throws InterruptedException &#123; // 判断， 换成 While 判断后，通过的线程在被唤醒时还会被拉回来判断一次 while (num == 0)&#123; this.wait(); // 线程等待 &#125; // 操作 num--; System.out.println(Thread.currentThread().getName()+\"购买了1个蛋糕，\"+\"还剩下\"+num+\"个！\"); // 通知 this.notifyAll(); // 唤醒所有等待的线程 &#125;&#125; 程序又一切正常了！！！ 即是 之前通过 判断后，还没操作的线程，再次得到CPU的执行权时，因为条件是while，会被拉回来再判断一次。 ReentrantLock 实现资源类精确唤醒对立方线程，不再浪费CPU资源去唤醒所有线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 资源类class Cake&#123; private int number = 0; // 临界资源 private Lock lock = new ReentrantLock(); private Condition producer = lock.newCondition(); // 生产者条件 private Condition customer = lock.newCondition(); // 消费者条件 public void increment()&#123; lock.lock(); try &#123; // 判断 while (number != 0)&#123; producer.await(); // 生产者等待 &#125; // 操作 number++; System.out.println(Thread.currentThread().getName()+\"生产了一个蛋糕\"+\"目前总共有：\"+number+\"个!\"); // 通知消费者 customer.signalAll(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void decrement()&#123; lock.lock(); try &#123; // 判断 while (number == 0)&#123; customer.await(); // 消费者等待 &#125; // 操作 number--; System.out.println(Thread.currentThread().getName()+\"购买了1个蛋糕，\"+\"还剩下\"+number+\"个！\"); // 通知生产者 producer.signalAll(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 主程序1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) &#123; Cake cake = new Cake(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 100 ; i++) &#123; try &#123; cake.increment(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"生产者1\").start(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 100 ; i++) &#123; try &#123; cake.decrement(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"消费者1\").start(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 100 ; i++) &#123; try &#123; cake.increment(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"生产者2\").start(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 100 ; i++) &#123; try &#123; cake.decrement(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"消费者2\").start();&#125; 思考​ 我们在 Synchronized 中使用 if ，会发生虚假唤醒。 ​ 那么在 ReentrantLock 中使用 if ，会发生什么情况呢? ​ 下面我们改一下代码，把 while 全部替换成 if 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 资源类class Cake&#123; private int number = 0; // 临界资源 private Lock lock = new ReentrantLock(); private Condition producer = lock.newCondition(); // 生产者条件 private Condition customer = lock.newCondition(); // 消费者条件 public void increment()&#123; lock.lock(); try &#123; // 判断 if (number != 0)&#123; producer.await(); // 生产者等待 &#125; // 操作 number++; System.out.println(Thread.currentThread().getName()+\"生产了一个蛋糕\"+\"目前总共有：\"+number+\"个!\"); // 通知消费者 customer.signalAll(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void decrement()&#123; lock.lock(); try &#123; // 判断 if (number == 0)&#123; customer.await(); // 消费者等待 &#125; // 操作 number--; System.out.println(Thread.currentThread().getName()+\"购买了1个蛋糕，\"+\"还剩下\"+number+\"个！\"); // 通知生产者 producer.signalAll(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 结果截图 依然是出现了虚假唤醒，在 ReentrantLock 中，依然要避免使用 if 关键字！！！ 多线程代码编写总结高内聚，低耦合，线程，资源，操作，While try前加锁 lock try里操作 对 临界资源 操作 finally解锁 unlock 判断 操作 通知","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"一个生产者与一个消费者","slug":"JAVA/多线程/一个生产者与一个消费者","date":"2019-01-04T16:00:00.000Z","updated":"2020-02-04T05:12:10.563Z","comments":true,"path":"2019/01/05/JAVA/多线程/一个生产者与一个消费者/","link":"","permalink":"http://yoursite.com/2019/01/05/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%B8%80%E4%B8%AA%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E4%B8%80%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85/","excerpt":"","text":"需求​ 两个线程，操作一个初始值为 0 的变量，生产一个，消费一个，这样交互循环30次，保证这个变量还是 0 。 分析​ 资源类的编写标准 高内聚 ，我们把需求具象话一个做蛋糕的点，在类中有生产蛋糕与购买蛋糕的互逆操作。 try前加锁 lock try里操作 对 临界资源 操作 finally解锁 unlock 两种实现方式对比Synchronized 实现资源类​ 在每个方法上面使用 synchronized 关键字加锁 1234567891011121314151617181920212223242526272829class Cake&#123; // 资源类 private int num = 0; // 生产蛋糕的方法 public synchronized void add() throws InterruptedException &#123; // 判断 if(num != 0) &#123; this.wait(); // 线程等待 &#125; // 操作 num++; System.out.println(Thread.currentThread().getName()+\"生产了一个蛋糕\"+\"目前总共有：\"+num+\"个!\"); // 通知 this.notify(); // 唤醒等待的线程 &#125; // 消费蛋糕的问题 public synchronized void reduce() throws InterruptedException &#123; // 判断 if (num == 0)&#123; this.wait(); // 线程等待 &#125; // 操作 num--; System.out.println(Thread.currentThread().getName()+\"购买了1个蛋糕，\"+\"还剩下\"+num+\"个！\"); // 通知 this.notify(); // 唤醒等待的线程 &#125;&#125; 主程序12345678910111213141516171819202122public static void main(String[] args) &#123; Cake cake = new Cake(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 30 ; i++) &#123; try &#123; cake.add(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"生产者\").start(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 30 ; i++) &#123; try &#123; cake.reduce(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"消费者\").start();&#125; ReentrantLock 实现由于 出现了生产者与消费者，所有需要用我们的锁创造两个代表着生产者与消费者的Condition 12Condition producer = lock.newCondition(); // 生产者条件Condition customer = lock.newCondition(); // 消费者条件 资源类123456789101112131415161718192021222324252627282930313233343536373839404142434445// 资源类class Cake2&#123; private int number = 0; // 临界资源 private final Lock lock = new ReentrantLock(); private final Condition producer = lock.newCondition(); // 生产者条件 private final Condition customer = lock.newCondition(); // 消费者条件 public void increment()&#123; lock.lock(); try &#123; // 判断 if (number != 0)&#123; producer.await(); // 生产者等待 &#125; // 操作 number++; System.out.println(Thread.currentThread().getName()+\"生产了一个蛋糕\"+\"目前总共有：\"+number+\"个!\"); // 通知消费者 customer.signal(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void decrement()&#123; lock.lock(); try &#123; // 判断 if (number == 0)&#123; customer.await(); // 消费者等待 &#125; // 操作 number--; System.out.println(Thread.currentThread().getName()+\"购买了1个蛋糕，\"+\"还剩下\"+number+\"个！\"); // 通知生产者 producer.signal(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 主程序1234567891011121314151617181920212223public static void main(String[] args) &#123; Cake2 cake = new Cake2(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 30; i++) &#123; try &#123; cake.increment(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;, \"生产者\").start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 30; i++) &#123; try &#123; cake.decrement(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;, \"消费者\").start(); &#125; 运行结果","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"ReentrantLock","slug":"JAVA/多线程/ReentrantLock","date":"2019-01-03T16:00:00.000Z","updated":"2020-02-04T05:12:15.159Z","comments":true,"path":"2019/01/04/JAVA/多线程/ReentrantLock/","link":"","permalink":"http://yoursite.com/2019/01/04/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ReentrantLock/","excerpt":"","text":"ReentrantLock​ JUC中出现了可重入锁（ReentrantLock），用来替换在JDK1.5之前被大量使用的 synchronized 。 他们的异同有以下三点： 独占锁ReentrantLock 和 synchronized 都是 独占锁，只允许线程互斥的访问临界区。但是实现上两者不同: synchronized 加锁解锁的过程是隐式的，用户不用手动操作，优点是操作简单，但显得不灵活。 ReentrantLock 需要手动加锁和解锁，且解锁的操作尽量要放在finally代码块中，保证线程正确释放锁。 ReentrantLock 操作较为复杂，但是因为可以手动控制加锁和解锁过程，其功能也较为强大。 可重入锁ReentrantLock 和 synchronized 都是可重入的。 一个线程请求得到一个对象锁后再次请求此对象锁，可以再次得到该对象锁。 公平锁ReentrantLock可以实现公平锁，公平锁是指当锁可用时，在锁上等待时间最长的线程将获得锁的使用。 非公平锁则随机分配这种使用权。 和 synchronized 一样，默认的 ReentrantLock 实现是非公平锁，因为相比公平锁，非公平锁性能更好。 在创建 ReentrantLock 的时候通过传进参数true创建公平锁，如果传入的是false或没传参数则创建的是非公平锁。 12Lock lock = new ReentrantLock(); //非公平锁Lock lock = new ReentrantLock(true); //公平锁 ReentrantLock 方法 getHoldCount() 查询当前线程获取此锁的次数，此线程执行 lock 方法的次数。 getQueueLength() 返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9。 getWaitQueueLength(Condition condition) 返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了 condition 对象的 await 方法，那么此时执行此方法返回 10。 hasWaiters(Condition condition) 查询是否有线程等待与此锁有关的给定条件（condition），对于指定 contidion 对象，有多少线程执行了 condition.await 方法。 hasQueuedThread(Thread thread) 查询给定线程是否等待获取此锁。 hasQueuedThreads() 是否有线程等待此锁。 isFair() 该锁是否公平锁。 isHeldByCurrentThread() 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true。 isLock() 此锁是否有任意线程占用。 lock() 加锁。 lockInterruptibly() 如果当前线程未被中断，获取锁。 tryLock() 尝试获得锁，仅在调用时锁未被线程占用，获得锁。 tryLock(long timeout, TimeUnit unit) 如果锁在给定等待时间内没有被另一个线程获取，则获取该锁。 ReentrantLock 代码示例 try前加锁 lock try里操作 对 临界资源 操作 finally解锁 unlock 12345678910111213// 资源类定义模板class X &#123; private final ReentrantLock lock = new ReentrantLock(); public void xxxxx() &#123; lock.lock(); // 加锁 try &#123; // 对临界资源的操作 &#125; finally &#123; lock.unlock(); // 解锁 &#125; &#125;&#125; Condition​ 首先我们需要明白 condition 对象是依赖于 lock 对象的，意思就是说condition 对象需要通过 lock 对象进行创建出来，根据不同的 Condition，把生产者、消费者线程区分开来。 12Condition producer = lock.newCondition(); // 生产者条件Condition customer = lock.newCondition(); // 消费者条件 下一篇文章，会给出使用 ReentrantLock 与 synchronized 的代码示例。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"线程的基本概念","slug":"JAVA/多线程/线程的基本概念","date":"2019-01-01T16:00:00.000Z","updated":"2020-02-04T05:12:47.431Z","comments":true,"path":"2019/01/02/JAVA/多线程/线程的基本概念/","link":"","permalink":"http://yoursite.com/2019/01/02/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"​ 在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程并发的工具包，JDK 1.5开始出现的。 线程的基本概念Thread1234567891011//当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）public static Thread.yield() //暂停一段时间public static Thread.sleep() //在一个线程中调用other.join(),将等待other执行完后才继续本线程。 public join() //后两个函数皆可以被打断public interrupte() 线程的状态​ 一般分为五种状态，初始状态（NEW），等待CPU调度（RUNNABLE），正在运行（RUNNING），等待（WAITING）,死亡（DEAD）。 高内聚​ 一个对象，能实现的所有的功能只有这个对象自己内部知道如何实现的，这个对象必须封装所有的操作方法，所有的操作都要它自己完成。 低耦合​ 即插即用就是低耦合的概念，U盘，鼠标，键盘 线程12345678new Thread(new Runnable() &#123; @Override public void run() &#123; // 对资源的操作的语句 &#125;&#125;).start();new Thread(() -&gt; &#123; 对资源的操作的语句 &#125;).start(); 资源锁是 用在 临界区 临界资源：一次仅允许一个进程使用的 共享资源 临界区：访问 临界资源 的那段代码称为 临界区，一旦进入临界区，必须执行以下步骤，防止线程出错。 线程间的通信​ 以下方法都来自与object类，因为object是所有类的父类所以每一个类都可以使用以下方法 ​ 线程的等待与唤醒又称为线程之间的通信，等待与唤醒机制是实现两个或多个线程在执行任务过程相互配合相互协作的一种技术。 void wait() 等待，让出cpu进入等待状态（如果一个线程内调用了该方法，那么该线程就停止运行，等待其他线程唤醒，或者其他线程调用notifAll方法） void notify() 唤醒，随机唤醒一个正在等待的线程，让其进入可运行状态（解除了调用wait方法线程的等待状态，让其变成可运行状态） void notifyAll() 唤醒所以进入等待状态的线程，让其都进入可运行状态 多线程代码标准 try前加锁 lock try里操作 对 临界资源 操作 finally解锁 unlock","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}]}