{"meta":{"title":"个人技术博客","subtitle":"记录了一些与JAVA相关的技术文章","description":"学习与工作总结","author":"杨发","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-11-30T06:41:57.000Z","updated":"2019-11-30T06:50:22.492Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-27T14:29:50.000Z","updated":"2019-11-30T06:51:06.039Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-11-30T06:42:05.000Z","updated":"2019-11-30T06:50:39.581Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构/Collection","slug":"数据结构/Collection","date":"2019-11-30T07:27:41.593Z","updated":"2019-11-30T07:27:45.934Z","comments":true,"path":"2019/11/30/数据结构/Collection/","link":"","permalink":"http://yoursite.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Collection/","excerpt":"","text":"CollectionCollection是一个接口，所有List、Map、Set都实现它 ArrayList123public class ArrayList&lt;E&gt;extends AbstractList&lt;E&gt;implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable 创建ArrayList时可以指定它的泛型，E表示集合。他有个构造方法： 1ArrayList(Collection&lt;? extends E&gt; c) 这个构造方法能直接将c中的元素提取并放在新的ArrayList的对象中。 主要的api： add(E e) 返回类型boolean；也有add(int index,E e) 返回类型为void addAll(Collection&lt;? extends E&gt; c) 将c中的所有元素追加至对象末尾，返回类型为boolean contains(E e) 是否包含e，返回类型boolean iterator() 返回类型是Iterator，这是一个迭代器，便于遍历出arrayList对象的所有数据；迭代器有两个重要方法：hasNext()和next()，hasNext()返回boolean，用于一直遍历iterator中的所有元素；next()返回是E类型，用于返回当前值 size() 返回int型 get(int index) 获得索引处的数 lastIndeOf(Object o) 获得最后一次出现o的索引 set(int index,E e) 返回索引处的源数据，并替换索引处数据 remove(int index) 删除索引处数据，并返回源数据 removeAll(Collection&lt;? extends E&gt; c) 删除所有包含c中的数据，返回boolean clear() 清空对象所有数据 HashSet123public class HashSet&lt;E&gt;extends AbstractSet&lt;E&gt;implements Set&lt;E&gt;, Cloneable, Serializable 他的构造方法中有一个： 1HashSet(Collection&lt;? extends E&gt; c) 和ArrayList的那个用集合对象作为参数的构造方法功能相似，就是将集合对象中的所有数据放入HashSet的对象中 主要api： isEmpty() 返回boolean iterator() 返回类型为Iterator，用来遍历HashSet对象中所有数据，同ArrayList的iterator()方法 size() 返回int型 add(E e) 返回boolean，将e添加至hashSet对象中（如果不存在的情况下） remove(Object o) 返回boolean，从hashSet对象中删除o contains(E e) 返回boolean clear() 清空数据 HashMap123public class HashMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt;implements Map&lt;K,V&gt;, Cloneable, Serializable HashMap的构造方法 1HashMap(Map&lt;? extends K,? extends V&gt; m) 主要api： put(K key,V value) 返回value，将key与value映射存入map size() 返回map元素的大小 get(K key) 返回map中key对应的value keySet() 返回map对象的key构成的set，方便遍历出所有的key；通过set的iterator()方法来遍历 values() 返回类型是Collection，返回map的所有value值；可以利用Set或List的带collection的构造方法来获得map中所有的value值 remove(K key) 返回key对应的value值，删除掉这个key-value映射 replace(K key,V value) 返回key对应的原value值，将原value值替换为参数的value clear() 清空map","categories":[],"tags":[]},{"title":"数据结构/队列","slug":"数据结构/队列","date":"2019-11-30T07:27:41.587Z","updated":"2019-11-30T07:27:46.252Z","comments":true,"path":"2019/11/30/数据结构/队列/","link":"","permalink":"http://yoursite.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/","excerpt":"","text":"栈与队列栈是限定仅在表尾进行插入和删除操作的线性表。队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表。 栈栈的操作顺序类似idea等软件的撤销按钮，后来的先返回。把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom）。栈是后进先出，LAST IN FIRST OUT，叫LIFO结构。 栈的顺序存储结构可以把栈想成线性表顺序存储结构的简化，简称顺序栈。把栈顶看成游标卡尺的游标，栈底固定位置，栈顶来回移动。 也可以看成子弹上膛。 两栈共享空间栈的存库空间必须事先定好，所以一般都会设计出合适的大小数组来处理。但是对于两个同类型的栈，我们可以做到最大限度利用他们的存储空间。 让第一个满了的栈的栈顶接上另一个未满栈的栈顶。使用这样的数据结构，通常是两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。如果不是两个具有相同数据类型的栈的，使用这个办法反而会使问题变复杂。 栈的的链式存储结构简称链栈。栈顶放在链表的头部，头指针和栈顶指针合二为一。对于链栈来说，基本不存在栈满的情况。 入栈操作： 123456789101112Status Push(LinkStack *S,SElemType e) &#123;//先创建一个需要插入的结点 LinkStackPtr s = (LinkStackPtr)malloc(sizeOf(StackNode)); //对s结点进行赋值和指向操作 s-&gt;data=e; //因为栈中的元素是从栈顶往栈底传递的，栈顶元素保存的下一结点的地址就是它下面一位元素 s-&gt;next=S-&gt;top; //对栈操作 S-&gt;top=s; S-&gt;count++; return ok;&#125; 如图所示： 出栈操作： 123456789101112131415Status Pop(LinkStack *S,SElemType *e)&#123; LinkStackPtr p; if(StackEmpty(*S)) return ERROR; //拿到栈顶的数据 *e=S-&gt;top-&gt;data; p=S-&gt;top; //将栈顶指针下移 S-&gt;top=S-&gt;top-&gt;next; //释放删除的结点 free(p); S-&gt;count--; return OK;&#125; 顺序栈和链栈的区别它们的时间复杂度是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定长度，可能会存在内存空间浪费问题，但是它存取时定位很方便，而链栈则要求每个元素都有指针域，这同时增加了内存开销，但对于栈的长度无限制。如果栈使用过程中元素变化不可预料，有时很小，有时非常大，那么最好用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。 栈的作用为何我们不用数组或者链表直接实现功能？因为栈的引入简化了程序设计的问题，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组，会需要分散精力去考虑数组的下标增减等细节问题，反而有掩盖了问题的本质。 栈的应用-递归关键词：斐波那契数列(Fibonacci) 迭代 递归 现在假设有一个数学函数： 打印前40位的斐波那契数列数，使用迭代，代码如下： 123456789101112131415int main()&#123; int i; int a[40]; a[0]=0; a[1]=1; printf(\"%d\",a[0]); printf(\"%d\",a[1]); for(i=2;i&lt;40;i++) &#123; a[i]=a[i-1]+a[i-2]; printf(\"%d\",a[i]); &#125; return 0;&#125; 使用迭代代码简单，容易理解，但是过于冗长。 使用递归： 123456789101112131415int Fbi(int i)&#123; if(i&lt;2) return i== 0?0:1; return Fbi(i-1)+Fbi(i-2);&#125;int main()&#123; int i; for(int i=0;i&lt;40;i++) &#123; printf(\"%d\",Fbi(i)); &#125; return 0;&#125; 递归是自己调用自己，我们可以把它看做是调用另一个函数；只不过，这个函数和自己长得一样。 每个递归定义必须至少有一个条件，满足时递归不在进行，即不再引用自身而是返回值退出。避免陷入永不结束的无穷递归中。 递归和迭代的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰，更简洁，更容易让人理解，从而减少读懂代码的时间。但大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代不需要反复调用函数和占用额外的内存。 这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合这样的数据结构，因此，编译器使用栈实现递归。 后缀表达式这是波兰逻辑学家提出的，它将传统的四则运算表达式，改造成去掉括号，运算符在运算数字之后出现的形式。 例如：9+(3-1)*3+10/2改造为9 3 1 - 3 * + 10 2 / + 如何看这个改造结果呢？理解起来就是：从左到右写数字，原则是运算符在计算的两个数字之后，但是要考虑括号和乘除优先写运算符。所以看成三块9 |+| (3-1)*3 |+| 10/2每一块又按这个原则来分。 9 3 1 - 3 * + 10 2 / +这个表达式计算机如何处理呢？计算机的做法是遇到数字就入栈，遇到运算符就将栈顶的两个数出栈进行运算(注意顺序)，将运算结果再入栈，这样直到最后的运算符。 队列queue是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。是一种先进先出的线性表，简称FIFO。允许插入的叫队尾，允许删除的一端称为队头。 键盘输入到屏幕输出用的就是队列。 循环队列当队列是顺序结构时，假设这个队列能放n个元素，那么它的长度必须是大于n的，并且要把队列的所有元素存储在数组的前n个单元，数组下标为0的一端就是队头。入队，就是在队尾加入一个元素，不用移动任何元素。出队，需要将除第一个元素的所有元素前移。所以入队的时间复杂度为o(1)，出队是o(n)。 如果我们不去限制队列的元素必须放在数组的前n个单元，出队的下标就不需要一定在下标为0的位置。 我们把队列这种头尾相接的顺序存储结构称为循环队列。 如何判断是否为空或者满呢？ 设置一个标识flag，当front==rear，且flag=0时为队列空；当front==rear，且flag=1时为队列满 当队列空时，条件就是front==rear。当队列满，数组中会有一个空闲位置，不让rear==front。 循环队列入队操作(顺序结构)1234567891011Status EnQueue(SqQueue *Q,QElemType e)&#123; //判断队列是否满 if((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front) return ERROR; //将元素e赋值给队尾，数组 Q-&gt;data[Q-&gt;rear]=e; //rear指针后移 Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE; return OK;&#125; 循环队列出队操作(顺序结构)1234567891011Status DeQueue(SqQueue *Q,QElemType *e)&#123; //队列为空的判断 if(Q-&gt;front == Q-&gt;rear) return ERROR; //取出要删除的数据 *e=Q-&gt;data[Q-&gt;front]; //队头后移 Q-&gt;front=(Q-&gt;front+1)%MAXSIZE; return OK;&#125; 入队(链式结构)将队头指针指向链对列的头结点，而队尾指针指向终端结点 1234567891011121314Status EnQueue(LinkQueue *Q,QElemType e)&#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); if(!s) exit(OVERFLOW); //对入队结点赋值 s-&gt;data=e; s-&gt;next=NULL; //将结点加入队列 Q-&gt;rear-&gt;next=s; //移动队尾指针 Q-&gt;rear=s; return OK;&#125; 出队(链式结构)出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点。如果链表除了头结点外只有一个元素，则需要将rear指向头结点。 12345678910111213141516Status DeQueue(LinkQueue *Q,QElemType *e)&#123; //新结点来保存信息 QueuePtr p; if(Q-&gt;front == Q-&gt;rear) return ERROR; //头结点的后继(被删除的结点)信息保存在p结点中 p=Q-&gt;front-&gt;next; *e=p-&gt;data; Q-&gt;front-&gt;next=p-&gt;next; //如果删除的结点是唯一结点 if(Q-&gt;rear==p) q-&gt;rear=Q-&gt;front; free(p); return OK;&#125;","categories":[],"tags":[]},{"title":"数据结构/树","slug":"数据结构/树","date":"2019-11-30T07:27:41.577Z","updated":"2019-11-30T07:27:44.746Z","comments":true,"path":"2019/11/30/数据结构/树/","link":"","permalink":"http://yoursite.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/","excerpt":"","text":"树树是n(n&gt;=0)个结点的有限集。n=0时称为空树。在任意一棵非空树种：(1)有且仅有一个特定的称为根(Root)的结点；(2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集，其中每一个集合本身又是一棵树，并且称为根的子树。 定义之前的顺序表 栈 队列 都是一对一的线性结构，现在需要一对多的结构，树就是一对多的数据结构。 结点分类根节点 内部结点 叶节点/终端结点。 其他定义如果树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 树中结点的最大层次称为树的深度。 森林是m(m&gt;=0)棵互不相交的树的集合。 树的存储结构之前有顺序存储结构，现在有链式存储结构。但是那都是一对一的关系，现在需要一对多的关系。如果树中结点只是简单的顺序结构，那就体现不了结点之间的一对多关系。可以充分结合链式和顺序存储的特点，让它能体现出一对多的关系。 双亲表示法每个结点都有一个指针域来指向它的父节点。根节点的指针域为-1。 特点是找结点的双亲方便。 孩子表示法每个结点都有多个指针域，其中每一个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法。 把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。 特点是找结点的孩子方便。 孩子兄弟表示法任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。 特点是找结点的兄弟结点方便。 二叉树一个结点只有左右两个结点。 折半查找目的是有规律的缩减筛选条件，当条件小到中间只差1，不就找到那个元素了。 二叉树定义二叉树(Binary Tree)是n(n&gt;=0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根节点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成。 二叉树特点 每个结点最多两棵子树，且每个结点的度最大也为2 子树需要区分顺序，左和右本来就是他们的特点 满二叉树可以说把二叉树填充满就是完全二叉树。在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 完全二叉树特点：满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。 对一棵具有n个结点的二叉树按层序排号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这可二叉树称为完全二叉树。 上面的解释读起来有点抽象，比喻一下就是，每一层的结点只能是从左向右按次序排，这层排满才能排下一层的结点。 遍历二叉树因为每个结点对应至多两个方向，那么每选择一个方向就是一个新的路线。 限制遍历顺序是从左往右，就有以下几种顺序。 前序遍历如下图： 从根结点开始记录，一直读左子树，直到终端结点，再读右终端节点往上读。 中序遍历如图： 从左子树的终端结点开始读，再读终端结点父结点，再读右终端结点。 后序遍历如下图： 从左子树的终端结点开始读，再读右终端结点，再读终端结点父结点。 遍历方式意义方便计算机识别，计算机只有循环、判断等方式处理，它只会处理线性序列；而上边的遍历顺序就是把在树中的结点变成某种意义的线性序列。 遍历算法二叉树的定义是递归的方式，每一个结点和子结点都可以看做一个最短二叉树。 那么实现遍历算法也可以采用递归。 前序遍历算法12345678void PreOrderTraverse(BiTree T)&#123; if(T==NULL) return; printf(&quot;%c&quot;,T-&gt;data);/*显示结点数据，可以更改为其他对结点操作*/ PreOrderTraverse(T-&gt;lchild);/*再前序遍历左子树*/ PreOrderTraverse(T-&gt;rchild);/*最后前序遍历右子树*/&#125; 这个算法的走势是：从根结点开始遍历，不为空就输出，然后就前序遍历左子树；因为左子树又可能不为空，就一直往下遍历左子树，直到左子树结点为空，就返回；这时就执行该结点的前序遍历右子树。 中序遍历算法根据上面算法的理解，就知道前序与中序的区别就是父节点到底是先输出还是在左结点输出只有再输出。 12345678void InOrderTraverse(BiTree T)&#123; if(T==NULL) return; InOrderTraverse(T-&gt;lchild);/*中序遍历左子树*/ printf(&quot;%c&quot;,T-&gt;data);/*显示结点数据，可以更改为其他对结点操作*/ InOrderTraverse(T-&gt;rchild);/*最后中序遍历右子树*/&#125; 后序遍历算法前中后，说的就是打印父节点的顺序。 12345678void PostOrderTraverse(BiTree T)&#123; if(T==NULL) return; PostOrderTraverse(T-&gt;lchild);/*先后序遍历左子树*/ PostOrderTraverse(T-&gt;rchild);/*再后序遍历右子树*/ printf(&quot;%c&quot;,T-&gt;data);/*显示结点数据，可以更改为其他对结点操作*/&#125; 后序遍历一定要记得他这个父节点是最后打印的。 如果给出前序和中序遍历的结果请推导出后序遍历像这种情况，就是需要充分理解上面的算法的特点。递归和前中后这两个特点是推导的关键，我们可以把每一个子树中在最后或者最前位置的结点看为根结点(根据前序和后序的特点)，中序遍历就是确定谁是左子树谁是右子树。 二叉树的建立(计算机)主要是将普通二叉树构建为扩展二叉树 线索二叉树将二叉树的每一个结点都增加两个指针域，其中左指针域指向它的孩子结点，同理右指针域。这样总会有一些空指针域，为了提高利用率，就将空指针域进行改造；左边的空指针域就指向中序遍历的前结点，右边的空指针域就指向中序遍历的后结点。 仅仅这样还是无法知道结点的左指针域指向的到底是左孩子还是它的前驱结点。 那么给结点再增加两个布尔域，用来辨别它的左右指针指向的是前驱还是孩子。 中序遍历线索化递归函数代码1234567891011121314151617181920BiThrTree pre;/*全局变量，始终指向刚刚访问过的结点*/void InThreading(BiThrTree p)&#123; if(p) &#123; InThreading(p-&gt;lchild);/*递归左子树线索化*/ if(!p-&gt;lchild)/*该结点没有左孩子*/ &#123; p-&gt;LTag=Thread;/*该结点的左指针标签为前驱*/ p-&gt;lchild=pre;/*左孩子指针指向前驱*/ &#125; if(!pre-&gt;rchild)/*前驱没有右孩子*/ &#123; pre-&gt;RTag=Thread;/*后继线索*/ pre-&gt;rchild=p;/*前驱右孩子指针指向后继(当前结点p)*/ &#125; pre=p;/*保持pre指向p的前驱*/ InThreading(p-&gt;rchild);/*递归右子树线索化*/ &#125;&#125;","categories":[],"tags":[]},{"title":"数据结构/线性表","slug":"数据结构/线性表","date":"2019-11-30T07:27:41.568Z","updated":"2019-11-30T07:27:43.406Z","comments":true,"path":"2019/11/30/数据结构/线性表/","link":"","permalink":"http://yoursite.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"概念筑基 数据 数据对象 有相同数量和类型数据项的数据元素的集合 数据元素 组成数据的基本单位 数据项 数据结构 包含相互关系数据元素的集合 逻辑结构与物理结构逻辑针对数据元素之间的关系，物理针对计算机存储单元之间的关系 逻辑关系：元素之间无关联、一对一、一对多、多对多；分别对应集合结构、线性结构、树形结构、图形结构。 物理结构：数据存储单元之间顺序存储、链式存储。 算法求解特定问题的求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 算法的特性： 输入 输出 有穷性 确定性 可行性 算法设计的特性： 正确性 可读性 健壮性 对输入不合法的情况做出合适的处理 时间效率高，存储量低‘ 算法效率的度量： 测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数。运行时间与这个计数成正比。 判断一个算法的效率，函数中常数和其他次要项常常可以忽略，更应该关注主项（最高阶项）的阶数。 推导时间复杂度的方法： 用常数1取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是1，则去除与整个项相乘的常数。 得到的结果就是大O阶 对于循环体来说，时间复杂度就是内循环的复杂度乘循环的次数。 线性表有顺序结构和链式结构。单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但是如果我们希望从第i个位置，插入10个元素，对于顺序存储结构意味着，每一次插入都要移动n-i个元素，每次都是O(n)。而单链表，我们只需要第一次找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针，事件复杂度为O(1)。显然，对于插入和删除数据越频繁的操作，单链表的效率优势就越明显。 单链表的整表创建1.头插法：让不断生成的结点始终位于第一的位置。新结点指向上一次的新结点，头指针指向新结点。 2.尾插法：把每次新结点都插在终端结点后面。上一次的新结点指向新结点。 单链表的整表删除链表中每个元素只有数据域和指向下一个元素的指针；要删除的话，只能从第一个开始删除，然后不断往后循环。 单链表结构与顺序存储结构优缺点时间性能上，单链表查找弱于顺序存储结构，插入和删除在多元素时优于顺序存储结构。空间性能上，顺序存储需要预先分配空间，这就直接导致会有浪费或者上溢。 例如：1.在游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况下都是读取，所以应该考虑使用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家游戏的过程中，可能随时增加或删除，此时再用顺序存储就太不合适了。2.当线性表中的元素个数变化较大或者根本不知道多大时，为了空间考虑还是使用单链表结构。如果事先知道线性表的大致长度，比如一年12个月，一周共7天，这种用顺序存储结构效率高很多。 静态链表当最初期的编程高级语言Basic、Fortran，由于没有指针，链表结构如何实现呢？和我在Java中定义链表差不多，我用一个包装类里面放数据和它指向的下个元素的地址。那这些没有指针的语言，它们可以使用数组来代替指针。首先是数组中的每个元素都是由两个数据域组成，data和cur；这个cur放的就是该元素的后继在数组中的下标。这种用数组描述的链表就是静态链表，还有叫游标实现法的。 光这样放元素还是不够完善，我们需要对数组第一个和最后一个元素作为特殊元素处理，不存数据。通常把未被使用数组元素（剩余空闲的数组元素连在一起的）称为备用链表。而数组第一个元素，下标为0的数组元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数组的元素的下标，相当于头结点。如下图：第一个节点中cur为7，庚元素的cur为0，数组的末尾的cur为1，这三个表示的意思，我们都应该要知道。7是备用链表的起始位置，0是表示当前数组元素为不为空的元素最后一个，1是表示数组中不为空的第一个位置的下标。7、0、1都是下标。 静态链表的插入与删除静态链表要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。 插入那么如何模拟结点创建呢？我们将数组中未被使用过的及已经被删除的分量用游标链成一个备用的链表，每当进行插入时，就从备用链表中取得一个结点作为待插入的新结点。 1234567891011121314/*备用链表非空，就返回要分配出去的结点的下标，否则返回0*/int Malloc_SLL(StaticLinkList space) &#123; //静态链表的第一个位置放的就是备用链表 //第一个元素的下标，现在我们先拿到 //备用链表的第一个元素 int i = space[0].cur; //如果能拿到备用链表的第一个结点，那就把它下一个 //结点作为新一个第一结点。因为需要人能顶起下次被取出的任务 if (space[0].cur) &#123; space[0].cur = space[i].cur; &#125; return i;&#125; 现在能从备用链表中拿到新的空间作为放新结点的位置了。那我们就来实现如何给静态链表插入一个元素。大致思路还是：先判断插入位置是否合理；再拿到插入位置的前一个结点，让它把它的后继结点的游标给我们新插入的结点来继承；然后新结点再作为前面结点的后继。很好理解，每个元素只有下一个元素的游标，我们要插入某个位置，那就要把这个位置的上游指向新结点且新结点指向上游的后继结点；那就先把上游的后继结点游标拿到，不然赋值就覆盖了。 12345678910111213141516171819Status ListInsert(StaticLinkList L,int i,ElemTyp e) &#123; //j用来接收分配位置,k用来接收静态链表的最后一位元素的下标， //位于该k位置元素的游标指向第一个放元素的下标；l用来计数。 int j,k,l; k = MAX_SIZE - 1; if (i&lt;1 ||i&gt;ListLength(L) +1) return ERROR; j = Malloc_SSL(L); /*获得空闲分量的下标*/ if (j) &#123; L[j].data = e; /*插入位置数据域赋值*/ for (l=1; l&lt;i; l++) &#123; /*l是相对于长度来说，l=1下面第一次循环就拿到开头元素的下标，那么他要循环到插入位置前一个元素，那对应的下标就是i-1，就循环i-1次*/ k = L[k].cur; &#125; L[j].cur = L[k].cur; L[k].cur = j; return OK; &#125; return ERROR;&#125; 这里面比较难理解的就是找到插入位置的前一个元素。一个循环，它的结束条件还是要看它循环体什么时候符合条件；符合条件了就要结束循环。 删除要删除i位置的结点，很简单，就是把i上游的游标不再指向i了，指向i的下游；然后将i位置结点释放。直接上代码： 1234567891011121314Status ListDelete(StaticLinkList L,int i) &#123; int j,k; if (i &lt;1 || i&gt;ListLength(L)) &#123; return ERROR; &#125; k = MAX_SIZE - 1; for (j = 1;j&lt;=i-1;j++) &#123; k = L[k].cur; &#125; j = L[k],cur; L[k].cur = L[j].cur; Free_SSL(L,j); return OK;&#125; 其中的Free_SSL(L,j)是释放元素： 123456/*将下标为k的空闲结点回收到备用链表*/void Free_SSL(StaticLinkList space,int k) &#123; /*用了头插法，把新产生的空闲结点放到备用链表第一个元素之前*/ space[k].cur = space[0].cur; space[0].cur = k;&#125; 为啥这里不用尾插法？理论上是可行，反正都是把空闲结点放进备用链表。不过尾插就得找到备用链表的最后一个结点，在静态链表中只能不断遍历才能拿到。这就过于麻烦了吧！静态链表有三个特殊位置，第一个是第一位指向了备用链表的位置，第二个是最后一位指向了有元素的第一个位置，第三个是备用链表的起始位置，它指向备用链表的后继。头插法是，我们只要把插入的结点指向之前的第一个结点就行；在静态链表中，除了要这样做之外，还要把第一个结点指向的位置换成新结点。 静态链表的优缺点优点是继承了单链表的优点，缺点是没有解决表长难确定的问题，失去了顺序存储结构随机存取的特性。静态链表理解它的思想就ok了。 循环链表第一个特点，从任一结点都能完整遍历链表。我们把单链表的尾结点的指针从空指针改为指向头结点。这样就把整个单链表形成一个环，这种头尾相连的单链表就是单循环链表。简称循环链表（circular linked list）。通常为了让空链表和非空链表处理一致，通常设置一个头结点。循环链表和单链表的主要差异就在于循环的判断条件，原来是判断p-&gt;next是否为空，现在是p-&gt;next不等于头结点，则循环未结束。循环链表就是为了解决从任一结点都能遍历链表，我们都知道链表的头和尾是两个特殊位置，如果我们想要不遍历整个链表就拿到头和尾，那该咋整呢？我们用一个尾指针来指向尾结点，不就解决了。 现在咋们有两个循环链表A和B，我们要让B接在A后面，如果只有头指针的情况下，怎么办？那就得遍历A，指导尾结点结束，然后让尾结点不再指向A的头结点；让它指向B的头结点，然后遍历B，让B的尾结点不指向B的头结点，去指向A的头结点。这里用到了两个遍历时间复杂度O(n)。如果现在有尾指针的情况下呢？A的尾指针去指向B的尾指针的next-&gt;next也就是B的头，让B的next指向A的尾指针的next-&gt;next也就是A的头。这里的时间复杂度是多少？也就两步吧？这不就很简单了。这就是尾指针的爽点。文字看起来不爽，来用代码表示一下： 1234p = rearA-&gt;next; /*拿到A的头结点*/rearA-&gt;next=rearB-&gt;next-&gt;next; /*A的尾结点指向B的头结点*/rearB-&gt;next=p; /*B的尾结点指向A的头结点*/free(p); 双向链表在一个循环链表的情况下，我们现在需要从尾结点开始，遍历整个链表，并且最后要回到头结点。遍历一次咋们还是在尾结点，还得多走一步才能回到头结点。现在我们整一个双向链表，啥是双向链表？先不管，反正能反着访问就行，那我们就可以从尾结点逆序访问到头结点，还不用多走一步。我们在单链表中，有了next指针，使得我们要查找下一结点的时间复杂度为O(1)。可是如果我们要找的是上一个结点，就得是O(n)了。因为我们每次都得从头开始查找。为了克服单向性这一个访问缺点，我们的科学家设计出了双向链表。double linked list是在单链表的每一个节点中，再设置一个指向其前驱结点的指针域。那么现在双向链表的每一个结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。 双向链表的插入与删除思路：在a1（p结点）与a2之间插入一个s结点，现在能知道的就是p结点和e结点。进行指针操作必须要注意p-&gt;next只能最后被赋值，因为它表示的就是a1与a2之间的联系，如果他改变了就表示联系断了。 1234567/*先给插入的s结点的两个指针域赋值，完成s结点的指向*/s-&gt;next = p-&gt;next; s-&gt;prior = p;/*对a2结点的priod指针（指向前一结点的指针域）赋值*/p-&gt;next-&gt;prior = s;/*对a1结点的next指针赋值*/p-&gt;next = s; 双向链表插入得修改三个结点，首先是插入结点的前后指针，再是插入位置的后一结点的前指针，最后是插入结点位置的前一结点的后指针。 删除：假如删除的就是p结点，它的前后结点的指针都与他无关了，之前和它有关的都得改变。 123p-&gt;next-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=p-&gt;next;free(p);","categories":[],"tags":[]}]}