{"meta":{"title":"个人技术博客","subtitle":"记录了一些与JAVA相关的技术文章","description":"学习与工作总结","author":"杨发","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-11-30T06:41:57.000Z","updated":"2019-11-30T08:45:32.174Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-30T06:42:05.000Z","updated":"2019-11-30T08:45:18.243Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-27T14:29:50.000Z","updated":"2019-11-30T08:45:08.311Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Lambda","slug":"JAVA/Lambda ","date":"2019-11-30T13:17:24.000Z","updated":"2019-11-30T15:40:37.926Z","comments":true,"path":"2019/11/30/JAVA/Lambda /","link":"","permalink":"http://yoursite.com/2019/11/30/JAVA/Lambda%20/","excerpt":"","text":"Lambda 表达式复制小括号，写死右箭头，落地大括号。 函数式接口函数式接口就是只显式声明一个抽象方法的接口。为保证方法数量不多不少，java8提供了一个专用注解 @FunctionalInterface，这样，当接口中声明的抽象方法多于或少于一个时就会报错。如下图所示： Java内置的四大核心函数式接口12345678Consumer&lt;T&gt; 消费型接口 消费对象 void accept(T t);Supplier&lt;T&gt; 供给型接口 生成对象 T get();Function&lt;R,T&gt; 函数型接口 指定特定功能 R apply(T t);Predicate&lt;T&gt; 断言型接口 进行条件判断 boolean test(T t); Lambda表达式Lambda表达式本质上是一个匿名方法。让我们来看下面这个例子： 123public int add(int x, int y) &#123; return x + y; &#125; 转成Lambda表达式后是这个样子： 1(int x, int y) -&gt; x + y; 参数类型也可以省略，Java编译器会根据上下文推断出来： 1(x, y) -&gt; x + y; // 隐式的自动返回 或者 1(x, y) -&gt; &#123; return x + y; &#125; // 显式指明返回值 可见Lambda表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。 Lambda表达式几种类型有参无返回值接口 1234@FunctionalInterfacepublic interface InterfaceWithParams &#123; void run(String s);&#125; 实现 12345678InterfaceWithParams params = new InterfaceWithParams() &#123; @Override public void run(String s) &#123; System.out.println(\"通过\" + s + \"实现run(String)\"); &#125;&#125;;InterfaceWithParams params1 = (String s) -&gt; System.out.println(\"通过\" + s + \"实现run(String)\"); 测试 12this.params.run(\"匿名类\");this.params1.run(\"Lambda\"); 无参有返回值接口 1234@FunctionalInterfacepublic interface InterfaceUnVoidWithNoParam &#123; String run();&#125; 实现 12345678InterfaceUnVoidWithNoParam interfaceUnVoidWithNoParam = new InterfaceUnVoidWithNoParam() &#123; @Override public String run() &#123; return \"Hello World!\"; &#125;&#125;;//省略掉了returnInterfaceUnVoidWithNoParam interfaceUnVoidWithNoParam1 = () -&gt; \"Hello Lambda!\"; 测试 1234String s = this.interfaceUnVoidWithNoParam.run();System.out.println(\"返回结果是：\"+s);String s0 = this.interfaceUnVoidWithNoParam1.run();System.out.println(\"返回结果是：\"+s0); 有参有返回值接口 1234@FunctionalInterfacepublic interface InterfaceUnVoidWithParams &#123; String run(Integer integer);&#125; 实现 1234567InterfaceUnVoidWithParams interfaceWithParams = new InterfaceUnVoidWithParams() &#123; @Override public String run(Integer integer) &#123; return String.valueOf(integer); &#125;&#125;;InterfaceUnVoidWithParams interfaceWithParams1 = (Integer integer) -&gt; String.valueOf(integer); 测试 1234String s1 = this.interfaceWithParams.run(1);System.out.println(\"您输入的是：\"+s1);String s2 = this.interfaceWithParams1.run(2);System.out.println(\"您输入的是：\"+s2); StreamJava 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用fork/join并行方式来拆分任务和加速处理过程。 中间操作筛选与切片filter接收 Lambda，从流中过滤某些数据 list.stream() .filter( (student -&gt; student.getNo() &gt; 3) ) //中间操作过滤编号小于4 .forEach( (student -&gt; System.out.println(student.toString()))); limit 截断流，使其元素不超过指定数量 list.stream() .limit(2) //截断流，只取两个 .forEach((student -&gt; System.out.println(student))); skip 跳过元素，返回一个扔掉了前n个元素的流，与limit相反 list.stream() .skip(2) //跳过流的前两个 .forEach((System.out::println)); distinct 通过 equals() 和 hashCode() 去除 list.stream() .distinct() .forEach((System.out::println)); 映射 map 接收 Lambda，将元素转换成其他形式，接受一个函数，会作用到每一个元素上。 list.stream() .map((String::toUpperCase)) // 映射函数 .forEach((System.out::println)); flatMap 接收一个函数作为参数，将流中的每个值都转换成另一个流，然后把所有流合并为一个流 排序 sorted() list.stream() .sorted() // 自然排序 .forEach((System.out::println)); sorted（Comparator com） 定制排序 list.stream() .sorted(Comparator.comparingInt(String::length)) // 定制排序 .forEach((System.out::println)); 终止操作 查找与匹配 allMatch 是否全部匹配，返回Boolean值 boolean g = list.stream() .allMatch((student -&gt; student.getSex().equals(“G”))); System.out.println(g); anyMatch 至少匹配一个，返回Boolean值 boolean g = list.stream() .anyMatch((student -&gt; student.getSex().equals(“G”))); System.out.println(g); noneMatch 没有匹配元素，返回Boolean值 boolean g = list.stream() .noneMatch((student -&gt; student.getSex().equals(“G”))); System.out.println(g); findFirst 返回第一个元素，封装为一个Optional，避免了空指针 Optional first = list.stream() .findFirst(); System.out.println(first.get()); findAny 返回当前流中任意的元素 Optional any = list.stream() .findAny(); System.out.println(any.get()); count 返回流中元素总个数 long count = list.stream() .count(); System.out.println(count); max 返回流中最大值，找出最高学生的信息 Optional max = list.stream() .max((x, y) -&gt; Float.compare(x.getHeight(), y.getHeight())); System.out.println(max.get()); min 返回流中最小值，找出学生中最矮的学生身高 Optional min = list.stream() .map((Student::getHeight)) .min(Float::compare); System.out.println(min.get()); 归约 map - reduce 模式 是将流中元素反复结合起来，得到一个值，有两种表现形式 1. 一个参数的Reduce Optional reduce = list.stream() .map((Student::getHeight)) // 获得每个学生的身高 .reduce(Float::sum); // 将身高总和加起来 System.out.println(reduce.get()); 假设Stream中的元素a[0]、a[1]、a[2]…a[n - 1]，表示将a[0]与a[1]进行二合运算，结果与a[2]做二合运算，一直到最后与a[n-1]做二合运算。 1.2 两个参数的Reduce Float reduce = list.stream() .map((Student::getHeight)) // 获得每个学生的身高 .reduce(0f, Float::sum); // 定义一个初始化的值为0 System.out.println(reduce); 它多了一个初始化的值，因此计算的顺序是identity与a[0]进行二合运算，结果与a[1]再进行二合运算，最终与a[n-1]进行二合运算，identity一般设为不影响结果的值。 1.3 三个参数的Reduce 收集 collect 是将流转换为其他形式。接收一个 Collector 接口的实现，用于给Stream中元素做汇总的方法。 Set collect = list.stream() .map((Student::getName)) // 获取所有学生的身高 .collect(Collectors.toSet()); // 把学生的名字收集到 set 集合中去 System.out.println(collect); // 去重结果 HashSet collect = list.stream() .map((Student::getName)) //什么集合，就是 集合名字::new .collect(Collectors.toCollection(HashSet::new)); System.out.println(collect); 3、Optional容器类 Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException） orElse(T other) 与 orElseGet(Supplier&lt;? extends T&gt; other) @Test public void test2() { Student student = new Student(1, “A”, “M”, 184); Student student1 = Optional.ofNullable(student).orElse(createStudent()); Student student2 = Optional.ofNullable(student).orElseGet(this::createStudent); } public Student createStudent(){ Student student = new Student(); student.setName(“新增的学生”); System.out.println(“新增的学生的方法执行了”); return student; } 这两个函数的区别： 当user值不为null时，orElse函数依然会执行 createStudent() 方法 而orElseGet函数并不会执行 createStudent() 方法，大家可自行测试。 https://www.cnblogs.com/rjzheng/p/9163246.html 4、线程安全的时间API，java.time Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API： Local(本地) − 简化了日期时间的处理，没有时区的问题。 Zoned(时区) − 通过制定的时区处理日期时间。 新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。 1、DateTimeFormatter DateTimeFormatter[] formatters = new DateTimeFormatter[]{ // 直接使用常量创建DateTimeFormatter格式器 DateTimeFormatter.ISO_LOCAL_DATE, DateTimeFormatter.ISO_LOCAL_TIME, DateTimeFormatter.ISO_LOCAL_DATE_TIME, // 使用本地化的不同风格来创建DateTimeFormatter格式器 DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.MEDIUM), DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG), // 根据模式字符串来创建DateTimeFormatter格式器 DateTimeFormatter.ofPattern(“Gyyyy%%MMM%%dd HH:mm:ss”) }; LocalDateTime date = LocalDateTime.now(); //获取当前本地时间 // 依次使用不同的格式器对LocalDateTime进行格式化 for(int i = 0 ; i &lt; formatters.length ; i++) { // 下面两行代码的作用相同 System.out.println(date.format(formatters[i])); System.out.println(formatters[i].format(date)); // 一般用这个 } 2、LocalDate、LocalTime、LocalDateTime LocalDateTime localDateTime = LocalDateTime.now(); // 获取当前时间 // 对时间的增减 LocalDateTime localDateTime1 = localDateTime.minusYears(1); // 加一年 LocalDateTime localDateTime2 = localDateTime.plusYears(1); // 减一年 // 获取时间的部分信息，get操作 DayOfWeek dayOfWeek = localDateTime.getDayOfWeek(); // 获取星期几 3、Instant 时间戳 Instant instant = Instant.now(); // 获取以 UTC 时区的时间 System.out.println(instant); 4、Duration、Period 两个类表示时间量或两个日期之间的差 两者之间的差异为：Period基于日期值，而Duration基于时间值。 Duration 类 计算两个 时间 之间的间隔 Duration类表示秒或纳秒时间间隔，适合处理较短的时间，需要更高的精确性。我们能使用between()方法比较两个瞬间的差： LocalTime startTime = LocalTime.now(); Thread.sleep(20000); LocalTime endTime = LocalTime.now(); Duration between = Duration.between(startTime, endTime); System.out.println(between.getSeconds()); // 使用get to等方法获取所需数据 Period 类 计算两个 日期 之间的间隔 Period 类表示一段时间的年、月、日，使用between()方法获取两个日期之间的差作为Period 对象返回： LocalDate startDate = LocalDate.of(2015, 2, 20); LocalDate endDate = LocalDate.of(2017, 1, 15); Period period = Period.between(startDate, endDate); //用 Period 类方法获取日期单元 System.out.println(period.getYears()); // 获取两个日期之间差几年 System.out.println(period.getMonths());// 获取两个日期之间差几月 System.out.println(period.getDays()); // 获取两个日期之间差几天 5、TemporalAdjuster 时间矫正器 使用 TemporalAdjuster 可以对当前时间进行处理，如下个周一，下个周日等等需求。 方法通常以 With 开头。 LocalDate today = LocalDate.now(); System.out.println(“今天: “ + today); // 使用DateAdjuster将今天的日期调整到下周一 LocalDate nextMonday = today.with(TemporalAdjusters.next(DayOfWeek.MONDAY)); System.out.println(“下周一: “ + nextMonday); // 使用 TemporalAdjuster 将今天的日期调整为月的最后一天 LocalDate lastDayOfMonth = today.with(TemporalAdjusters.lastDayOfMonth()); System.out.println(“这个月最后一天: “ + lastDayOfMonth); // 创建一个在3个月2天后日期的 TemporalAdjuster TemporalAdjuster adjuster = TemporalAdjusters.ofDateAdjuster((LocalDate date) -&gt; date.plusMonths(3).plusDays(2)); LocalDate dayAfter3Mon2Day = today.with(adjuster); System.out.println(“三月零两天后的日期: “ + dayAfter3Mon2Day); 6、ZoneDate、ZoneTime、ZoneDateTime","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"SpringBoot集成Swagger2","slug":"SpringBoot/Swagger","date":"2019-11-30T13:17:24.000Z","updated":"2019-11-30T15:46:32.026Z","comments":true,"path":"2019/11/30/SpringBoot/Swagger/","link":"","permalink":"http://yoursite.com/2019/11/30/SpringBoot/Swagger/","excerpt":"","text":"Swagger我们提供Restful接口的时候，API文档是尤为的重要，它承载着对接口的定义，描述等。它还是和API消费方沟通的重要工具。在实际情况中由于接口和文档存放的位置不同，我们很难及时的去维护文档。个人在实际的工作中就遇到过很多接口更新了很久，但是文档却还是老版本的情况，其实在这个时候这份文档就已经失去了它存在的意义。而Swagger是目前我见过的最好的API文档生成工具，使用起来也很方便，还可以直接调试我们的API。我们今天就来看下Swagger2与SpringBoot的结合。 导入依赖12345678910111213&lt;!-- swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; Swagger 的配置类1234567891011121314151617181920212223242526272829303132333435363738@Configuration@EnableSwagger2public class SwaggerConfig extends WebMvcConfigurationSupport &#123; @Bean public Docket productApi() &#123; return new Docket(DocumentationType.SWAGGER_2).select() // 扫描的包路径 .apis(RequestHandlerSelectors.basePackage(\"com.yf.controller\")) // 定义要生成文档的Api的url路径规则 .paths(PathSelectors.any()) .build() // 设置swagger-ui.html页面上的一些元素信息。 .apiInfo(metaData()); &#125; private ApiInfo metaData() &#123; return new ApiInfoBuilder() // 标题 .title(\"SpringBoot集成Swagger2测试\") // 描述 .description(\"这是一篇博客演示\") // 文档版本 .version(\"1.0.0\") .license(\"Apache License Version 2.0\") .licenseUrl(\"https://www.apache.org/licenses/LICENSE-2.0\") .build(); &#125; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); &#125;&#125; Swagger 常用注解 @Api() 用于类：表示标识这个类是swagger的资源 tags——表示说明 value——也是说明，可以使用tags替代 但是tags 如果有多个值，会生成多个list 12345@ApiOperation(value = \"获取用户列表\",notes = \"获取所有用户的信息\")@GetMapping(\"/users\")public Object index() &#123; &#125; @ApiOperation() 用于方法：表示一个 http 请求的操作 value——用于方法描述 notes——用于提示内容 tags可以重新分组（视情况而用） @ApiOperation(value = “获取用户列表”,notes = “获取所有用户的信息”) @GetMapping(“/users”) public Object index() { } @ApiParam() 用于参数：对方法参数的补充说明 name——参数名 value——参数的描述 required——是否必填 @ApiOperation(value = “根据用户ID查询用户”,notes = “查询单个用户的信息”) @ApiParam(name =”id”,value = “用户id”,required = true) @GetMapping(“/users/{id}”) public Object getUserById(@PathVariable(“id”) String id) { }","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[]},{"title":"树","slug":"数据结构/树","date":"2019-11-30T09:01:24.000Z","updated":"2019-11-30T15:40:44.026Z","comments":true,"path":"2019/11/30/数据结构/树/","link":"","permalink":"http://yoursite.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/","excerpt":"","text":"树树是n(n&gt;=0)个结点的有限集。n=0时称为空树。在任意一棵非空树种：(1)有且仅有一个特定的称为根(Root)的结点；(2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集，其中每一个集合本身又是一棵树，并且称为根的子树。 定义之前的顺序表 栈 队列 都是一对一的线性结构，现在需要一对多的结构，树就是一对多的数据结构。 结点分类根节点 内部结点 叶节点/终端结点。 其他定义如果树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 树中结点的最大层次称为树的深度。 森林是m(m&gt;=0)棵互不相交的树的集合。 树的存储结构之前有顺序存储结构，现在有链式存储结构。但是那都是一对一的关系，现在需要一对多的关系。如果树中结点只是简单的顺序结构，那就体现不了结点之间的一对多关系。可以充分结合链式和顺序存储的特点，让它能体现出一对多的关系。 双亲表示法每个结点都有一个指针域来指向它的父节点。根节点的指针域为-1。 特点是找结点的双亲方便。 孩子表示法每个结点都有多个指针域，其中每一个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法。 把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。 特点是找结点的孩子方便。 孩子兄弟表示法任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。 特点是找结点的兄弟结点方便。 二叉树一个结点只有左右两个结点。 折半查找目的是有规律的缩减筛选条件，当条件小到中间只差1，不就找到那个元素了。 二叉树定义二叉树(Binary Tree)是n(n&gt;=0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根节点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成。 二叉树特点 每个结点最多两棵子树，且每个结点的度最大也为2 子树需要区分顺序，左和右本来就是他们的特点 满二叉树可以说把二叉树填充满就是完全二叉树。在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 完全二叉树特点：满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。 对一棵具有n个结点的二叉树按层序排号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这可二叉树称为完全二叉树。 上面的解释读起来有点抽象，比喻一下就是，每一层的结点只能是从左向右按次序排，这层排满才能排下一层的结点。 遍历二叉树因为每个结点对应至多两个方向，那么每选择一个方向就是一个新的路线。限制遍历顺序是从左往右，就有以下几种顺序。二叉树的定义是递归的方式，每一个结点和子结点都可以看做一个最短二叉树。那么实现遍历算法也可以采用递归。 前序遍历代码如图： 123456789public void preOrder()&#123; System.out.println(this); if (this.lrft != null)&#123; this.lrft.preOrder(); &#125; if (this.right != null)&#123; this.right.preOrder(); &#125;&#125; 从根结点开始记录，一直读左子树，直到终端结点，再读右终端节点往上读。 中序遍历代码如图： 123456789public void infixOrder()&#123; if (this.lrft != null)&#123; this.lrft.infixOrder(); &#125; System.out.println(this); if (this.right != null)&#123; this.right.infixOrder(); &#125; &#125; 从左子树的终端结点开始读，再读终端结点父结点，再读右终端结点。 后序遍历代码如图： 123456789public void lastOrder()&#123; if (this.lrft != null)&#123; this.lrft.lastOrder(); &#125; if (this.right != null)&#123; this.right.lastOrder(); &#125; System.out.println(this); &#125; 从左子树的终端结点开始读，再读右终端结点，再读终端结点父结点。 遍历方式意义方便计算机识别，计算机只有循环、判断等方式处理，它只会处理线性序列；而上边的遍历顺序就是把在树中的结点变成某种意义的线性序列。 如果给出前序和中序遍历的结果请推导出后序遍历像这种情况，就是需要充分理解上面的算法的特点。递归和前中后这两个特点是推导的关键，我们可以把每一个子树中在最后或者最前位置的结点看为根结点(根据前序和后序的特点)，中序遍历就是确定谁是左子树谁是右子树。 线索话二叉树将二叉树的每一个结点都增加两个指针域，其中左指针域指向它的孩子结点，同理右指针域。这样总会有一些空指针域，为了提高利用率，就将空指针域进行改造；左边的空指针域就指向中序遍历的前结点，右边的空指针域就指向中序遍历的后结点。仅仅这样还是无法知道结点的左指针域指向的到底是左孩子还是它的前驱结点。那么给结点再增加两个布尔域，用来辨别它的左右指针指向的是前驱还是孩子。 二叉排序树二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。 对于二叉排序树，要求任何一个非叶子结点，其左子树结点的值比当前结点小，右子结点的值比当前结点大。 平衡二叉树（AVL），对BST的升级 每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。&gt;1 的时候，就需要考虑用旋转了。 并且左右两个子树都是一棵平衡二叉树。 单旋转1、左单旋：任何一个结点，他的右子树的高度 - 左子树的高度 &gt;1 的时候，就要考虑左旋了，左旋是为了解决右子树太高的问题。 https://img-blog.csdn.net/20180722220546910 2、右单旋：任何一个结点，他的左子树的高度 - 右子树的高度 &gt;1 的时候，就要考虑右旋了，右旋是为了解决左子树太高的问题。 https://img-blog.csdn.net/20180722222413303 方案：将左子树的右子树链接到父亲结点的左孩子结点，父亲结点作为左孩子结点的右孩子结点便完成了旋转。 3、双旋转：当一个结点的左右子树中，有不是AVL 树时，就需要对 左子树 或 右子树 进行旋转，情况有以下四种，递归执行。 只有当每个子树都是AVL树的时候，才能操作Root结点。 当左子结点的 左子树 的高度大于 右子树 的高度时，需要右旋 当左子结点的 左子树 的高度小于 右子树 的高度时，需要左旋 当右子结点的 左子树 的高度大于 右子树 的高度时，需要右旋 当右子结点的 左子树 的高度小于 右子树 的高度时，需要左旋 红黑树 红黑树 和 AVL 树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的 n 是树中元素的数目。 红黑树的性质 根节点是黑色 父子不能同为红色 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 平衡多叉树（B树，B+树）将树的度设为 1024，600亿 个元素最多只需要 4次 I/O 操作就可以取得想要的元素，效率是非常的快的。 B树广泛的应用于 文件存储系统 和 数据库系统中（索引） 。 2-3树2-3树是最简单的B树结构，2-3树 满足如下条件： 所有叶子结点都在同一层（平衡多叉树必须满足的条件） 有两个子结点的结点叫二结点，二结点要么没有子结点，要么有两个子结点 有三个子结点的结点叫三结点，三结点要么没有子结点，要么有三个子结点 2-3树 是由二结点和三结点构成的树 B树 B树的特点 从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束； 没有命中，则进入查询关键字所属范围的儿子结点进行查找； 重复以上步骤，直到所对应的儿子指针为空，或已经是叶子结点； 搜索性能等于在关键字全集中做二分查找。查找很不稳定，最好就是根节点，最坏就在叶子结点。 B+树B+树，是B树的一种变体，也是一种多路搜索树。他们差别是： B+树中所有的数据都会放在叶子结点，而不会放在非叶子结点 B+树的特点 B+树 跟 B树 搜索基本相同，区别是 B+树 只有达到叶子结点才会命中，搜索性能等于在关键字全集中做二分查找。 所有的 关键字都出现在叶子结点的链表中，（即关键字只能在叶子结点【稠密索引】），且链表中的关键字恰好是有序的。 非叶子结点相当于是叶子结点的索引【稀疏索引】，叶子结点相当于是存储（关键字）的箱子。 适合做文件索引系统，数据库索引系统。 为什么说 B+树 比 B 树 更适合实际应用中操作系统的文件索引和数据库索引？1、B+树的磁盘读写代价更低B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更 小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 而B+树非叶子节点没有Data数据，所以同样大小的磁盘页可以容纳更多的节点元素。所以数据量相同的情况下，B+树比B树更加“矮胖“，因此使用的IO查询次数更少。 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。 2、B+树的的查询效率更加稳定由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 而B树的查找并不稳定（最好的情况是查询根节点，最坏查询叶子节点）。而B树每一次查找都是稳定的。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"线性表","slug":"数据结构/线性表","date":"2019-11-30T09:01:24.000Z","updated":"2019-11-30T08:38:27.587Z","comments":true,"path":"2019/11/30/数据结构/线性表/","link":"","permalink":"http://yoursite.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"概念筑基 数据 数据对象 有相同数量和类型数据项的数据元素的集合 数据元素 组成数据的基本单位 数据项 数据结构 包含相互关系数据元素的集合 逻辑结构与物理结构逻辑针对数据元素之间的关系，物理针对计算机存储单元之间的关系 逻辑关系：元素之间无关联、一对一、一对多、多对多；分别对应集合结构、线性结构、树形结构、图形结构。 物理结构：数据存储单元之间顺序存储、链式存储。 算法求解特定问题的求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 算法的特性： 输入 输出 有穷性 确定性 可行性 算法设计的特性： 正确性 可读性 健壮性 对输入不合法的情况做出合适的处理 时间效率高，存储量低‘ 算法效率的度量： 测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数。运行时间与这个计数成正比。 判断一个算法的效率，函数中常数和其他次要项常常可以忽略，更应该关注主项（最高阶项）的阶数。 推导时间复杂度的方法： 用常数1取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是1，则去除与整个项相乘的常数。 得到的结果就是大O阶 对于循环体来说，时间复杂度就是内循环的复杂度乘循环的次数。 线性表有顺序结构和链式结构。单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但是如果我们希望从第i个位置，插入10个元素，对于顺序存储结构意味着，每一次插入都要移动n-i个元素，每次都是O(n)。而单链表，我们只需要第一次找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针，事件复杂度为O(1)。显然，对于插入和删除数据越频繁的操作，单链表的效率优势就越明显。 单链表的整表创建1.头插法：让不断生成的结点始终位于第一的位置。新结点指向上一次的新结点，头指针指向新结点。 2.尾插法：把每次新结点都插在终端结点后面。上一次的新结点指向新结点。 单链表的整表删除链表中每个元素只有数据域和指向下一个元素的指针；要删除的话，只能从第一个开始删除，然后不断往后循环。 单链表结构与顺序存储结构优缺点时间性能上，单链表查找弱于顺序存储结构，插入和删除在多元素时优于顺序存储结构。空间性能上，顺序存储需要预先分配空间，这就直接导致会有浪费或者上溢。 例如：1.在游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况下都是读取，所以应该考虑使用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家游戏的过程中，可能随时增加或删除，此时再用顺序存储就太不合适了。2.当线性表中的元素个数变化较大或者根本不知道多大时，为了空间考虑还是使用单链表结构。如果事先知道线性表的大致长度，比如一年12个月，一周共7天，这种用顺序存储结构效率高很多。 静态链表当最初期的编程高级语言Basic、Fortran，由于没有指针，链表结构如何实现呢？和我在Java中定义链表差不多，我用一个包装类里面放数据和它指向的下个元素的地址。那这些没有指针的语言，它们可以使用数组来代替指针。首先是数组中的每个元素都是由两个数据域组成，data和cur；这个cur放的就是该元素的后继在数组中的下标。这种用数组描述的链表就是静态链表，还有叫游标实现法的。 光这样放元素还是不够完善，我们需要对数组第一个和最后一个元素作为特殊元素处理，不存数据。通常把未被使用数组元素（剩余空闲的数组元素连在一起的）称为备用链表。而数组第一个元素，下标为0的数组元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数组的元素的下标，相当于头结点。如下图：第一个节点中cur为7，庚元素的cur为0，数组的末尾的cur为1，这三个表示的意思，我们都应该要知道。7是备用链表的起始位置，0是表示当前数组元素为不为空的元素最后一个，1是表示数组中不为空的第一个位置的下标。7、0、1都是下标。 静态链表的插入与删除静态链表要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。 插入那么如何模拟结点创建呢？我们将数组中未被使用过的及已经被删除的分量用游标链成一个备用的链表，每当进行插入时，就从备用链表中取得一个结点作为待插入的新结点。 1234567891011121314/*备用链表非空，就返回要分配出去的结点的下标，否则返回0*/int Malloc_SLL(StaticLinkList space) &#123; //静态链表的第一个位置放的就是备用链表 //第一个元素的下标，现在我们先拿到 //备用链表的第一个元素 int i = space[0].cur; //如果能拿到备用链表的第一个结点，那就把它下一个 //结点作为新一个第一结点。因为需要人能顶起下次被取出的任务 if (space[0].cur) &#123; space[0].cur = space[i].cur; &#125; return i;&#125; 现在能从备用链表中拿到新的空间作为放新结点的位置了。那我们就来实现如何给静态链表插入一个元素。大致思路还是：先判断插入位置是否合理；再拿到插入位置的前一个结点，让它把它的后继结点的游标给我们新插入的结点来继承；然后新结点再作为前面结点的后继。很好理解，每个元素只有下一个元素的游标，我们要插入某个位置，那就要把这个位置的上游指向新结点且新结点指向上游的后继结点；那就先把上游的后继结点游标拿到，不然赋值就覆盖了。 12345678910111213141516171819Status ListInsert(StaticLinkList L,int i,ElemTyp e) &#123; //j用来接收分配位置,k用来接收静态链表的最后一位元素的下标， //位于该k位置元素的游标指向第一个放元素的下标；l用来计数。 int j,k,l; k = MAX_SIZE - 1; if (i&lt;1 ||i&gt;ListLength(L) +1) return ERROR; j = Malloc_SSL(L); /*获得空闲分量的下标*/ if (j) &#123; L[j].data = e; /*插入位置数据域赋值*/ for (l=1; l&lt;i; l++) &#123; /*l是相对于长度来说，l=1下面第一次循环就拿到开头元素的下标，那么他要循环到插入位置前一个元素，那对应的下标就是i-1，就循环i-1次*/ k = L[k].cur; &#125; L[j].cur = L[k].cur; L[k].cur = j; return OK; &#125; return ERROR;&#125; 这里面比较难理解的就是找到插入位置的前一个元素。一个循环，它的结束条件还是要看它循环体什么时候符合条件；符合条件了就要结束循环。 删除要删除i位置的结点，很简单，就是把i上游的游标不再指向i了，指向i的下游；然后将i位置结点释放。直接上代码： 1234567891011121314Status ListDelete(StaticLinkList L,int i) &#123; int j,k; if (i &lt;1 || i&gt;ListLength(L)) &#123; return ERROR; &#125; k = MAX_SIZE - 1; for (j = 1;j&lt;=i-1;j++) &#123; k = L[k].cur; &#125; j = L[k],cur; L[k].cur = L[j].cur; Free_SSL(L,j); return OK;&#125; 其中的Free_SSL(L,j)是释放元素： 123456/*将下标为k的空闲结点回收到备用链表*/void Free_SSL(StaticLinkList space,int k) &#123; /*用了头插法，把新产生的空闲结点放到备用链表第一个元素之前*/ space[k].cur = space[0].cur; space[0].cur = k;&#125; 为啥这里不用尾插法？理论上是可行，反正都是把空闲结点放进备用链表。不过尾插就得找到备用链表的最后一个结点，在静态链表中只能不断遍历才能拿到。这就过于麻烦了吧！静态链表有三个特殊位置，第一个是第一位指向了备用链表的位置，第二个是最后一位指向了有元素的第一个位置，第三个是备用链表的起始位置，它指向备用链表的后继。头插法是，我们只要把插入的结点指向之前的第一个结点就行；在静态链表中，除了要这样做之外，还要把第一个结点指向的位置换成新结点。 静态链表的优缺点优点是继承了单链表的优点，缺点是没有解决表长难确定的问题，失去了顺序存储结构随机存取的特性。静态链表理解它的思想就ok了。 循环链表第一个特点，从任一结点都能完整遍历链表。我们把单链表的尾结点的指针从空指针改为指向头结点。这样就把整个单链表形成一个环，这种头尾相连的单链表就是单循环链表。简称循环链表（circular linked list）。通常为了让空链表和非空链表处理一致，通常设置一个头结点。循环链表和单链表的主要差异就在于循环的判断条件，原来是判断p-&gt;next是否为空，现在是p-&gt;next不等于头结点，则循环未结束。循环链表就是为了解决从任一结点都能遍历链表，我们都知道链表的头和尾是两个特殊位置，如果我们想要不遍历整个链表就拿到头和尾，那该咋整呢？我们用一个尾指针来指向尾结点，不就解决了。 现在咋们有两个循环链表A和B，我们要让B接在A后面，如果只有头指针的情况下，怎么办？那就得遍历A，指导尾结点结束，然后让尾结点不再指向A的头结点；让它指向B的头结点，然后遍历B，让B的尾结点不指向B的头结点，去指向A的头结点。这里用到了两个遍历时间复杂度O(n)。如果现在有尾指针的情况下呢？A的尾指针去指向B的尾指针的next-&gt;next也就是B的头，让B的next指向A的尾指针的next-&gt;next也就是A的头。这里的时间复杂度是多少？也就两步吧？这不就很简单了。这就是尾指针的爽点。文字看起来不爽，来用代码表示一下： 1234p = rearA-&gt;next; /*拿到A的头结点*/rearA-&gt;next=rearB-&gt;next-&gt;next; /*A的尾结点指向B的头结点*/rearB-&gt;next=p; /*B的尾结点指向A的头结点*/free(p); 双向链表在一个循环链表的情况下，我们现在需要从尾结点开始，遍历整个链表，并且最后要回到头结点。遍历一次咋们还是在尾结点，还得多走一步才能回到头结点。现在我们整一个双向链表，啥是双向链表？先不管，反正能反着访问就行，那我们就可以从尾结点逆序访问到头结点，还不用多走一步。我们在单链表中，有了next指针，使得我们要查找下一结点的时间复杂度为O(1)。可是如果我们要找的是上一个结点，就得是O(n)了。因为我们每次都得从头开始查找。为了克服单向性这一个访问缺点，我们的科学家设计出了双向链表。double linked list是在单链表的每一个节点中，再设置一个指向其前驱结点的指针域。那么现在双向链表的每一个结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。 双向链表的插入与删除思路：在a1（p结点）与a2之间插入一个s结点，现在能知道的就是p结点和e结点。进行指针操作必须要注意p-&gt;next只能最后被赋值，因为它表示的就是a1与a2之间的联系，如果他改变了就表示联系断了。 1234567/*先给插入的s结点的两个指针域赋值，完成s结点的指向*/s-&gt;next = p-&gt;next; s-&gt;prior = p;/*对a2结点的priod指针（指向前一结点的指针域）赋值*/p-&gt;next-&gt;prior = s;/*对a1结点的next指针赋值*/p-&gt;next = s; 双向链表插入得修改三个结点，首先是插入结点的前后指针，再是插入位置的后一结点的前指针，最后是插入结点位置的前一结点的后指针。 删除：假如删除的就是p结点，它的前后结点的指针都与他无关了，之前和它有关的都得改变。 123p-&gt;next-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=p-&gt;next;free(p);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"栈与队列","slug":"数据结构/队列","date":"2019-11-30T09:01:24.000Z","updated":"2019-11-30T08:37:21.767Z","comments":true,"path":"2019/11/30/数据结构/队列/","link":"","permalink":"http://yoursite.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/","excerpt":"","text":"栈与队列栈是限定仅在表尾进行插入和删除操作的线性表。队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表。 栈栈的操作顺序类似idea等软件的撤销按钮，后来的先返回。把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom）。栈是后进先出，LAST IN FIRST OUT，叫LIFO结构。 栈的顺序存储结构可以把栈想成线性表顺序存储结构的简化，简称顺序栈。把栈顶看成游标卡尺的游标，栈底固定位置，栈顶来回移动。 也可以看成子弹上膛。 两栈共享空间栈的存库空间必须事先定好，所以一般都会设计出合适的大小数组来处理。但是对于两个同类型的栈，我们可以做到最大限度利用他们的存储空间。 让第一个满了的栈的栈顶接上另一个未满栈的栈顶。使用这样的数据结构，通常是两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。如果不是两个具有相同数据类型的栈的，使用这个办法反而会使问题变复杂。 栈的的链式存储结构简称链栈。栈顶放在链表的头部，头指针和栈顶指针合二为一。对于链栈来说，基本不存在栈满的情况。 入栈操作： 123456789101112Status Push(LinkStack *S,SElemType e) &#123;//先创建一个需要插入的结点 LinkStackPtr s = (LinkStackPtr)malloc(sizeOf(StackNode)); //对s结点进行赋值和指向操作 s-&gt;data=e; //因为栈中的元素是从栈顶往栈底传递的，栈顶元素保存的下一结点的地址就是它下面一位元素 s-&gt;next=S-&gt;top; //对栈操作 S-&gt;top=s; S-&gt;count++; return ok;&#125; 如图所示： 出栈操作： 123456789101112131415Status Pop(LinkStack *S,SElemType *e)&#123; LinkStackPtr p; if(StackEmpty(*S)) return ERROR; //拿到栈顶的数据 *e=S-&gt;top-&gt;data; p=S-&gt;top; //将栈顶指针下移 S-&gt;top=S-&gt;top-&gt;next; //释放删除的结点 free(p); S-&gt;count--; return OK;&#125; 顺序栈和链栈的区别它们的时间复杂度是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定长度，可能会存在内存空间浪费问题，但是它存取时定位很方便，而链栈则要求每个元素都有指针域，这同时增加了内存开销，但对于栈的长度无限制。如果栈使用过程中元素变化不可预料，有时很小，有时非常大，那么最好用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。 栈的作用为何我们不用数组或者链表直接实现功能？因为栈的引入简化了程序设计的问题，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组，会需要分散精力去考虑数组的下标增减等细节问题，反而有掩盖了问题的本质。 栈的应用-递归关键词：斐波那契数列(Fibonacci) 迭代 递归 现在假设有一个数学函数： 打印前40位的斐波那契数列数，使用迭代，代码如下： 123456789101112131415int main()&#123; int i; int a[40]; a[0]=0; a[1]=1; printf(\"%d\",a[0]); printf(\"%d\",a[1]); for(i=2;i&lt;40;i++) &#123; a[i]=a[i-1]+a[i-2]; printf(\"%d\",a[i]); &#125; return 0;&#125; 使用迭代代码简单，容易理解，但是过于冗长。 使用递归： 123456789101112131415int Fbi(int i)&#123; if(i&lt;2) return i== 0?0:1; return Fbi(i-1)+Fbi(i-2);&#125;int main()&#123; int i; for(int i=0;i&lt;40;i++) &#123; printf(\"%d\",Fbi(i)); &#125; return 0;&#125; 递归是自己调用自己，我们可以把它看做是调用另一个函数；只不过，这个函数和自己长得一样。 每个递归定义必须至少有一个条件，满足时递归不在进行，即不再引用自身而是返回值退出。避免陷入永不结束的无穷递归中。 递归和迭代的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰，更简洁，更容易让人理解，从而减少读懂代码的时间。但大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代不需要反复调用函数和占用额外的内存。 这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合这样的数据结构，因此，编译器使用栈实现递归。 后缀表达式这是波兰逻辑学家提出的，它将传统的四则运算表达式，改造成去掉括号，运算符在运算数字之后出现的形式。 例如：9+(3-1)*3+10/2改造为9 3 1 - 3 * + 10 2 / + 如何看这个改造结果呢？理解起来就是：从左到右写数字，原则是运算符在计算的两个数字之后，但是要考虑括号和乘除优先写运算符。所以看成三块9 |+| (3-1)*3 |+| 10/2每一块又按这个原则来分。 9 3 1 - 3 * + 10 2 / +这个表达式计算机如何处理呢？计算机的做法是遇到数字就入栈，遇到运算符就将栈顶的两个数出栈进行运算(注意顺序)，将运算结果再入栈，这样直到最后的运算符。 队列queue是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。是一种先进先出的线性表，简称FIFO。允许插入的叫队尾，允许删除的一端称为队头。 键盘输入到屏幕输出用的就是队列。 循环队列当队列是顺序结构时，假设这个队列能放n个元素，那么它的长度必须是大于n的，并且要把队列的所有元素存储在数组的前n个单元，数组下标为0的一端就是队头。入队，就是在队尾加入一个元素，不用移动任何元素。出队，需要将除第一个元素的所有元素前移。所以入队的时间复杂度为o(1)，出队是o(n)。 如果我们不去限制队列的元素必须放在数组的前n个单元，出队的下标就不需要一定在下标为0的位置。 我们把队列这种头尾相接的顺序存储结构称为循环队列。 如何判断是否为空或者满呢？ 设置一个标识flag，当front==rear，且flag=0时为队列空；当front==rear，且flag=1时为队列满 当队列空时，条件就是front==rear。当队列满，数组中会有一个空闲位置，不让rear==front。 循环队列入队操作(顺序结构)1234567891011Status EnQueue(SqQueue *Q,QElemType e)&#123; //判断队列是否满 if((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front) return ERROR; //将元素e赋值给队尾，数组 Q-&gt;data[Q-&gt;rear]=e; //rear指针后移 Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE; return OK;&#125; 循环队列出队操作(顺序结构)1234567891011Status DeQueue(SqQueue *Q,QElemType *e)&#123; //队列为空的判断 if(Q-&gt;front == Q-&gt;rear) return ERROR; //取出要删除的数据 *e=Q-&gt;data[Q-&gt;front]; //队头后移 Q-&gt;front=(Q-&gt;front+1)%MAXSIZE; return OK;&#125; 入队(链式结构)将队头指针指向链对列的头结点，而队尾指针指向终端结点 1234567891011121314Status EnQueue(LinkQueue *Q,QElemType e)&#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); if(!s) exit(OVERFLOW); //对入队结点赋值 s-&gt;data=e; s-&gt;next=NULL; //将结点加入队列 Q-&gt;rear-&gt;next=s; //移动队尾指针 Q-&gt;rear=s; return OK;&#125; 出队(链式结构)出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点。如果链表除了头结点外只有一个元素，则需要将rear指向头结点。 12345678910111213141516Status DeQueue(LinkQueue *Q,QElemType *e)&#123; //新结点来保存信息 QueuePtr p; if(Q-&gt;front == Q-&gt;rear) return ERROR; //头结点的后继(被删除的结点)信息保存在p结点中 p=Q-&gt;front-&gt;next; *e=p-&gt;data; Q-&gt;front-&gt;next=p-&gt;next; //如果删除的结点是唯一结点 if(Q-&gt;rear==p) q-&gt;rear=Q-&gt;front; free(p); return OK;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]}]}